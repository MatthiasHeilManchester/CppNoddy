\doxysubsection{Tests/\+H\+Y\+P\+\_\+2\+D/\+H\+Y\+P2\+D\+Nonlinear\+Advection\+XY.cpp File Reference}
\label{HYP2DNonlinearAdvectionXY_8cpp}\index{Tests/HYP\_2D/HYP2DNonlinearAdvectionXY.cpp@{Tests/HYP\_2D/HYP2DNonlinearAdvectionXY.cpp}}
{\ttfamily \#include $<$Two\+D\+\_\+\+H\+Y\+P\+\_\+bundle.\+h$>$}\newline
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Cpp\+Noddy\+::\+Example\+::\+Nlin\+Adv}
\begin{DoxyCompactList}\small\item\em Define the system. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \textbf{ Cpp\+Noddy}
\begin{DoxyCompactList}\small\item\em A collection of OO numerical routines aimed at simple (typical) applied problems in continuum mechanics. \end{DoxyCompactList}\item 
 \textbf{ Cpp\+Noddy\+::\+Example}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Cpp\+Noddy\+::\+Example\+::\+Q\+\_\+init} (const double \&x, const double \&y, \textbf{ Dense\+Vector}$<$ double $>$ \&q)
\begin{DoxyCompactList}\small\item\em Set the initial state of the system. \end{DoxyCompactList}\item 
int \textbf{ main} ()
\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
Solving the 2D `nonlinear advection equation' \[ Q_t + \left ( \frac{Q^2}{\sqrt{2}} \right )_x + \left ( \frac{Q^2}{\sqrt{2}} \right )_y = 0 \quad \mbox{where} \quad Q=Q(x,y,t) \] using a T\+VD Lax-\/\+Friedrichs scheme for $ (x,y)\in[-1,1]\times[-1,1]$. The initial condition is a sine distribution. 

\doxysubsubsection{Function Documentation}
\mbox{\label{HYP2DNonlinearAdvectionXY_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}} 
\index{HYP2DNonlinearAdvectionXY.cpp@{HYP2DNonlinearAdvectionXY.cpp}!main@{main}}
\index{main@{main}!HYP2DNonlinearAdvectionXY.cpp@{HYP2DNonlinearAdvectionXY.cpp}}
\doxyparagraph{main()}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 66 of file H\+Y\+P2\+D\+Nonlinear\+Advection\+X\+Y.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{67 \{}
\DoxyCodeLine{68   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{69   cout << \textcolor{stringliteral}{"=== Hyperbolic: 2D nonlinear advection at an angle ==\(\backslash\)n"};}
\DoxyCodeLine{70   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{71 }
\DoxyCodeLine{72   std::string dirname(\textcolor{stringliteral}{"./DATA"});}
\DoxyCodeLine{73   mkdir( dirname.c\_str(), S\_IRWXU );}
\DoxyCodeLine{74   std::string filename\_stub( \textcolor{stringliteral}{"./DATA/HYP\_2D\_nlin\_adv\_xy"} );}
\DoxyCodeLine{75 }
\DoxyCodeLine{76   \textcolor{comment}{// define the domain/mesh}}
\DoxyCodeLine{77   \textcolor{keyword}{const} \textcolor{keywordtype}{double} west =  -\/1.0;}
\DoxyCodeLine{78   \textcolor{keyword}{const} \textcolor{keywordtype}{double} east =  1.0;}
\DoxyCodeLine{79   \textcolor{keyword}{const} \textcolor{keywordtype}{double} south =  -\/1.0;}
\DoxyCodeLine{80   \textcolor{keyword}{const} \textcolor{keywordtype}{double} north = 1.0;}
\DoxyCodeLine{81   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} N = 151;}
\DoxyCodeLine{82   DenseVector<double> faces\_x = Utility::uniform\_node\_vector( west, east, N );}
\DoxyCodeLine{83   DenseVector<double> faces\_y = Utility::uniform\_node\_vector( south, north, N );}
\DoxyCodeLine{84 }
\DoxyCodeLine{85   Example::NlinAdv conservative\_problem;}
\DoxyCodeLine{86   TwoD\_TVDLF\_Mesh NlinAdv\_mesh( faces\_x, faces\_y, \&conservative\_problem, Example::Q\_init );}
\DoxyCodeLine{87   NlinAdv\_mesh.set\_limiter( 0 );}
\DoxyCodeLine{88 }
\DoxyCodeLine{89   \textcolor{keywordtype}{double} asym( 0.0 );}
\DoxyCodeLine{90   \textcolor{keywordtype}{unsigned} loop\_counter( 0 );}
\DoxyCodeLine{91   DenseVector<double> x1( 2, 0.0 );}
\DoxyCodeLine{92   x1[ 0 ] = 0.75;}
\DoxyCodeLine{93   x1[ 1 ] = 0.75;}
\DoxyCodeLine{94   DenseVector<double> x2( 2, 0.0 );}
\DoxyCodeLine{95   x2[ 0 ] = -\/0.75;}
\DoxyCodeLine{96   x2[ 1 ] = -\/0.75;}
\DoxyCodeLine{97   \textcolor{keywordflow}{do}}
\DoxyCodeLine{98   \{}
\DoxyCodeLine{99     NlinAdv\_mesh.update( 0.49 );}
\DoxyCodeLine{100     NlinAdv\_mesh.dump\_gnu( filename\_stub + Utility::stringify( loop\_counter ) + \textcolor{stringliteral}{"\_gnu.dat"} );}
\DoxyCodeLine{101 }
\DoxyCodeLine{102     asym = std::max( asym, std::abs( NlinAdv\_mesh.get\_point\_values( x1 )[0] + NlinAdv\_mesh.get\_point\_values( x2 )[0] ) );}
\DoxyCodeLine{103     ++loop\_counter;}
\DoxyCodeLine{104   \}}
\DoxyCodeLine{105   \textcolor{keywordflow}{while} ( ( NlinAdv\_mesh.get\_time() < 0.4 ) \&\& ( loop\_counter < 1000 ) );}
\DoxyCodeLine{106 }
\DoxyCodeLine{107   \textcolor{comment}{// problem should be antisymmetric about x = 1/2}}
\DoxyCodeLine{108   \textcolor{keywordflow}{if} ( ( asym > 1.e-\/9 ) || ( loop\_counter >= 1000 ) )}
\DoxyCodeLine{109   \{}
\DoxyCodeLine{110     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;31;48m  * FAILED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{111     cout << \textcolor{stringliteral}{"asymmetry = "} << asym << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{112     cout << \textcolor{stringliteral}{"loop counter = "} << loop\_counter << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{113     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{114   \}}
\DoxyCodeLine{115   \textcolor{keywordflow}{else}}
\DoxyCodeLine{116   \{}
\DoxyCodeLine{117     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;32;48m  * PASSED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{118     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{119   \}}
\DoxyCodeLine{120 }
\DoxyCodeLine{121 \} \textcolor{comment}{// end of main()}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::dump\+\_\+gnu(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+point\+\_\+values(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+time(), Cpp\+Noddy\+::\+Example\+::\+Q\+\_\+init(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::set\+\_\+limiter(), Cpp\+Noddy\+::\+Utility\+::stringify(), Cpp\+Noddy\+::\+Utility\+::uniform\+\_\+node\+\_\+vector(), and Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::update().

