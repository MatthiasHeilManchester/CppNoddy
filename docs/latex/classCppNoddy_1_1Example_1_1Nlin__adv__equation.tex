\doxysubsection{Cpp\+Noddy\+::Example\+::Nlin\+\_\+adv\+\_\+equation Class Reference}
\label{classCppNoddy_1_1Example_1_1Nlin__adv__equation}\index{CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}}
Inheritance diagram for Cpp\+Noddy\+::Example\+::Nlin\+\_\+adv\+\_\+equation\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5.000000cm]{classCppNoddy_1_1Example_1_1Nlin__adv__equation}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Nlin\+\_\+adv\+\_\+equation} ()
\begin{DoxyCompactList}\small\item\em The problem is 2nd order and real. \end{DoxyCompactList}\item 
void \textbf{ residual\+\_\+fn} (const \textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ z}, \textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ f}) const
\begin{DoxyCompactList}\small\item\em Define a nonlinear advection diffusion problem. \end{DoxyCompactList}\item 
void \textbf{ matrix0} (const \textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ z}, \textbf{ Dense\+Matrix}$<$ double $>$ \&\textbf{ m}) const
\begin{DoxyCompactList}\small\item\em Define the derivative terms by providing the mass matrix -- identity in this case. \end{DoxyCompactList}\item 
void \textbf{ get\+\_\+jacobian\+\_\+of\+\_\+matrix0\+\_\+mult\+\_\+vector} (const \textbf{ Dense\+Vector}$<$ double $>$ \&state, const \textbf{ Dense\+Vector}$<$ double $>$ \&vec, \textbf{ Dense\+Matrix}$<$ double $>$ \&\textbf{ h}) const
\begin{DoxyCompactList}\small\item\em Return the product of the Jacobian-\/of-\/the-\/matrix and a vector \textquotesingle{}vec\textquotesingle{} when the equation has a given \textquotesingle{}state\textquotesingle{}. \end{DoxyCompactList}\item 
void \textbf{ matrix1} (const \textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ z}, \textbf{ Dense\+Matrix}$<$ double $>$ \&\textbf{ m}) const
\begin{DoxyCompactList}\small\item\em Define the unsteady terms by providing the mass matrix. \end{DoxyCompactList}\item 
void \textbf{ get\+\_\+jacobian\+\_\+of\+\_\+matrix1\+\_\+mult\+\_\+vector} (const \textbf{ Dense\+Vector}$<$ double $>$ \&state, const \textbf{ Dense\+Vector}$<$ double $>$ \&vec, \textbf{ Dense\+Matrix}$<$ double $>$ \&\textbf{ h}) const
\begin{DoxyCompactList}\small\item\em Return the product of the Jacobian-\/of-\/the-\/matrix and a vector \textquotesingle{}vec\textquotesingle{} when the equation has a given \textquotesingle{}state\textquotesingle{}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}


\doxysubsubsection{Detailed Description}


Definition at line 38 of file I\+B\+V\+P\+Nonlinear\+Adv\+Diffusion.\+cpp.



\doxysubsubsection{Constructor \& Destructor Documentation}
\mbox{\label{classCppNoddy_1_1Example_1_1Nlin__adv__equation_accebfe5bc08196d0df521001cbde22fb}} 
\index{CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}!Nlin\_adv\_equation@{Nlin\_adv\_equation}}
\index{Nlin\_adv\_equation@{Nlin\_adv\_equation}!CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}}
\doxyparagraph{Nlin\_adv\_equation()}
{\footnotesize\ttfamily Cpp\+Noddy\+::\+Example\+::\+Nlin\+\_\+adv\+\_\+equation\+::\+Nlin\+\_\+adv\+\_\+equation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



The problem is 2nd order and real. 



Definition at line 43 of file I\+B\+V\+P\+Nonlinear\+Adv\+Diffusion.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{43 : Equation\_2matrix<double> ( 2 ) \{\}}

\end{DoxyCode}


\doxysubsubsection{Member Function Documentation}
\mbox{\label{classCppNoddy_1_1Example_1_1Nlin__adv__equation_aaf26a8674b9b502a2ed0bf8c85a22b6a}} 
\index{CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}!get\_jacobian\_of\_matrix0\_mult\_vector@{get\_jacobian\_of\_matrix0\_mult\_vector}}
\index{get\_jacobian\_of\_matrix0\_mult\_vector@{get\_jacobian\_of\_matrix0\_mult\_vector}!CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}}
\doxyparagraph{get\_jacobian\_of\_matrix0\_mult\_vector()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::\+Nlin\+\_\+adv\+\_\+equation\+::get\+\_\+jacobian\+\_\+of\+\_\+matrix0\+\_\+mult\+\_\+vector (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{state,  }\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{vec,  }\item[{\textbf{ Dense\+Matrix}$<$ double $>$ \&}]{h }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Return the product of the Jacobian-\/of-\/the-\/matrix and a vector \textquotesingle{}vec\textquotesingle{} when the equation has a given \textquotesingle{}state\textquotesingle{}. 

The user should overload this if concerned about performance of the solver. If not overloaded, the default is to finite difference the Jacobian-\/of-\/the-\/matrix. 
\begin{DoxyParams}{Parameters}
{\em state} & The current state variables -- used for clarity when overloaded by the user instead of expecting the user to access the member data. \\
\hline
{\em vec} & The vector that will be multiplied by the Jacobian-\/of-\/the-\/matrix \\
\hline
{\em h} & The resulting 2D matrix \\
\hline
\end{DoxyParams}
constant mass matrix, so we\textquotesingle{}ll overlload this as empty to speed things up

Reimplemented from \textbf{ Cpp\+Noddy\+::\+Equation\+\_\+1matrix$<$ double, double $>$} \doxyref{}{p.}{classCppNoddy_1_1Equation__1matrix_a293c22844ca906668d9c13945438fa09}.



Definition at line 59 of file I\+B\+V\+P\+Nonlinear\+Adv\+Diffusion.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{60       \{\textcolor{comment}{}}
\DoxyCodeLine{61 \textcolor{comment}{        /// constant mass matrix, so we'll overlload this as empty to speed things up}}
\DoxyCodeLine{62 \textcolor{comment}{}      \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1Example_1_1Nlin__adv__equation_a9520ea779d20c59841ac5265fa93b889}} 
\index{CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}!get\_jacobian\_of\_matrix1\_mult\_vector@{get\_jacobian\_of\_matrix1\_mult\_vector}}
\index{get\_jacobian\_of\_matrix1\_mult\_vector@{get\_jacobian\_of\_matrix1\_mult\_vector}!CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}}
\doxyparagraph{get\_jacobian\_of\_matrix1\_mult\_vector()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::\+Nlin\+\_\+adv\+\_\+equation\+::get\+\_\+jacobian\+\_\+of\+\_\+matrix1\+\_\+mult\+\_\+vector (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{state,  }\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{vec,  }\item[{\textbf{ Dense\+Matrix}$<$ double $>$ \&}]{h }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Return the product of the Jacobian-\/of-\/the-\/matrix and a vector \textquotesingle{}vec\textquotesingle{} when the equation has a given \textquotesingle{}state\textquotesingle{}. 

The user should overload this if concerned about performance of the solver. If not overloaded, the default is to finite difference the Jacobian-\/of-\/the-\/matrix. 
\begin{DoxyParams}{Parameters}
{\em state} & The current state variables -- used for clarity when overloaded by the user instead of expecting the user to access the member data. \\
\hline
{\em vec} & The vector that will be multiplied by the Jacobian-\/of-\/the-\/matrix \\
\hline
{\em h} & The resulting 2D matrix \\
\hline
\end{DoxyParams}


Reimplemented from \textbf{ Cpp\+Noddy\+::\+Equation\+\_\+2matrix$<$ double $>$} \doxyref{}{p.}{classCppNoddy_1_1Equation__2matrix_a5b3040cf23a1a082ebab4a819102ceee}.



Definition at line 70 of file I\+B\+V\+P\+Nonlinear\+Adv\+Diffusion.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{71       \{}
\DoxyCodeLine{72         h( 1, U ) = -\/ Re * vec[ 0 ];}
\DoxyCodeLine{73       \}}

\end{DoxyCode}


References h, Cpp\+Noddy\+::\+Example\+::\+Re, and Cpp\+Noddy\+::\+Example\+::\+U().

\mbox{\label{classCppNoddy_1_1Example_1_1Nlin__adv__equation_a336c5cb00dedb30f5ccfe8ce3ae16434}} 
\index{CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}!matrix0@{matrix0}}
\index{matrix0@{matrix0}!CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}}
\doxyparagraph{matrix0()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::\+Nlin\+\_\+adv\+\_\+equation\+::matrix0 (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{z,  }\item[{\textbf{ Dense\+Matrix}$<$ double $>$ \&}]{m }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Define the derivative terms by providing the mass matrix -- identity in this case. 



Reimplemented from \textbf{ Cpp\+Noddy\+::\+Equation\+\_\+1matrix$<$ double, double $>$} \doxyref{}{p.}{classCppNoddy_1_1Equation__1matrix_af3f73a36fb2ec75a03f0298874d30e4c}.



Definition at line 54 of file I\+B\+V\+P\+Nonlinear\+Adv\+Diffusion.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{55       \{}
\DoxyCodeLine{56         m(0,0)=1;m(1,1)=1;}
\DoxyCodeLine{57       \}}

\end{DoxyCode}


References m.

\mbox{\label{classCppNoddy_1_1Example_1_1Nlin__adv__equation_aa4b925e6bce4fcab44cd7b0af0507cfe}} 
\index{CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}!matrix1@{matrix1}}
\index{matrix1@{matrix1}!CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}}
\doxyparagraph{matrix1()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::\+Nlin\+\_\+adv\+\_\+equation\+::matrix1 (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{z,  }\item[{\textbf{ Dense\+Matrix}$<$ double $>$ \&}]{m }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Define the unsteady terms by providing the mass matrix. 



Reimplemented from \textbf{ Cpp\+Noddy\+::\+Equation\+\_\+2matrix$<$ double $>$} \doxyref{}{p.}{classCppNoddy_1_1Equation__2matrix_a362eab539b08f747e8360d5d1a0934e8}.



Definition at line 65 of file I\+B\+V\+P\+Nonlinear\+Adv\+Diffusion.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{66       \{}
\DoxyCodeLine{67         m( 1, 0 ) = -\/ Re * z[ U ];}
\DoxyCodeLine{68       \}}

\end{DoxyCode}


References m, Cpp\+Noddy\+::\+Example\+::\+Re, Cpp\+Noddy\+::\+Example\+::\+U(), and Cpp\+Noddy\+::\+Example\+::z().

\mbox{\label{classCppNoddy_1_1Example_1_1Nlin__adv__equation_a338d541e09760023f032f46bc897778b}} 
\index{CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}!residual\_fn@{residual\_fn}}
\index{residual\_fn@{residual\_fn}!CppNoddy::Example::Nlin\_adv\_equation@{CppNoddy::Example::Nlin\_adv\_equation}}
\doxyparagraph{residual\_fn()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::\+Nlin\+\_\+adv\+\_\+equation\+::residual\+\_\+fn (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{z,  }\item[{\textbf{ Dense\+Vector}$<$ double $>$ \&}]{f }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Define a nonlinear advection diffusion problem. 



Reimplemented from \textbf{ Cpp\+Noddy\+::\+Residual$<$ double $>$} \doxyref{}{p.}{classCppNoddy_1_1Residual_a8016270e2cd26406a3681087f4a105c8}.



Definition at line 46 of file I\+B\+V\+P\+Nonlinear\+Adv\+Diffusion.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{47       \{}
\DoxyCodeLine{48         \textcolor{comment}{// The system}}
\DoxyCodeLine{49         f[ U ] = z[ Ud ];}
\DoxyCodeLine{50         f[ Ud ] = source( coord(0), coord(1) );}
\DoxyCodeLine{51       \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Residual\+\_\+with\+\_\+coords$<$ double, double $>$\+::coord(), f, Cpp\+Noddy\+::\+Example\+::source(), Cpp\+Noddy\+::\+Example\+::\+U(), Ud, and Cpp\+Noddy\+::\+Example\+::z().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Tests/\+I\+B\+V\+P/\textbf{ I\+B\+V\+P\+Nonlinear\+Adv\+Diffusion.\+cpp}\end{DoxyCompactItemize}
