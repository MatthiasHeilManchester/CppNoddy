\doxysubsection{Tests/\+Poisson/\+Poisson\+Cartesian\+\_\+petscd\+\_\+mumps.cpp File Reference}
\label{PoissonCartesian__petscd__mumps_8cpp}\index{Tests/Poisson/PoissonCartesian\_petscd\_mumps.cpp@{Tests/Poisson/PoissonCartesian\_petscd\_mumps.cpp}}
{\ttfamily \#include $<$Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h$>$}\newline
{\ttfamily \#include $<$Sparse\+Linear\+System.\+h$>$}\newline
{\ttfamily \#include $<$Dense\+Linear\+System.\+h$>$}\newline
{\ttfamily \#include $<$Utility.\+h$>$}\newline
{\ttfamily \#include $<$Petsc\+Session.\+h$>$}\newline
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \textbf{ Cpp\+Noddy}
\begin{DoxyCompactList}\small\item\em A collection of OO numerical routines aimed at simple (typical) applied problems in continuum mechanics. \end{DoxyCompactList}\item 
 \textbf{ Cpp\+Noddy\+::\+Example}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
double \textbf{ Cpp\+Noddy\+::\+Example\+::source\+\_\+fn} (const std\+::pair$<$ double, double $>$ \&coord)
\item 
double \textbf{ Cpp\+Noddy\+::\+Example\+::boundary\+\_\+fn} (const std\+::pair$<$ double, double $>$ \&coord)
\item 
int \textbf{ main} (int argc, char $\ast$argv[$\,$])
\end{DoxyCompactItemize}


\doxysubsubsection{Function Documentation}
\mbox{\label{PoissonCartesian__petscd__mumps_8cpp_a0ddf1224851353fc92bfbff6f499fa97}} 
\index{PoissonCartesian\_petscd\_mumps.cpp@{PoissonCartesian\_petscd\_mumps.cpp}!main@{main}}
\index{main@{main}!PoissonCartesian\_petscd\_mumps.cpp@{PoissonCartesian\_petscd\_mumps.cpp}}
\doxyparagraph{main()}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}\item[{int}]{argc,  }\item[{char $\ast$}]{argv[$\,$] }\end{DoxyParamCaption})}



Definition at line 38 of file Poisson\+Cartesian\+\_\+petscd\+\_\+mumps.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{39 \{}
\DoxyCodeLine{40   PetscSession::getInstance(argc,argv);}
\DoxyCodeLine{41 }
\DoxyCodeLine{42   \textcolor{comment}{// Number of points in a square mesh.}}
\DoxyCodeLine{43   \textcolor{keywordtype}{unsigned} Nx = 5;}
\DoxyCodeLine{44   \textcolor{keywordtype}{unsigned} Ny = 5;}
\DoxyCodeLine{45   }
\DoxyCodeLine{46   DenseVector<double> X = Utility::uniform\_node\_vector( -\/2.0, 2.0, Nx );}
\DoxyCodeLine{47   DenseVector<double> Y = Utility::uniform\_node\_vector( -\/1.0, 1.0, Ny );}
\DoxyCodeLine{48   TwoD\_Node\_Mesh<double> mesh(X,Y,2);}
\DoxyCodeLine{49   \textcolor{keywordtype}{double} dx2 = pow(X[1]-\/X[0],2);}
\DoxyCodeLine{50   \textcolor{keywordtype}{double} dy2 = pow(Y[1]-\/Y[0],2);}
\DoxyCodeLine{51   }
\DoxyCodeLine{52   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{53   cout << \textcolor{stringliteral}{"=== Poisson: Cartesian geometry =====================\(\backslash\)n"};}
\DoxyCodeLine{54   cout << \textcolor{stringliteral}{"    Solving in [-\/2 , 2] x [-\/1 , 1]      \(\backslash\)n"};}
\DoxyCodeLine{55   cout << \textcolor{stringliteral}{"    Using a "} << Nx << \textcolor{stringliteral}{"x"} << Ny << \textcolor{stringliteral}{" mesh\(\backslash\)n"};}
\DoxyCodeLine{56   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{57 }
\DoxyCodeLine{58   SparseMatrix<double> A(Nx*Ny,Nx*Ny);}
\DoxyCodeLine{59   DenseVector<double> B(Nx*Ny,0.0);}
\DoxyCodeLine{60   \{}
\DoxyCodeLine{61     \textcolor{comment}{// LHS}}
\DoxyCodeLine{62     \textcolor{keywordtype}{unsigned} i(0);}
\DoxyCodeLine{63     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j = 0; j < Ny; ++j) \{}
\DoxyCodeLine{64       A(j,j) = 1.0;}
\DoxyCodeLine{65       B[j] = Example::boundary\_fn(mesh.coord(i,j));}
\DoxyCodeLine{66     \}}
\DoxyCodeLine{67   \}}
\DoxyCodeLine{68   \textcolor{comment}{// step through x nodes}}
\DoxyCodeLine{69   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 1; i < Nx-\/1; ++i) \{}
\DoxyCodeLine{70     \textcolor{comment}{// bottom}}
\DoxyCodeLine{71     \textcolor{keywordtype}{unsigned} j = 0;}
\DoxyCodeLine{72     A(i*Ny+j,i*Ny+j) = 1.0;}
\DoxyCodeLine{73     B[i*Ny+j] = Example::boundary\_fn(mesh.coord(i,j));}
\DoxyCodeLine{74     \textcolor{keywordflow}{for} ( j = 1; j < Ny-\/1; ++j) \{}
\DoxyCodeLine{75       \textcolor{comment}{// interior nodes}}
\DoxyCodeLine{76       A(i*Ny+j,i*Ny+j-\/1) = 1./dy2;}
\DoxyCodeLine{77       A(i*Ny+j,i*Ny+j) = -\/2./dx2-\/2./dy2;}
\DoxyCodeLine{78       A(i*Ny+j,i*Ny+j+1) = 1./dy2;}
\DoxyCodeLine{79       A(i*Ny+j,i*Ny+j+Ny) = 1./dx2;}
\DoxyCodeLine{80       A(i*Ny+j,i*Ny+j-\/Ny) = 1./dx2;}
\DoxyCodeLine{81       B[i*Ny+j] = Example::source\_fn(mesh.coord(i,j));}
\DoxyCodeLine{82     \}}
\DoxyCodeLine{83     \textcolor{comment}{// top}}
\DoxyCodeLine{84     j = Ny-\/1;}
\DoxyCodeLine{85     A(i*Ny+j,i*Ny+j) = 1.0;}
\DoxyCodeLine{86     B[i*Ny+j] = Example::boundary\_fn(mesh.coord(i,j));}
\DoxyCodeLine{87   \}}
\DoxyCodeLine{88   \{}
\DoxyCodeLine{89     \textcolor{comment}{// RHS}}
\DoxyCodeLine{90     \textcolor{keywordtype}{unsigned} i(Nx-\/1);}
\DoxyCodeLine{91     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j = 0; j < Ny; ++j) \{}
\DoxyCodeLine{92       A(i*Ny+j,i*Ny+j) = 1.0;}
\DoxyCodeLine{93       B[i*Ny+j] = Example::boundary\_fn(mesh.coord(i,j));}
\DoxyCodeLine{94     \}}
\DoxyCodeLine{95   \}}
\DoxyCodeLine{96 }
\DoxyCodeLine{97   \textcolor{comment}{//A.dump();}}
\DoxyCodeLine{98   \textcolor{comment}{//B.dump();}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100   SparseLinearSystem<double> system(\&A,\&B,\textcolor{stringliteral}{"petsc"});}
\DoxyCodeLine{101   system.solve();}
\DoxyCodeLine{102 }
\DoxyCodeLine{103   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < Nx; ++i) \{}
\DoxyCodeLine{104     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j = 0; j < Ny; ++j) \{}
\DoxyCodeLine{105       \textcolor{keyword}{const} \textcolor{keywordtype}{double} x = mesh.coord(i,j).first; }
\DoxyCodeLine{106       \textcolor{keyword}{const} \textcolor{keywordtype}{double} y = mesh.coord(i,j).second;}
\DoxyCodeLine{107       \textcolor{comment}{// solution is quadratic in x,y so should be accurate on}}
\DoxyCodeLine{108       \textcolor{comment}{// any mesh}}
\DoxyCodeLine{109       mesh(i,j,0)=B[i*Nx+j];}
\DoxyCodeLine{110       mesh(i,j,1)=mesh(i,j,0) -\/ pow(x*y,2.0);}
\DoxyCodeLine{111     \}}
\DoxyCodeLine{112   \}}
\DoxyCodeLine{113 }
\DoxyCodeLine{114   mesh.dump\_gnu(\textcolor{stringliteral}{"./DATA/mesh.dat"});}
\DoxyCodeLine{115   }
\DoxyCodeLine{116   \textcolor{keywordtype}{bool} failed(\textcolor{keyword}{true});}
\DoxyCodeLine{117   \textcolor{keyword}{const} \textcolor{keywordtype}{double} tol(1.e-\/14);}
\DoxyCodeLine{118   \textcolor{keywordtype}{double} abserror = mesh.max\_abs(1);}
\DoxyCodeLine{119   cout << \textcolor{stringliteral}{"error = "} << abserror << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{120 }
\DoxyCodeLine{121   \textcolor{keywordflow}{if} ( abserror < tol ) failed = \textcolor{keyword}{false};}
\DoxyCodeLine{122 }
\DoxyCodeLine{123   \textcolor{keywordflow}{if} ( failed )}
\DoxyCodeLine{124   \{}
\DoxyCodeLine{125     cout << \textcolor{stringliteral}{"Poisson solver failed to give exact solution.\(\backslash\)n"};}
\DoxyCodeLine{126     cout << \textcolor{stringliteral}{"error = "} << abserror << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{127     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;31;48m  * FAILED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{128     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{129   \}}
\DoxyCodeLine{130   \textcolor{keywordflow}{else}}
\DoxyCodeLine{131   \{}
\DoxyCodeLine{132     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;32;48m  * PASSED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{133     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{134   \}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136 \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Example\+::\+A(), Cpp\+Noddy\+::\+Example\+::boundary\+\_\+fn(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::coord(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::dump\+\_\+gnu(), Cpp\+Noddy\+::\+Example\+::failed, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::max\+\_\+abs(), Cpp\+Noddy\+::\+Sparse\+Linear\+System$<$ \+\_\+\+Type $>$\+::solve(), Cpp\+Noddy\+::\+Example\+::source\+\_\+fn(), and Cpp\+Noddy\+::\+Utility\+::uniform\+\_\+node\+\_\+vector().

