\doxysubsection{Tests/\+H\+Y\+P\+\_\+2\+D/\+H\+Y\+P2\+D\+Nonlinear\+AdvectionY.cpp File Reference}
\label{HYP2DNonlinearAdvectionY_8cpp}\index{Tests/HYP\_2D/HYP2DNonlinearAdvectionY.cpp@{Tests/HYP\_2D/HYP2DNonlinearAdvectionY.cpp}}
{\ttfamily \#include $<$Two\+D\+\_\+\+H\+Y\+P\+\_\+bundle.\+h$>$}\newline
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Cpp\+Noddy\+::\+Example\+::\+Nlin\+Adv}
\begin{DoxyCompactList}\small\item\em Define the system. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \textbf{ Cpp\+Noddy}
\begin{DoxyCompactList}\small\item\em A collection of OO numerical routines aimed at simple (typical) applied problems in continuum mechanics. \end{DoxyCompactList}\item 
 \textbf{ Cpp\+Noddy\+::\+Example}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Cpp\+Noddy\+::\+Example\+::\+Q\+\_\+init} (const double \&x, const double \&y, \textbf{ Dense\+Vector}$<$ double $>$ \&q)
\begin{DoxyCompactList}\small\item\em Set the initial state of the system. \end{DoxyCompactList}\item 
int \textbf{ main} ()
\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
Solving the 1D `nonlinear advection equation' \[ Q_t + \left ( \frac{Q^2}{2} \right )_y = 0 \quad \mbox{where} \quad Q=Q(x,y,t) \] using a T\+VD Lax-\/\+Friedrichs scheme for $ (x,y)\in[-1,1]\times[-1,1]$. The initial condition is a sine distribution. 

\doxysubsubsection{Function Documentation}
\mbox{\label{HYP2DNonlinearAdvectionY_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}} 
\index{HYP2DNonlinearAdvectionY.cpp@{HYP2DNonlinearAdvectionY.cpp}!main@{main}}
\index{main@{main}!HYP2DNonlinearAdvectionY.cpp@{HYP2DNonlinearAdvectionY.cpp}}
\doxyparagraph{main()}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 77 of file H\+Y\+P2\+D\+Nonlinear\+Advection\+Y.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{78 \{}
\DoxyCodeLine{79 }
\DoxyCodeLine{80   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{81   cout << \textcolor{stringliteral}{"=== Hyperbolic: 2D nonlinear advection in y =========\(\backslash\)n"};}
\DoxyCodeLine{82   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{83 }
\DoxyCodeLine{84   \textcolor{comment}{// define the domain/mesh}}
\DoxyCodeLine{85   \textcolor{keyword}{const} \textcolor{keywordtype}{double} west =  1.0;}
\DoxyCodeLine{86   \textcolor{keyword}{const} \textcolor{keywordtype}{double} east = 0.0;}
\DoxyCodeLine{87   \textcolor{keyword}{const} \textcolor{keywordtype}{double} south =  0.0;}
\DoxyCodeLine{88   \textcolor{keyword}{const} \textcolor{keywordtype}{double} north = 1.0;}
\DoxyCodeLine{89   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} N = 51;}
\DoxyCodeLine{90   DenseVector<double> faces\_x = Utility::uniform\_node\_vector( east, west, N );}
\DoxyCodeLine{91   DenseVector<double> faces\_y = Utility::uniform\_node\_vector( south, north, N );}
\DoxyCodeLine{92 }
\DoxyCodeLine{93   Example::NlinAdv conservative\_problem;}
\DoxyCodeLine{94   TwoD\_TVDLF\_Mesh NlinAdv\_mesh( faces\_x, faces\_y, \&conservative\_problem, Example::Q\_init );}
\DoxyCodeLine{95   NlinAdv\_mesh.set\_limiter( 0 );}
\DoxyCodeLine{96 }
\DoxyCodeLine{97   \textcolor{keywordtype}{double} asym( 0.0 );}
\DoxyCodeLine{98   \textcolor{keywordtype}{unsigned} loop\_counter( 0 );}
\DoxyCodeLine{99   DenseVector<double> x1( 2, 0.0 );}
\DoxyCodeLine{100   x1[ 0 ] = 0.5;}
\DoxyCodeLine{101   x1[ 1 ] = 0.75;}
\DoxyCodeLine{102   DenseVector<double> x2( 2, 0.0 );}
\DoxyCodeLine{103   x2[ 0 ] = 0.5;}
\DoxyCodeLine{104   x2[ 1 ] = 0.25;}
\DoxyCodeLine{105   \textcolor{keywordflow}{do}}
\DoxyCodeLine{106   \{}
\DoxyCodeLine{107     NlinAdv\_mesh.update( 0.49 );}
\DoxyCodeLine{108     asym = std::max( asym, std::abs( NlinAdv\_mesh.get\_point\_values( x1 )[0] + NlinAdv\_mesh.get\_point\_values( x2 )[0] ) );}
\DoxyCodeLine{109     ++loop\_counter;}
\DoxyCodeLine{110   \}}
\DoxyCodeLine{111   \textcolor{keywordflow}{while} ( ( NlinAdv\_mesh.get\_time() < 0.4 ) \&\& ( loop\_counter < 1000 ) );}
\DoxyCodeLine{112 }
\DoxyCodeLine{113   \textcolor{comment}{// problem should be antisymmetric about y = 1/2}}
\DoxyCodeLine{114   \textcolor{keywordflow}{if} ( ( asym > 1.e-\/9 ) || ( loop\_counter >= 1000 ) )}
\DoxyCodeLine{115   \{}
\DoxyCodeLine{116     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;31;48m  * FAILED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{117     cout << \textcolor{stringliteral}{"asymmetry = "} << asym << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{118     cout << \textcolor{stringliteral}{"loop counter = "} << loop\_counter << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{119     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{120   \}}
\DoxyCodeLine{121   \textcolor{keywordflow}{else}}
\DoxyCodeLine{122   \{}
\DoxyCodeLine{123     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;32;48m  * PASSED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{124     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{125   \}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127 \} \textcolor{comment}{// end of main()}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+point\+\_\+values(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+time(), Cpp\+Noddy\+::\+Example\+::\+Q\+\_\+init(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::set\+\_\+limiter(), Cpp\+Noddy\+::\+Utility\+::uniform\+\_\+node\+\_\+vector(), and Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::update().

