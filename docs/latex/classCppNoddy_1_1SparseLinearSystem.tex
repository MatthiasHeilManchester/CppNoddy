\doxysubsection{Cpp\+Noddy\+::Sparse\+Linear\+System$<$ \+\_\+\+Type $>$ Class Template Reference}
\label{classCppNoddy_1_1SparseLinearSystem}\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}


A linear system class for vector right-\/hand sides.  




{\ttfamily \#include $<$Sparse\+Linear\+System.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Sparse\+Linear\+System} (\textbf{ Sparse\+Matrix}$<$ \+\_\+\+Type $>$ $\ast$Aptr, \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ $\ast$Bptr, std\+::string which=\char`\"{}native\char`\"{})
\begin{DoxyCompactList}\small\item\em Constructor for a sparse linear system object. \end{DoxyCompactList}\item 
\textbf{ $\sim$\+Sparse\+Linear\+System} ()
\begin{DoxyCompactList}\small\item\em Destructor for a linear system object. \end{DoxyCompactList}\item 
void \textbf{ cleanup} ()
\begin{DoxyCompactList}\small\item\em deallocates some objects \end{DoxyCompactList}\item 
void \textbf{ solve} ()
\begin{DoxyCompactList}\small\item\em Solve the sparse system. \end{DoxyCompactList}\item 
void \textbf{ factorise} ()
\begin{DoxyCompactList}\small\item\em Factorise the Ax=B system. \end{DoxyCompactList}\item 
void \textbf{ solve\+\_\+using\+\_\+factorisation} ()
\begin{DoxyCompactList}\small\item\em Resolve the same system using the same factorisation. \end{DoxyCompactList}\item 
void \textbf{ temp\+\_\+solve} ()
\item 
void \textbf{ factorise} ()
\item 
void \textbf{ solve\+\_\+using\+\_\+factorisation} ()
\item 
void \textbf{ factorise} ()
\item 
void \textbf{ solve\+\_\+using\+\_\+factorisation} ()
\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
\subsubsection*{template$<$typename \+\_\+\+Type$>$\newline
class Cpp\+Noddy\+::\+Sparse\+Linear\+System$<$ \+\_\+\+Type $>$}

A linear system class for vector right-\/hand sides. 

The class is constructed for S\+P\+A\+R\+SE problems of the form \[ A_{NxN} \,{\underline x}_i = B_{1xN} \]. 

Definition at line 20 of file Sparse\+Linear\+System.\+h.



\doxysubsubsection{Constructor \& Destructor Documentation}
\mbox{\label{classCppNoddy_1_1SparseLinearSystem_a7ce36e3aba144d2e2fe62d005d373521}} 
\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}!SparseLinearSystem@{SparseLinearSystem}}
\index{SparseLinearSystem@{SparseLinearSystem}!CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}
\doxyparagraph{SparseLinearSystem()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Sparse\+Linear\+System}$<$ \+\_\+\+Type $>$\+::\textbf{ Sparse\+Linear\+System} (\begin{DoxyParamCaption}\item[{\textbf{ Sparse\+Matrix}$<$ \+\_\+\+Type $>$ $\ast$}]{Aptr,  }\item[{\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ $\ast$}]{Bptr,  }\item[{std\+::string}]{which = {\ttfamily \char`\"{}native\char`\"{}} }\end{DoxyParamCaption})}



Constructor for a sparse linear system object. 


\begin{DoxyParams}{Parameters}
{\em Aptr} & A pointer to the \textquotesingle{}A matrix\textquotesingle{}, an NxN double/complex sparse matrix \\
\hline
{\em Bptr} & A pointer to the \textquotesingle{}B vector\textquotesingle{} a size N double/complex dense vector \\
\hline
{\em which} & A string that indicates which solver to use\+: native (default) pr petsc \\
\hline
\end{DoxyParams}


Definition at line 21 of file Sparse\+Linear\+System.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{21                                                                                                                     : m\_factorised(\textcolor{keyword}{false}) \{}
\DoxyCodeLine{22     m\_pA = Aptr;}
\DoxyCodeLine{23     m\_pB = Bptr;}
\DoxyCodeLine{24     m\_version = which;}
\DoxyCodeLine{25     \textcolor{comment}{//}}
\DoxyCodeLine{26     \textcolor{keywordflow}{if} (m\_version != \textcolor{stringliteral}{"petsc"}) \{}
\DoxyCodeLine{27       std::string problem;}
\DoxyCodeLine{28       problem = \textcolor{stringliteral}{"The SparseLinearSystem has been instantiated with an unrecognised\(\backslash\)n"};}
\DoxyCodeLine{29       problem += \textcolor{stringliteral}{"request for a solver type. Options: 'petsc'. \(\backslash\)n"};}
\DoxyCodeLine{30       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{31     \}}
\DoxyCodeLine{32     \textcolor{comment}{//}}
\DoxyCodeLine{33     \textcolor{keywordflow}{if}(m\_version == \textcolor{stringliteral}{"petsc"}) \{}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#if !defined(PETSC\_D) \&\& !defined(PETSC\_Z)}}
\DoxyCodeLine{35       std::string problem;}
\DoxyCodeLine{36       problem = \textcolor{stringliteral}{"The SparseLinearSystem has been instantiated for a petsc solver.\(\backslash\)n"};}
\DoxyCodeLine{37       problem += \textcolor{stringliteral}{"HOWEVER, CppNoddy was not compiled with PETSC\_D or PETSC\_Z defined.\(\backslash\)n"};}
\DoxyCodeLine{38       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{40     \}}
\DoxyCodeLine{41     \textcolor{comment}{//}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#if defined(PETSC\_D) || defined(PETSC\_Z)}}
\DoxyCodeLine{43     \textcolor{keywordflow}{if}(m\_version == \textcolor{stringliteral}{"petsc"}) \{}
\DoxyCodeLine{44       \textcolor{keywordtype}{int} flag(0);}
\DoxyCodeLine{45       MPI\_Initialized(\&flag);}
\DoxyCodeLine{46       \textcolor{keywordflow}{if}(flag != 1) \{}
\DoxyCodeLine{47         std::string problem;}
\DoxyCodeLine{48         problem = \textcolor{stringliteral}{"The SparseLinearSystem has been instantiated for a petsc solver.\(\backslash\)n"};}
\DoxyCodeLine{49         problem += \textcolor{stringliteral}{"You must call PetscInitialize before calling the petsc solver.\(\backslash\)n"};}
\DoxyCodeLine{50         \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{51       \}}
\DoxyCodeLine{52     \}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{54   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1SparseLinearSystem_ad4473046d4176d24622ac6eec430a056}} 
\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}!````~SparseLinearSystem@{$\sim$SparseLinearSystem}}
\index{````~SparseLinearSystem@{$\sim$SparseLinearSystem}!CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}
\doxyparagraph{$\sim$SparseLinearSystem()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Sparse\+Linear\+System}$<$ \+\_\+\+Type $>$\+::$\sim$\textbf{ Sparse\+Linear\+System}}



Destructor for a linear system object. 



Definition at line 57 of file Sparse\+Linear\+System.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{57                                                  \{}
\DoxyCodeLine{58     cleanup();}
\DoxyCodeLine{59   \}}

\end{DoxyCode}


\doxysubsubsection{Member Function Documentation}
\mbox{\label{classCppNoddy_1_1SparseLinearSystem_abbdfa5cd5a05afc9bcdb2dac7128fb57}} 
\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}!cleanup@{cleanup}}
\index{cleanup@{cleanup}!CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}
\doxyparagraph{cleanup()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Sparse\+Linear\+System}$<$ \+\_\+\+Type $>$\+::cleanup}



deallocates some objects 



Definition at line 62 of file Sparse\+Linear\+System.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{62                                           \{}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#if defined(PETSC\_D) || defined(PETSC\_Z)}}
\DoxyCodeLine{64     \textcolor{comment}{// delete objects used in the factorisation?}}
\DoxyCodeLine{65     \textcolor{keywordflow}{if}(m\_factorised) \{}
\DoxyCodeLine{66       VecDestroy(\&m\_petsc\_x);}
\DoxyCodeLine{67       VecDestroy(\&m\_petsc\_B);}
\DoxyCodeLine{68       KSPDestroy(\&m\_petsc\_ksp);}
\DoxyCodeLine{69       m\_factorised = \textcolor{keyword}{false};}
\DoxyCodeLine{70     \}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{72   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1SparseLinearSystem_a0af8aa6d0932a2122b932a27b309c026}} 
\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}!factorise@{factorise}}
\index{factorise@{factorise}!CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}
\doxyparagraph{factorise()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Sparse\+Linear\+System}$<$ \+\_\+\+Type $>$\+::factorise (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Factorise the Ax=B system. 



Referenced by main().

\mbox{\label{classCppNoddy_1_1SparseLinearSystem_a89b1fe8f66d794a05e578721f809fe20}} 
\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}!factorise@{factorise}}
\index{factorise@{factorise}!CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}
\doxyparagraph{factorise()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Sparse\+Linear\+System}$<$ double $>$\+::factorise (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 93 of file Sparse\+Linear\+System.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{93                                              \{}
\DoxyCodeLine{94 \textcolor{preprocessor}{\#if !defined(PETSC\_D)}}
\DoxyCodeLine{95     std::string problem;}
\DoxyCodeLine{96     problem = \textcolor{stringliteral}{"CppNoddy is linked against the COMPLEX version of PETSc\(\backslash\)n"};}
\DoxyCodeLine{97     problem += \textcolor{stringliteral}{"but you are trying to factorise a DOUBLE matrix. Either\(\backslash\)n"};}
\DoxyCodeLine{98     problem += \textcolor{stringliteral}{"redefine your matrix as complex, or recompile with \$PETSC\_ARCH\(\backslash\)n"};}
\DoxyCodeLine{99     problem += \textcolor{stringliteral}{"pointing to a DOUBLE version of the PETSc code."};}
\DoxyCodeLine{100     \textcolor{keywordflow}{throw} ExceptionExternal(problem);}
\DoxyCodeLine{101 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{102 \textcolor{preprocessor}{\#if defined(PETSC\_D)}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104     \textcolor{keywordflow}{if}(m\_factorised) \{}
\DoxyCodeLine{105       \textcolor{comment}{// already factorised -\/-\/ so delete and re-\/create below}}
\DoxyCodeLine{106       cleanup();}
\DoxyCodeLine{107     \}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109     \textcolor{comment}{// store a boolean to indicate that we}}
\DoxyCodeLine{110     m\_factorised = \textcolor{keyword}{true};}
\DoxyCodeLine{111     PetscInt Istart,Iend,n;}
\DoxyCodeLine{112     Mat petsc\_A;}
\DoxyCodeLine{113 }
\DoxyCodeLine{114     \textcolor{comment}{// size of the (assumed square) matrix}}
\DoxyCodeLine{115     n = m\_pA -\/> nrows();}
\DoxyCodeLine{116     \textcolor{comment}{/*}}
\DoxyCodeLine{117 \textcolor{comment}{       Create parallel vectors B (for RHS) \& x (for soln).}}
\DoxyCodeLine{118 \textcolor{comment}{    */}}
\DoxyCodeLine{119     VecCreate(PETSC\_COMM\_WORLD,\&m\_petsc\_B);}
\DoxyCodeLine{120     VecSetSizes(m\_petsc\_B,PETSC\_DECIDE,m\_pA-\/>nrows());}
\DoxyCodeLine{121     \textcolor{comment}{// add any command line configuration}}
\DoxyCodeLine{122     VecSetFromOptions(m\_petsc\_B);}
\DoxyCodeLine{123     \textcolor{comment}{// make a copy to define x}}
\DoxyCodeLine{124     VecDuplicate(m\_petsc\_B,\&m\_petsc\_x);}
\DoxyCodeLine{125 }
\DoxyCodeLine{126     }
\DoxyCodeLine{127     \textcolor{comment}{// configure the A matrix}}
\DoxyCodeLine{128     MatCreate(PETSC\_COMM\_WORLD,\&petsc\_A);}
\DoxyCodeLine{129     \textcolor{comment}{// set A to be an nxn matrix}}
\DoxyCodeLine{130     MatSetSizes(petsc\_A,PETSC\_DECIDE,PETSC\_DECIDE,n,n);}
\DoxyCodeLine{131     \textcolor{comment}{// add any command line configuration}}
\DoxyCodeLine{132     MatSetFromOptions(petsc\_A);}
\DoxyCodeLine{133 }
\DoxyCodeLine{134     \textcolor{comment}{// get: all\_rows\_nnz[i] is the number of nonzero elts in row i}}
\DoxyCodeLine{135     PetscInt* all\_rows\_nnz = \textcolor{keyword}{new} PetscInt[ n ];}
\DoxyCodeLine{136     m\_pA -\/> nelts\_all\_rows(all\_rows\_nnz);}
\DoxyCodeLine{137 }
\DoxyCodeLine{138     \textcolor{comment}{// pre-\/allocate memory using the number of non-\/zero elts}}
\DoxyCodeLine{139     \textcolor{comment}{// in each row (the 0 is ignored here)}}
\DoxyCodeLine{140     MatSeqAIJSetPreallocation(petsc\_A, 0, all\_rows\_nnz);}
\DoxyCodeLine{141     }
\DoxyCodeLine{142     \textcolor{comment}{// add any command line configuration}}
\DoxyCodeLine{143     MatSetFromOptions(petsc\_A);}
\DoxyCodeLine{144     \textcolor{comment}{// finish the A definition}}
\DoxyCodeLine{145     MatSetUp(petsc\_A);}
\DoxyCodeLine{146     }
\DoxyCodeLine{147     \textcolor{comment}{/*}}
\DoxyCodeLine{148 \textcolor{comment}{       petsc\_A is defined as Sequential above, so this is not strictly needed}}
\DoxyCodeLine{149 \textcolor{comment}{    */}}
\DoxyCodeLine{150     MatGetOwnershipRange(petsc\_A,\&Istart,\&Iend);}
\DoxyCodeLine{151     \textcolor{comment}{// populate the A matrix using the CppNoddy sparse matrix data}}
\DoxyCodeLine{152     \textcolor{keywordflow}{for}(PetscInt i = Istart; i<Iend; ++i) \{}
\DoxyCodeLine{153       \textcolor{comment}{// move the matrix data into PETSc format 1 row at a time}}
\DoxyCodeLine{154       std::size\_t nelts\_in\_row = all\_rows\_nnz[i]; }
\DoxyCodeLine{155       \textcolor{comment}{// row i has all\_rows\_nnz[i] elements that are non-\/zero, so we store their columns}}
\DoxyCodeLine{156       PetscInt* cols = \textcolor{keyword}{new} PetscInt[all\_rows\_nnz[i]];}
\DoxyCodeLine{157       \textcolor{comment}{// store the non-\/zero elts in this row}}
\DoxyCodeLine{158       PetscScalar* storage = \textcolor{keyword}{new} PetscScalar[all\_rows\_nnz[i]];}
\DoxyCodeLine{159       \textcolor{comment}{// get the data from the CppNoddy sparse matrix structure}}
\DoxyCodeLine{160       m\_pA -\/> get\_row\_petsc(i, storage, cols);}
\DoxyCodeLine{161       MatSetValues(petsc\_A,1,\&i,nelts\_in\_row,cols,storage,INSERT\_VALUES);}
\DoxyCodeLine{162       \textcolor{comment}{// delete temp storage made in the conversion}}
\DoxyCodeLine{163       \textcolor{keyword}{delete}[] cols;}
\DoxyCodeLine{164       \textcolor{keyword}{delete}[] storage;}
\DoxyCodeLine{165     \}}
\DoxyCodeLine{166     }
\DoxyCodeLine{167     \textcolor{comment}{// MatSetValue inserted values are generally cached}}
\DoxyCodeLine{168     \textcolor{comment}{// so we need to explicitly do final assembly}}
\DoxyCodeLine{169     MatAssemblyBegin(petsc\_A,MAT\_FINAL\_ASSEMBLY);}
\DoxyCodeLine{170     MatAssemblyEnd(petsc\_A,MAT\_FINAL\_ASSEMBLY);}
\DoxyCodeLine{171 }
\DoxyCodeLine{172     \textcolor{comment}{/* -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/}}
\DoxyCodeLine{173 \textcolor{comment}{                  Create the linear solver and set various options}}
\DoxyCodeLine{174 \textcolor{comment}{       -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/}}
\DoxyCodeLine{175 \textcolor{comment}{    */}}
\DoxyCodeLine{176     KSPCreate(PETSC\_COMM\_WORLD,\&m\_petsc\_ksp);}
\DoxyCodeLine{177     KSPSetOperators(m\_petsc\_ksp,petsc\_A,petsc\_A);}
\DoxyCodeLine{178 \textcolor{comment}{}}
\DoxyCodeLine{179 \textcolor{comment}{    /////////////////////////////}}
\DoxyCodeLine{180 \textcolor{comment}{}    \textcolor{comment}{// default solver is MUMPS //}\textcolor{comment}{}}
\DoxyCodeLine{181 \textcolor{comment}{    /////////////////////////////}}
\DoxyCodeLine{182 \textcolor{comment}{}    \textcolor{comment}{//KSPSetType(m\_petsc\_ksp,KSPPREONLY);}}
\DoxyCodeLine{183     KSPGetPC(m\_petsc\_ksp,\&m\_petsc\_pc);}
\DoxyCodeLine{184     \textcolor{comment}{// hardwire a DIRECT SOLVER via MUMPS}}
\DoxyCodeLine{185     \textcolor{comment}{//PCSetType(m\_petsc\_pc,PCLU);}}
\DoxyCodeLine{186     \textcolor{comment}{//PCFactorSetMatSolverType(m\_petsc\_pc,MATSOLVERMUMPS);}}
\DoxyCodeLine{187     \textcolor{comment}{//PCFactorSetUpMatSolverType(m\_petsc\_pc);}\textcolor{comment}{}}
\DoxyCodeLine{188 \textcolor{comment}{    /////////////////////////////}}
\DoxyCodeLine{189 \textcolor{comment}{}    KSPSetFromOptions(m\_petsc\_ksp);}
\DoxyCodeLine{190     KSPSetUp(m\_petsc\_ksp);}
\DoxyCodeLine{191 }
\DoxyCodeLine{192     \textcolor{comment}{/* create m\_petsc\_F */}}
\DoxyCodeLine{193     PCFactorGetMatrix(m\_petsc\_pc,\&m\_petsc\_F);}
\DoxyCodeLine{194 }
\DoxyCodeLine{195     \textcolor{comment}{/* increase estimate of working space by 20\% */}}
\DoxyCodeLine{196     \textcolor{comment}{// MatMumpsSetIcntl(m\_petsc\_F,14,20.0);}}
\DoxyCodeLine{197 }
\DoxyCodeLine{198     \textcolor{comment}{/* sequential ordering */}}
\DoxyCodeLine{199     \textcolor{comment}{// icntl = 7;}}
\DoxyCodeLine{200     \textcolor{comment}{// ival = 2;}}
\DoxyCodeLine{201     \textcolor{comment}{// MatMumpsSetIcntl(m\_petsc\_F,icntl,ival);}}
\DoxyCodeLine{202 }
\DoxyCodeLine{203     \textcolor{comment}{/* threshhold for row pivot detection */}}
\DoxyCodeLine{204     \textcolor{comment}{// MatMumpsSetIcntl(m\_petsc\_F,24,1);}}
\DoxyCodeLine{205     \textcolor{comment}{// icntl = 3;}}
\DoxyCodeLine{206     \textcolor{comment}{// val = 1.e-\/6;}}
\DoxyCodeLine{207     \textcolor{comment}{// MatMumpsSetCntl(m\_petsc\_F,icntl,val);}}
\DoxyCodeLine{208 }
\DoxyCodeLine{209     \textcolor{comment}{/* compute determinant of A */}}
\DoxyCodeLine{210     \textcolor{comment}{// MatMumpsSetIcntl(m\_petsc\_F,33,1);}}
\DoxyCodeLine{211     \textcolor{comment}{/* not used unless we initialise PETSc using the command line options */}}
\DoxyCodeLine{212     \textcolor{comment}{// KSPSetFromOptions(m\_petsc\_ksp);}}
\DoxyCodeLine{213     }
\DoxyCodeLine{214 }
\DoxyCodeLine{215     \textcolor{comment}{// /* determinant calculation */}}
\DoxyCodeLine{216     \textcolor{comment}{// \{}}
\DoxyCodeLine{217     \textcolor{comment}{//   PetscInt  icntl,infog34;}}
\DoxyCodeLine{218     \textcolor{comment}{//   PetscReal cntl,rinfo12,rinfo13;}}
\DoxyCodeLine{219     \textcolor{comment}{//   icntl = 3;}}
\DoxyCodeLine{220     \textcolor{comment}{//   MatMumpsGetCntl(F,icntl,\&cntl);}}
\DoxyCodeLine{221     \textcolor{comment}{//   // output determinant only the first proc.}}
\DoxyCodeLine{222     \textcolor{comment}{//   if (!rank)}}
\DoxyCodeLine{223     \textcolor{comment}{//   \{}}
\DoxyCodeLine{224     \textcolor{comment}{//     MatMumpsGetInfog(F,34,\&infog34);}}
\DoxyCodeLine{225     \textcolor{comment}{//     MatMumpsGetRinfog(F,12,\&rinfo12);}}
\DoxyCodeLine{226     \textcolor{comment}{//     MatMumpsGetRinfog(F,13,\&rinfo13);}}
\DoxyCodeLine{227     \textcolor{comment}{//     PetscPrintf(PETSC\_COMM\_SELF,"  Mumps row pivot threshhold = \%g\(\backslash\)n",cntl);}}
\DoxyCodeLine{228     \textcolor{comment}{//     PetscPrintf(PETSC\_COMM\_SELF,"  Mumps determinant = (\%g, \%g) * 2\string^\%D \(\backslash\)n",(double)rinfo12,(double)rinfo13,infog34);}}
\DoxyCodeLine{229     \textcolor{comment}{//   \}}}
\DoxyCodeLine{230     \textcolor{comment}{// \}}}
\DoxyCodeLine{231 }
\DoxyCodeLine{232     MatDestroy(\&petsc\_A);}
\DoxyCodeLine{233     \textcolor{keyword}{delete}[] all\_rows\_nnz;}
\DoxyCodeLine{234     }
\DoxyCodeLine{235 \textcolor{preprocessor}{\#endif // check for PETSC\_D/Z}}
\DoxyCodeLine{236   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1SparseLinearSystem_a048790b72c775dddc146530662bd6969}} 
\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}!factorise@{factorise}}
\index{factorise@{factorise}!CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}
\doxyparagraph{factorise()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Sparse\+Linear\+System}$<$ std\+::complex$<$ double $>$ $>$\+::factorise (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 301 of file Sparse\+Linear\+System.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{301                                                           \{}
\DoxyCodeLine{302 \textcolor{preprocessor}{\#if !defined(PETSC\_Z)}}
\DoxyCodeLine{303     std::string problem;}
\DoxyCodeLine{304     problem = \textcolor{stringliteral}{"CppNoddy is linked against the DOUBLE version of PETSc\(\backslash\)n"};}
\DoxyCodeLine{305     problem += \textcolor{stringliteral}{"but you are trying to factorise a COMPLEX matrix.\(\backslash\)n"};}
\DoxyCodeLine{306     problem += \textcolor{stringliteral}{"Recompile with \$PETSC\_ARCH\(\backslash\)n"};}
\DoxyCodeLine{307     problem += \textcolor{stringliteral}{"pointing to a COMPLEX version of the PETSc code."};}
\DoxyCodeLine{308     \textcolor{keywordflow}{throw} ExceptionExternal(problem);}
\DoxyCodeLine{309 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{310 }
\DoxyCodeLine{311 \textcolor{preprocessor}{\#if defined(PETSC\_Z)}}
\DoxyCodeLine{312     \textcolor{keywordflow}{if}(m\_factorised) \{}
\DoxyCodeLine{313       \textcolor{comment}{// already factorised -\/-\/ so delete and re-\/create below}}
\DoxyCodeLine{314       cleanup();}
\DoxyCodeLine{315     \}}
\DoxyCodeLine{316 }
\DoxyCodeLine{317     \textcolor{comment}{// store a boolean to indicate that we}}
\DoxyCodeLine{318     m\_factorised = \textcolor{keyword}{true};}
\DoxyCodeLine{319     PetscInt Istart,Iend,n;}
\DoxyCodeLine{320     Mat A;}
\DoxyCodeLine{321 }
\DoxyCodeLine{322     \textcolor{comment}{// size of the (assumed square) matrix}}
\DoxyCodeLine{323     n = m\_pA -\/> nrows();}
\DoxyCodeLine{324     \textcolor{comment}{/*}}
\DoxyCodeLine{325 \textcolor{comment}{       Create parallel vectors.}}
\DoxyCodeLine{326 \textcolor{comment}{    */}}
\DoxyCodeLine{327     VecCreate(PETSC\_COMM\_WORLD,\&m\_petsc\_B);}
\DoxyCodeLine{328     VecSetSizes(m\_petsc\_B,PETSC\_DECIDE,m\_pA-\/>nrows());}
\DoxyCodeLine{329     VecSetFromOptions(m\_petsc\_B);}
\DoxyCodeLine{330     VecDuplicate(m\_petsc\_B,\&m\_petsc\_x);}
\DoxyCodeLine{331 }
\DoxyCodeLine{332     \textcolor{comment}{// configure the A matrix}}
\DoxyCodeLine{333     MatCreate(PETSC\_COMM\_WORLD,\&A);}
\DoxyCodeLine{334     \textcolor{comment}{// set A to be an nxn matrix}}
\DoxyCodeLine{335     MatSetSizes(A,PETSC\_DECIDE,PETSC\_DECIDE,n,n);}
\DoxyCodeLine{336     MatSetFromOptions(A);}
\DoxyCodeLine{337 }
\DoxyCodeLine{338     \textcolor{comment}{// get: all\_rows\_nnz[i] is the number of nonzero elts in row i}}
\DoxyCodeLine{339     PetscInt* all\_rows\_nnz = \textcolor{keyword}{new} PetscInt[ n ];}
\DoxyCodeLine{340     m\_pA -\/> nelts\_all\_rows(all\_rows\_nnz);}
\DoxyCodeLine{341 }
\DoxyCodeLine{342     \textcolor{comment}{// pre-\/allocate memory using the number of non-\/zero elts}}
\DoxyCodeLine{343     \textcolor{comment}{// in each row (the 0 is ignored here)}}
\DoxyCodeLine{344     MatSeqAIJSetPreallocation(A, 0, all\_rows\_nnz);}
\DoxyCodeLine{345     MatSetUp(A);}
\DoxyCodeLine{346 }
\DoxyCodeLine{347     \textcolor{comment}{/*}}
\DoxyCodeLine{348 \textcolor{comment}{       Currently, all PETSc parallel matrix formats are partitioned by}}
\DoxyCodeLine{349 \textcolor{comment}{       contiguous chunks of rows across the processors.  Determine which}}
\DoxyCodeLine{350 \textcolor{comment}{       rows of the matrix are locally owned.}}
\DoxyCodeLine{351 \textcolor{comment}{    */}}
\DoxyCodeLine{352     MatGetOwnershipRange(A,\&Istart,\&Iend);}
\DoxyCodeLine{353     \textcolor{comment}{// populate the A matrix using the CppNoddy sparse matrix data}}
\DoxyCodeLine{354     \textcolor{keywordflow}{for}(PetscInt i = Istart; i<Iend; ++i) \{}
\DoxyCodeLine{355       \textcolor{comment}{// move the matrix data into PETSc format 1 row at a time}}
\DoxyCodeLine{356       std::size\_t nelts\_in\_row = all\_rows\_nnz[i];}
\DoxyCodeLine{357       \textcolor{comment}{// row i has all\_rows\_nnz[i] elements that are non-\/zero, so we store their columns}}
\DoxyCodeLine{358       PetscInt* cols = \textcolor{keyword}{new} PetscInt[nelts\_in\_row];}
\DoxyCodeLine{359       \textcolor{comment}{// store the non-\/zero elts in this row}}
\DoxyCodeLine{360       PetscScalar* storage = \textcolor{keyword}{new} PetscScalar[nelts\_in\_row];}
\DoxyCodeLine{361       \textcolor{comment}{// get the data from the CppNoddy sparse matrix structure}}
\DoxyCodeLine{362       m\_pA -\/> get\_row\_petsc(i, storage, cols);}
\DoxyCodeLine{363       MatSetValues(A,1,\&i,nelts\_in\_row,cols,storage,INSERT\_VALUES);}
\DoxyCodeLine{364       \textcolor{comment}{// delete temp storage made in the conversion}}
\DoxyCodeLine{365       \textcolor{keyword}{delete}[] cols;}
\DoxyCodeLine{366       \textcolor{keyword}{delete}[] storage;}
\DoxyCodeLine{367     \}}
\DoxyCodeLine{368 }
\DoxyCodeLine{369     \textcolor{comment}{/*}}
\DoxyCodeLine{370 \textcolor{comment}{       Assemble matrix, using the 2-\/step process:}}
\DoxyCodeLine{371 \textcolor{comment}{         MatAssemblyBegin(), MatAssemblyEnd()}}
\DoxyCodeLine{372 \textcolor{comment}{       Computations can be done while messages are in transition}}
\DoxyCodeLine{373 \textcolor{comment}{       by placing code between these two statements.}}
\DoxyCodeLine{374 \textcolor{comment}{    */}}
\DoxyCodeLine{375     MatAssemblyBegin(A,MAT\_FINAL\_ASSEMBLY);}
\DoxyCodeLine{376     MatAssemblyEnd(A,MAT\_FINAL\_ASSEMBLY);}
\DoxyCodeLine{377 }
\DoxyCodeLine{378     \textcolor{comment}{/* -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/}}
\DoxyCodeLine{379 \textcolor{comment}{                  Create the linear solver and set various options}}
\DoxyCodeLine{380 \textcolor{comment}{       -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/}}
\DoxyCodeLine{381 \textcolor{comment}{    */}}
\DoxyCodeLine{382     KSPCreate(PETSC\_COMM\_WORLD,\&m\_petsc\_ksp);}
\DoxyCodeLine{383     KSPSetOperators(m\_petsc\_ksp,A,A);}
\DoxyCodeLine{384 }
\DoxyCodeLine{385     \textcolor{comment}{//KSPSetType(m\_petsc\_ksp,KSPPREONLY);}}
\DoxyCodeLine{386     KSPGetPC(m\_petsc\_ksp,\&m\_petsc\_pc);}
\DoxyCodeLine{387     \textcolor{comment}{// hardwire a DIRECT SOLVER via MUMPS}}
\DoxyCodeLine{388     \textcolor{comment}{//PCSetType(m\_petsc\_pc,PCLU);}}
\DoxyCodeLine{389     \textcolor{comment}{//PCFactorSetMatSolverType(m\_petsc\_pc,MATSOLVERSUPERLU\_DIST);}}
\DoxyCodeLine{390     \textcolor{comment}{//PCFactorSetMatSolverType(m\_petsc\_pc,MATSOLVERMUMPS);}}
\DoxyCodeLine{391     \textcolor{comment}{//PCFactorSetMatSolverType(m\_petsc\_pc,MATSOLVERMKL\_PARDISO);}}
\DoxyCodeLine{392     \textcolor{comment}{//PCFactorSetUpMatSolverType(m\_petsc\_pc);}}
\DoxyCodeLine{393 }
\DoxyCodeLine{394     KSPSetFromOptions(m\_petsc\_ksp);}
\DoxyCodeLine{395 }
\DoxyCodeLine{396     KSPSetUp(m\_petsc\_ksp);}
\DoxyCodeLine{397     \textcolor{comment}{/* call MatGetFactor() to create F */}}
\DoxyCodeLine{398     PCFactorGetMatrix(m\_petsc\_pc,\&m\_petsc\_F);}
\DoxyCodeLine{399 }
\DoxyCodeLine{400     \textcolor{comment}{/* sequential ordering */}}
\DoxyCodeLine{401     \textcolor{comment}{//PetscInt  ival,icntl;}}
\DoxyCodeLine{402     \textcolor{comment}{//icntl = 7;}}
\DoxyCodeLine{403     \textcolor{comment}{//ival = 2;}}
\DoxyCodeLine{404     \textcolor{comment}{//MatMumpsSetIcntl(m\_petsc\_F,icntl,ival);}}
\DoxyCodeLine{405 }
\DoxyCodeLine{406     \textcolor{comment}{/* threshhold for row pivot detection */}}
\DoxyCodeLine{407     \textcolor{comment}{//MatMumpsSetIcntl(m\_petsc\_F,24,1);}}
\DoxyCodeLine{408     \textcolor{comment}{//icntl = 3;}}
\DoxyCodeLine{409     \textcolor{comment}{//PetscReal val;}}
\DoxyCodeLine{410     \textcolor{comment}{//val = 1.e-\/6;}}
\DoxyCodeLine{411     \textcolor{comment}{//MatMumpsSetCntl(m\_petsc\_F,icntl,val);}}
\DoxyCodeLine{412 }
\DoxyCodeLine{413     \textcolor{comment}{/* compute determinant of A */}}
\DoxyCodeLine{414     \textcolor{comment}{// MatMumpsSetIcntl(m\_petsc\_F,33,1);}}
\DoxyCodeLine{415     \textcolor{comment}{/* not used unless we initialise PETSc using the command line options */}}
\DoxyCodeLine{416     \textcolor{comment}{// KSPSetFromOptions(m\_petsc\_ksp);}}
\DoxyCodeLine{417 }
\DoxyCodeLine{418     \textcolor{comment}{/* Get info from matrix factors */}}
\DoxyCodeLine{419 }
\DoxyCodeLine{420     \textcolor{comment}{//KSPView(m\_petsc\_ksp, PETSC\_VIEWER\_STDOUT\_WORLD);}}
\DoxyCodeLine{421 }
\DoxyCodeLine{422     MatDestroy(\&A);}
\DoxyCodeLine{423     \textcolor{keyword}{delete}[] all\_rows\_nnz;}
\DoxyCodeLine{424 }
\DoxyCodeLine{425 \textcolor{preprocessor}{\#endif // check for PETSC\_D/Z}}
\DoxyCodeLine{426   \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Example\+::\+A().

\mbox{\label{classCppNoddy_1_1SparseLinearSystem_a0e1b2b9950f859cf4783144672827964}} 
\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}!solve@{solve}}
\index{solve@{solve}!CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}
\doxyparagraph{solve()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Sparse\+Linear\+System}$<$ \+\_\+\+Type $>$\+::solve}



Solve the sparse system. 



Definition at line 75 of file Sparse\+Linear\+System.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{75                                         \{}
\DoxyCodeLine{76     \textcolor{keywordflow}{if}(\textcolor{stringliteral}{"petsc"} == m\_version) \{}
\DoxyCodeLine{77       factorise();}
\DoxyCodeLine{78       solve\_using\_factorisation();}
\DoxyCodeLine{79     \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{// we catch incorrect m\_version choices in the ctor}}
\DoxyCodeLine{80       std::string problem;}
\DoxyCodeLine{81       problem = \textcolor{stringliteral}{"CppNoddy needs to be linked to PETSc to solve sparse\(\backslash\)n"};}
\DoxyCodeLine{82       problem += \textcolor{stringliteral}{"linear systems."};}
\DoxyCodeLine{83       \textcolor{keywordflow}{throw} ExceptionExternal(problem);}
\DoxyCodeLine{84     \}}
\DoxyCodeLine{85   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1SparseLinearSystem_a8ac478d27ae386625ddb2384653645c1}} 
\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}!solve\_using\_factorisation@{solve\_using\_factorisation}}
\index{solve\_using\_factorisation@{solve\_using\_factorisation}!CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}
\doxyparagraph{solve\_using\_factorisation()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Sparse\+Linear\+System}$<$ \+\_\+\+Type $>$\+::solve\+\_\+using\+\_\+factorisation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Resolve the same system using the same factorisation. 



Referenced by main().

\mbox{\label{classCppNoddy_1_1SparseLinearSystem_a5bfec67d9ce4a1e5ea95d33b35c8700d}} 
\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}!solve\_using\_factorisation@{solve\_using\_factorisation}}
\index{solve\_using\_factorisation@{solve\_using\_factorisation}!CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}
\doxyparagraph{solve\_using\_factorisation()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Sparse\+Linear\+System}$<$ double $>$\+::solve\+\_\+using\+\_\+factorisation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 242 of file Sparse\+Linear\+System.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{242                                                              \{}
\DoxyCodeLine{243 \textcolor{preprocessor}{\#if !defined(PETSC\_D)}}
\DoxyCodeLine{244     std::string problem;}
\DoxyCodeLine{245     problem = \textcolor{stringliteral}{"CppNoddy is linked against the COMPLEX version of PETSc\(\backslash\)n"};}
\DoxyCodeLine{246     problem += \textcolor{stringliteral}{"but you are trying to solve a DOUBLE matrix. Either\(\backslash\)n"};}
\DoxyCodeLine{247     problem += \textcolor{stringliteral}{"redefine your matrix as complex, or recompile with \$PETSC\_ARCH\(\backslash\)n"};}
\DoxyCodeLine{248     problem += \textcolor{stringliteral}{"pointing to a DOUBLE version of the PETSc code."};}
\DoxyCodeLine{249     \textcolor{keywordflow}{throw} ExceptionExternal(problem);}
\DoxyCodeLine{250 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{251 \textcolor{preprocessor}{\#if defined(PETSC\_D)}}
\DoxyCodeLine{252     \textcolor{comment}{// size of the (assumed square) matrix}}
\DoxyCodeLine{253     PetscInt n = m\_pA -\/> nrows();}
\DoxyCodeLine{254 }
\DoxyCodeLine{255     \textcolor{comment}{// populate the RHS vector using the CppNoddy DenseVector content}}
\DoxyCodeLine{256     \textcolor{keywordflow}{for}(PetscInt i = 0; i < n; ++i) \{}
\DoxyCodeLine{257       VecSetValue(m\_petsc\_B,i,m\_pB-\/>operator[](i),INSERT\_VALUES);}
\DoxyCodeLine{258     \}}
\DoxyCodeLine{259 }
\DoxyCodeLine{260     \textcolor{comment}{/* -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/}}
\DoxyCodeLine{261 \textcolor{comment}{                        Solve the linear system}}
\DoxyCodeLine{262 \textcolor{comment}{       -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ */}}
\DoxyCodeLine{263     KSPSolve(m\_petsc\_ksp,m\_petsc\_B,m\_petsc\_x);}
\DoxyCodeLine{264 }
\DoxyCodeLine{265     \textcolor{comment}{/* We can now gather the parallel result back to ALL processes}}
\DoxyCodeLine{266 \textcolor{comment}{      This is temporary as the SparseMatrix is stored on each processes}}
\DoxyCodeLine{267 \textcolor{comment}{      and is too dumb for "proper" parallelization */}}
\DoxyCodeLine{268     Vec y;}
\DoxyCodeLine{269     \textcolor{comment}{// a scatter context}}
\DoxyCodeLine{270     VecScatter ctx = 0;}
\DoxyCodeLine{271     \textcolor{comment}{// map all elts of the parallel vector to a sequential copy}}
\DoxyCodeLine{272     VecScatterCreateToAll(m\_petsc\_x,\&ctx,\&y);}
\DoxyCodeLine{273     \textcolor{comment}{// scatter it}}
\DoxyCodeLine{274     VecScatterBegin(ctx,m\_petsc\_x,y,INSERT\_VALUES,SCATTER\_FORWARD);}
\DoxyCodeLine{275     VecScatterEnd(ctx,m\_petsc\_x,y,INSERT\_VALUES,SCATTER\_FORWARD);}
\DoxyCodeLine{276     \textcolor{comment}{// clean up}}
\DoxyCodeLine{277     VecScatterDestroy(\&ctx);}
\DoxyCodeLine{278     \textcolor{comment}{// this array is a pointer not a copy}}
\DoxyCodeLine{279     PetscScalar* array;}
\DoxyCodeLine{280     VecGetArray(y,\&array);}
\DoxyCodeLine{281     \textcolor{comment}{// now copy to the CppNoddy densevctor}}
\DoxyCodeLine{282     \textcolor{keywordflow}{for}(PetscInt i=0; i<n; i++) \{}
\DoxyCodeLine{283       m\_pB -\/> operator[](i) = array[i];}
\DoxyCodeLine{284     \}}
\DoxyCodeLine{285     \textcolor{comment}{// follow the docs and Restore after get}}
\DoxyCodeLine{286     VecRestoreArray(m\_petsc\_x,\&array);}
\DoxyCodeLine{287     VecDestroy(\&y);}
\DoxyCodeLine{288 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{289   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1SparseLinearSystem_ab7bf5f0855caf4f104b183c2339b231a}} 
\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}!solve\_using\_factorisation@{solve\_using\_factorisation}}
\index{solve\_using\_factorisation@{solve\_using\_factorisation}!CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}
\doxyparagraph{solve\_using\_factorisation()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Sparse\+Linear\+System}$<$ std\+::complex$<$ double $>$ $>$\+::solve\+\_\+using\+\_\+factorisation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 432 of file Sparse\+Linear\+System.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{432                                                                           \{}
\DoxyCodeLine{433 \textcolor{preprocessor}{\#if !defined(PETSC\_Z)}}
\DoxyCodeLine{434     std::string problem;}
\DoxyCodeLine{435     problem = \textcolor{stringliteral}{"CppNoddy is linked against the DOUBLE version of PETSc\(\backslash\)n"};}
\DoxyCodeLine{436     problem += \textcolor{stringliteral}{"but you are trying to solve e a COMPLEX matrix.\(\backslash\)n"};}
\DoxyCodeLine{437     problem += \textcolor{stringliteral}{"Recompile with \$PETSC\_ARCH\(\backslash\)n"};}
\DoxyCodeLine{438     problem += \textcolor{stringliteral}{"pointing to a COMPLEX version of the PETSc code."};}
\DoxyCodeLine{439     \textcolor{keywordflow}{throw} ExceptionExternal(problem);}
\DoxyCodeLine{440 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{441 \textcolor{preprocessor}{\#if defined(PETSC\_Z)}}
\DoxyCodeLine{442     \textcolor{comment}{// size of the (assumed square) matrix}}
\DoxyCodeLine{443     PetscInt n = m\_pA -\/> nrows();}
\DoxyCodeLine{444 }
\DoxyCodeLine{445     \textcolor{comment}{// populate the RHS vector using the CppNoddy DenseVector content}}
\DoxyCodeLine{446     \textcolor{keywordflow}{for}(PetscInt i = 0; i < n; ++i) \{}
\DoxyCodeLine{447       VecSetValue(m\_petsc\_B,i,m\_pB-\/>operator[](i),INSERT\_VALUES);}
\DoxyCodeLine{448     \}}
\DoxyCodeLine{449 }
\DoxyCodeLine{450     \textcolor{comment}{/* -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/}}
\DoxyCodeLine{451 \textcolor{comment}{                        Solve the linear system}}
\DoxyCodeLine{452 \textcolor{comment}{       -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ -\/ */}}
\DoxyCodeLine{453     KSPSolve(m\_petsc\_ksp,m\_petsc\_B,m\_petsc\_x);}
\DoxyCodeLine{454 }
\DoxyCodeLine{455     \textcolor{comment}{/* We can now gather the parallel result back to ALL processes}}
\DoxyCodeLine{456 \textcolor{comment}{      This is temporary as the SparseMatrix is stored on each processes}}
\DoxyCodeLine{457 \textcolor{comment}{      and is too dumb for "proper" parallelization */}}
\DoxyCodeLine{458     Vec y;}
\DoxyCodeLine{459     \textcolor{comment}{// a scatter context}}
\DoxyCodeLine{460     VecScatter ctx = 0;}
\DoxyCodeLine{461     \textcolor{comment}{// map all elts of the parallel vector to a sequential copy}}
\DoxyCodeLine{462     VecScatterCreateToAll(m\_petsc\_x,\&ctx,\&y);}
\DoxyCodeLine{463     \textcolor{comment}{// scatter it}}
\DoxyCodeLine{464     VecScatterBegin(ctx,m\_petsc\_x,y,INSERT\_VALUES,SCATTER\_FORWARD);}
\DoxyCodeLine{465     VecScatterEnd(ctx,m\_petsc\_x,y,INSERT\_VALUES,SCATTER\_FORWARD);}
\DoxyCodeLine{466     \textcolor{comment}{// clean up}}
\DoxyCodeLine{467     VecScatterDestroy(\&ctx);}
\DoxyCodeLine{468     \textcolor{comment}{// this array is a pointer not a copy}}
\DoxyCodeLine{469     PetscScalar* array;}
\DoxyCodeLine{470     VecGetArray(y,\&array);}
\DoxyCodeLine{471     \textcolor{comment}{// now copy to the CppNoddy densevctor}}
\DoxyCodeLine{472     \textcolor{keywordflow}{for}(PetscInt i=0; i<n; i++) \{}
\DoxyCodeLine{473       m\_pB -\/> operator[](i) = array[i];}
\DoxyCodeLine{474     \}}
\DoxyCodeLine{475     \textcolor{comment}{// follow the docs and Restore after get}}
\DoxyCodeLine{476     VecRestoreArray(m\_petsc\_x,\&array);}
\DoxyCodeLine{477     VecDestroy(\&y);}
\DoxyCodeLine{478 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{479   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1SparseLinearSystem_ac91852a05947992407cc95f4782e484e}} 
\index{CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}!temp\_solve@{temp\_solve}}
\index{temp\_solve@{temp\_solve}!CppNoddy::SparseLinearSystem$<$ \_Type $>$@{CppNoddy::SparseLinearSystem$<$ \_Type $>$}}
\doxyparagraph{temp\_solve()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Sparse\+Linear\+System}$<$ \+\_\+\+Type $>$\+::temp\+\_\+solve (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/\textbf{ Sparse\+Linear\+System.\+h}\item 
src/\textbf{ Sparse\+Linear\+System.\+cpp}\end{DoxyCompactItemize}
