\doxysubsection{Cpp\+Noddy\+::Dense\+Matrix$<$ \+\_\+\+Type $>$ Class Template Reference}
\label{classCppNoddy_1_1DenseMatrix}\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}


A matrix class that constructs a D\+E\+N\+SE matrix as a row major std\+::vector of Dense\+Vectors.  




{\ttfamily \#include $<$Dense\+Matrix.\+h$>$}

Inheritance diagram for Cpp\+Noddy\+::Dense\+Matrix$<$ \+\_\+\+Type $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classCppNoddy_1_1DenseMatrix}
\end{center}
\end{figure}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ $>$\+::iterator \textbf{ row\+\_\+iter}
\begin{DoxyCompactList}\small\item\em Typedef iterator types. \end{DoxyCompactList}\item 
typedef std\+::vector$<$ \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ $>$\+::const\+\_\+iterator \textbf{ row\+\_\+citer}
\item 
typedef std\+::vector$<$ \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ $>$\+::reverse\+\_\+iterator \textbf{ row\+\_\+riter}
\item 
typedef std\+::vector$<$ \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ $>$\+::const\+\_\+reverse\+\_\+iterator \textbf{ row\+\_\+criter}
\item 
typedef \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$\+::\textbf{ elt\+\_\+iter} \textbf{ elt\+\_\+iter}
\item 
typedef \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$\+::\textbf{ elt\+\_\+citer} \textbf{ elt\+\_\+citer}
\item 
typedef \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$\+::\textbf{ elt\+\_\+riter} \textbf{ elt\+\_\+riter}
\item 
typedef \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$\+::\textbf{ elt\+\_\+criter} \textbf{ elt\+\_\+criter}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Dense\+Matrix} ()
\begin{DoxyCompactList}\small\item\em Allow empty construction. \end{DoxyCompactList}\item 
\textbf{ Dense\+Matrix} (const std\+::size\+\_\+t \&rows, const std\+::size\+\_\+t \&cols, const \+\_\+\+Type \&fill)
\begin{DoxyCompactList}\small\item\em Noddy Matrix constructor with a specified fill data. \end{DoxyCompactList}\item 
\textbf{ Dense\+Matrix} (const std\+::size\+\_\+t \&rows, const std\+::size\+\_\+t \&cols, const \+\_\+\+Type $\ast$\textbf{ p})
\begin{DoxyCompactList}\small\item\em Construct a Noddy Matrix from a contiguous set of data. \end{DoxyCompactList}\item 
\textbf{ Dense\+Matrix} (const \textbf{ Banded\+Matrix}$<$ \+\_\+\+Type $>$ \&source)
\begin{DoxyCompactList}\small\item\em Construct a dense matrix from its banded counterpart. \end{DoxyCompactList}\item 
\textbf{ Dense\+Matrix} (const \textbf{ Dense\+Matrix} \&source)
\begin{DoxyCompactList}\small\item\em Copy constructor. \end{DoxyCompactList}\item 
\textbf{ Dense\+Matrix} \& \textbf{ operator=} (const \textbf{ Dense\+Matrix} \&source)
\begin{DoxyCompactList}\small\item\em Assignment operator. \end{DoxyCompactList}\item 
\textbf{ $\sim$\+Dense\+Matrix} ()
\item 
const \+\_\+\+Type \& \textbf{ operator()} (const std\+::size\+\_\+t \&row, const std\+::size\+\_\+t \&col) const
\begin{DoxyCompactList}\small\item\em Access operator. \end{DoxyCompactList}\item 
\+\_\+\+Type \& \textbf{ operator()} (const std\+::size\+\_\+t \&row, const std\+::size\+\_\+t \&col)
\begin{DoxyCompactList}\small\item\em Access operator. \end{DoxyCompactList}\item 
const \+\_\+\+Type \& \textbf{ get} (const std\+::size\+\_\+t \&row, const std\+::size\+\_\+t \&col) const
\begin{DoxyCompactList}\small\item\em Access operator. \end{DoxyCompactList}\item 
\+\_\+\+Type \& \textbf{ set} (const std\+::size\+\_\+t \&row, const std\+::size\+\_\+t \&col)
\begin{DoxyCompactList}\small\item\em Access operator. \end{DoxyCompactList}\item 
\textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \textbf{ operator$\ast$} (const double \&\textbf{ m}) const
\begin{DoxyCompactList}\small\item\em S\+I\+MD operator sugar. \end{DoxyCompactList}\item 
\textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \textbf{ operator+} (const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&A) const
\item 
\textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \textbf{ operator-\/} (const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&A) const
\item 
std\+::size\+\_\+t \textbf{ nrows} () const
\item 
std\+::size\+\_\+t \textbf{ ncols} () const
\item 
std\+::size\+\_\+t \textbf{ nelts} () const
\item 
void \textbf{ scale} (const \+\_\+\+Type \&mult)
\begin{DoxyCompactList}\small\item\em Scale all matrix elements by a scalar. \end{DoxyCompactList}\item 
void \textbf{ transpose} ()
\begin{DoxyCompactList}\small\item\em Transpose the matrix. \end{DoxyCompactList}\item 
double \textbf{ one\+\_\+norm} () const
\begin{DoxyCompactList}\small\item\em Return the maximum one\+\_\+norm of all rows. \end{DoxyCompactList}\item 
double \textbf{ two\+\_\+norm} () const
\begin{DoxyCompactList}\small\item\em Rreturn the maximum two\+\_\+norm of all rows. \end{DoxyCompactList}\item 
double \textbf{ inf\+\_\+norm} () const
\begin{DoxyCompactList}\small\item\em Return the maximum inf\+\_\+norm of all rows. \end{DoxyCompactList}\item 
double \textbf{ frob\+\_\+norm} () const
\begin{DoxyCompactList}\small\item\em Return the sum of the two\+\_\+norm of all rows. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \textbf{ multiply} (const \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \&x) const
\begin{DoxyCompactList}\small\item\em Right multiply the matrix by a D\+E\+N\+SE vector. \end{DoxyCompactList}\item 
void \textbf{ dump} () const
\begin{DoxyCompactList}\small\item\em Output the matrix to std\+::cout. \end{DoxyCompactList}\item 
void \textbf{ assign} (\+\_\+\+Type elt)
\begin{DoxyCompactList}\small\item\em Assign a value to the matrix but keep the same geometry. \end{DoxyCompactList}\item 
\textbf{ row\+\_\+iter} \textbf{ begin} ()
\begin{DoxyCompactList}\small\item\em Pass through of iterator calls. \end{DoxyCompactList}\item 
\textbf{ row\+\_\+iter} \textbf{ end} ()
\begin{DoxyCompactList}\small\item\em Pass through of iterator calls. \end{DoxyCompactList}\item 
\textbf{ row\+\_\+riter} \textbf{ rbegin} ()
\begin{DoxyCompactList}\small\item\em Pass through of iterator calls. \end{DoxyCompactList}\item 
\textbf{ row\+\_\+riter} \textbf{ rend} ()
\begin{DoxyCompactList}\small\item\em Pass through of iterator calls. \end{DoxyCompactList}\item 
\textbf{ row\+\_\+citer} \textbf{ begin} () const
\begin{DoxyCompactList}\small\item\em Pass through of iterator calls. \end{DoxyCompactList}\item 
\textbf{ row\+\_\+citer} \textbf{ end} () const
\begin{DoxyCompactList}\small\item\em Pass through of iterator calls. \end{DoxyCompactList}\item 
\textbf{ row\+\_\+criter} \textbf{ rbegin} () const
\begin{DoxyCompactList}\small\item\em Pass through of iterator calls. \end{DoxyCompactList}\item 
\textbf{ row\+\_\+criter} \textbf{ rend} () const
\begin{DoxyCompactList}\small\item\em Pass through of iterator calls. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \& \textbf{ operator[$\,$]} (const std\+::size\+\_\+t \&row)
\begin{DoxyCompactList}\small\item\em Operator overloading for R\+OW access. \end{DoxyCompactList}\item 
const \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \& \textbf{ operator[$\,$]} (const std\+::size\+\_\+t \&row) const
\begin{DoxyCompactList}\small\item\em Operator overloading for R\+OW access. \end{DoxyCompactList}\item 
void \textbf{ add} (const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&b)
\begin{DoxyCompactList}\small\item\em Add a D\+E\+N\+SE matrix to this object. \end{DoxyCompactList}\item 
void \textbf{ sub} (const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&b)
\begin{DoxyCompactList}\small\item\em Subtract a D\+E\+N\+SE matrix from this object. \end{DoxyCompactList}\item 
\textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \textbf{ multiply} (const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&b) const
\begin{DoxyCompactList}\small\item\em Right-\/multiply by a D\+E\+N\+SE matrix and return the result. \end{DoxyCompactList}\item 
void \textbf{ set\+\_\+col} (const std\+::size\+\_\+t \&col, const \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \&x)
\begin{DoxyCompactList}\small\item\em Set a column of the matrix. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \textbf{ get\+\_\+col} (const std\+::size\+\_\+t \&col) const
\begin{DoxyCompactList}\small\item\em Get a column of the matrix. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ matrix\+\_\+to\+\_\+vector} (const std\+::size\+\_\+t \&padding=0) const
\begin{DoxyCompactList}\small\item\em Conversion to contiguous data in row major format Inefficient ... \end{DoxyCompactList}\item 
void \textbf{ matrix\+\_\+to\+\_\+vector} (\textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ p}, const std\+::size\+\_\+t \&padding=0) const
\begin{DoxyCompactList}\small\item\em Conversion to contiguous data in row major format. \end{DoxyCompactList}\item 
\textbf{ row\+\_\+iter} \textbf{ max\+\_\+in\+\_\+col} (const std\+::size\+\_\+t \&col, \textbf{ row\+\_\+iter} row\+\_\+min, \textbf{ row\+\_\+iter} row\+\_\+max) const
\begin{DoxyCompactList}\small\item\em Find the maximum abs value in a column. \end{DoxyCompactList}\item 
void \textbf{ matrix\+\_\+to\+\_\+vector} (\textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ p}, const std\+::size\+\_\+t \&padding) const
\item 
void \textbf{ matrix\+\_\+to\+\_\+vector} (\textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ p}, const std\+::size\+\_\+t \&padding) const
\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ matrix\+\_\+to\+\_\+vector} (const std\+::size\+\_\+t \&padding) const
\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ matrix\+\_\+to\+\_\+vector} (const std\+::size\+\_\+t \&padding) const
\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
\subsubsection*{template$<$typename \+\_\+\+Type$>$\newline
class Cpp\+Noddy\+::\+Dense\+Matrix$<$ \+\_\+\+Type $>$}

A matrix class that constructs a D\+E\+N\+SE matrix as a row major std\+::vector of Dense\+Vectors. 

This is generally a nice way to implement the matrix, but the data elements [i][j] are not necessarily in contiguous row\+\_\+major format in memory because there is a system dependent padding at the end of each row vector. Thus, in general, \&[i][j+1] -\/ \&[i][j] != \&[i][0] -\/ \&[i-\/1][Nc] .. ie. the step may be larger from the end of row i-\/1 to the start of row i. Typically, the data must be copied into contiguous memory for use in external libraries that take base pointers \& assume uniform steps between elements. 

Definition at line 25 of file Dense\+Matrix.\+h.



\doxysubsubsection{Member Typedef Documentation}
\mbox{\label{classCppNoddy_1_1DenseMatrix_af90f9357a7906e42e8bb204a3de90efe}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!elt\_citer@{elt\_citer}}
\index{elt\_citer@{elt\_citer}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{elt\_citer}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
typedef \textbf{ Dense\+Vector}$<$\+\_\+\+Type$>$\+::\textbf{ elt\+\_\+citer} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ elt\+\_\+citer}}



Definition at line 37 of file Dense\+Matrix.\+h.

\mbox{\label{classCppNoddy_1_1DenseMatrix_a731b8e02a751efa5bde75d74d0b3da0a}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!elt\_criter@{elt\_criter}}
\index{elt\_criter@{elt\_criter}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{elt\_criter}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
typedef \textbf{ Dense\+Vector}$<$\+\_\+\+Type$>$\+::\textbf{ elt\+\_\+criter} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ elt\+\_\+criter}}



Definition at line 39 of file Dense\+Matrix.\+h.

\mbox{\label{classCppNoddy_1_1DenseMatrix_a336456c312df152f5f98a2d23d2c4f60}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!elt\_iter@{elt\_iter}}
\index{elt\_iter@{elt\_iter}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{elt\_iter}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
typedef \textbf{ Dense\+Vector}$<$\+\_\+\+Type$>$\+::\textbf{ elt\+\_\+iter} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ elt\+\_\+iter}}



Definition at line 36 of file Dense\+Matrix.\+h.

\mbox{\label{classCppNoddy_1_1DenseMatrix_ad6bafcf53651851dc184aef3e581fdd2}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!elt\_riter@{elt\_riter}}
\index{elt\_riter@{elt\_riter}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{elt\_riter}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
typedef \textbf{ Dense\+Vector}$<$\+\_\+\+Type$>$\+::\textbf{ elt\+\_\+riter} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ elt\+\_\+riter}}



Definition at line 38 of file Dense\+Matrix.\+h.

\mbox{\label{classCppNoddy_1_1DenseMatrix_a4348434a4ed83b9f7c7ef29f9f6abd0e}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!row\_citer@{row\_citer}}
\index{row\_citer@{row\_citer}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{row\_citer}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
typedef std\+::vector$<$\textbf{ Dense\+Vector}$<$\+\_\+\+Type$>$ $>$\+::const\+\_\+iterator \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ row\+\_\+citer}}



Definition at line 31 of file Dense\+Matrix.\+h.

\mbox{\label{classCppNoddy_1_1DenseMatrix_a88c5e0620edc59cb6239706e281c2742}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!row\_criter@{row\_criter}}
\index{row\_criter@{row\_criter}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{row\_criter}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
typedef std\+::vector$<$\textbf{ Dense\+Vector}$<$\+\_\+\+Type$>$ $>$\+::const\+\_\+reverse\+\_\+iterator \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ row\+\_\+criter}}



Definition at line 35 of file Dense\+Matrix.\+h.

\mbox{\label{classCppNoddy_1_1DenseMatrix_a912ddfc54a95f856f344aa7dabdfb06f}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!row\_iter@{row\_iter}}
\index{row\_iter@{row\_iter}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{row\_iter}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
typedef std\+::vector$<$\textbf{ Dense\+Vector}$<$\+\_\+\+Type$>$ $>$\+::iterator \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ row\+\_\+iter}}



Typedef iterator types. 



Definition at line 29 of file Dense\+Matrix.\+h.

\mbox{\label{classCppNoddy_1_1DenseMatrix_aa08ac91849bf6d0639fb5d2b61109d6c}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!row\_riter@{row\_riter}}
\index{row\_riter@{row\_riter}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{row\_riter}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
typedef std\+::vector$<$\textbf{ Dense\+Vector}$<$\+\_\+\+Type$>$ $>$\+::reverse\+\_\+iterator \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ row\+\_\+riter}}



Definition at line 33 of file Dense\+Matrix.\+h.



\doxysubsubsection{Constructor \& Destructor Documentation}
\mbox{\label{classCppNoddy_1_1DenseMatrix_ad5a65945032f0dc59372bdd0c21e7432}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!DenseMatrix@{DenseMatrix}}
\index{DenseMatrix@{DenseMatrix}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{DenseMatrix()\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ Dense\+Matrix}}



Allow empty construction. 



Definition at line 17 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{17                                   : m\_nr(0), m\_nc(0)}
\DoxyCodeLine{18   \{\}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a29bb44ee1f7c4192ce3314f45177027a}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!DenseMatrix@{DenseMatrix}}
\index{DenseMatrix@{DenseMatrix}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{DenseMatrix()\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ Dense\+Matrix} (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{rows,  }\item[{const std\+::size\+\_\+t \&}]{cols,  }\item[{const \+\_\+\+Type \&}]{fill }\end{DoxyParamCaption})}



Noddy Matrix constructor with a specified fill data. 


\begin{DoxyParams}{Parameters}
{\em rows} & The number of rows in the matrix. \\
\hline
{\em cols} & The number of columns in the matrix. \\
\hline
{\em fill} & The entry to be placed in all elements. \\
\hline
\end{DoxyParams}


Definition at line 21 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{23                                                      :}
\DoxyCodeLine{24     Sequential\_Matrix\_base<\_Type>(),}
\DoxyCodeLine{25     m\_nr(rows),}
\DoxyCodeLine{26     m\_nc(cols) \{}
\DoxyCodeLine{27     \textcolor{comment}{// make a row}}
\DoxyCodeLine{28     \textcolor{keyword}{const} DenseVector<\_Type> row(cols, fill);}
\DoxyCodeLine{29     \textcolor{comment}{// reserve the space}}
\DoxyCodeLine{30     m\_matrix.reserve(rows);}
\DoxyCodeLine{31     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < rows; ++i) \{}
\DoxyCodeLine{32       \textcolor{comment}{// push require number of rows into the 'matrix'}}
\DoxyCodeLine{33       m\_matrix.push\_back(row);}
\DoxyCodeLine{34     \}}
\DoxyCodeLine{35   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_ad36da52afc5fc0f79b7fd14ba05a674c}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!DenseMatrix@{DenseMatrix}}
\index{DenseMatrix@{DenseMatrix}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{DenseMatrix()\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ Dense\+Matrix} (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{rows,  }\item[{const std\+::size\+\_\+t \&}]{cols,  }\item[{const \+\_\+\+Type $\ast$}]{p }\end{DoxyParamCaption})}



Construct a Noddy Matrix from a contiguous set of data. 

This will be nasty if you pass the wrong pointer, but is useful in interfacing with external libraries. This assumes the contiguous data is in row\+\_\+major format. 
\begin{DoxyParams}{Parameters}
{\em rows} & The number of rows in the matrix. \\
\hline
{\em cols} & The number of columns in the matrix. \\
\hline
{\em p} & A pointer to the start of the data. \\
\hline
\end{DoxyParams}


Definition at line 38 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{40                                                   :}
\DoxyCodeLine{41     Sequential\_Matrix\_base<\_Type>(),}
\DoxyCodeLine{42     m\_nr(rows),}
\DoxyCodeLine{43     m\_nc(cols) \{}
\DoxyCodeLine{44     m\_matrix.reserve(rows);}
\DoxyCodeLine{45     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < rows; ++i) \{}
\DoxyCodeLine{46       m\_matrix.push\_back(DenseVector<\_Type>(cols, \&p[ i * cols ]));}
\DoxyCodeLine{47     \}}
\DoxyCodeLine{48   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a8a9958fc81753c5597205846f16c2cbf}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!DenseMatrix@{DenseMatrix}}
\index{DenseMatrix@{DenseMatrix}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{DenseMatrix()\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ Dense\+Matrix} (\begin{DoxyParamCaption}\item[{const \textbf{ Banded\+Matrix}$<$ \+\_\+\+Type $>$ \&}]{source }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct a dense matrix from its banded counterpart. 


\begin{DoxyParams}{Parameters}
{\em source} & The banded matrix to be used in the construction. \\
\hline
\end{DoxyParams}


Definition at line 65 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{65                                                    \{}
\DoxyCodeLine{66       \textcolor{comment}{// get the number of off diagonal elts}}
\DoxyCodeLine{67       \textcolor{keywordtype}{int} l = source.noffdiag();}
\DoxyCodeLine{68       \textcolor{comment}{// banded matrix class is always square}}
\DoxyCodeLine{69       \textcolor{keywordtype}{int} n = source.nrows();}
\DoxyCodeLine{70       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} row = 0; row < n; ++row) \{}
\DoxyCodeLine{71         DenseVector<\_Type> vecrow(n, 0.0);}
\DoxyCodeLine{72         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} col = std::max(row -\/ l, 0);}
\DoxyCodeLine{73             col < std::min(n, row + l + 1);}
\DoxyCodeLine{74             ++col) \{}
\DoxyCodeLine{75           vecrow[ col ] = source(row, col);}
\DoxyCodeLine{76         \}}
\DoxyCodeLine{77         m\_matrix.push\_back(vecrow);}
\DoxyCodeLine{78       \}}
\DoxyCodeLine{79       m\_nr = m\_nc = n;}
\DoxyCodeLine{80     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_abbca47986fef3b54156d246daa2b77bd}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!DenseMatrix@{DenseMatrix}}
\index{DenseMatrix@{DenseMatrix}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{DenseMatrix()\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::\textbf{ Dense\+Matrix} (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&}]{source }\end{DoxyParamCaption})}



Copy constructor. 


\begin{DoxyParams}{Parameters}
{\em source} & The source object to be copied \\
\hline
\end{DoxyParams}


Definition at line 51 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{51                                                                   :}
\DoxyCodeLine{52     Sequential\_Matrix\_base<\_Type>() \{}
\DoxyCodeLine{53     *\textcolor{keyword}{this} = source;}
\DoxyCodeLine{54   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a19ea0d370b1fe83e407203fa724b5f89}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!````~DenseMatrix@{$\sim$DenseMatrix}}
\index{````~DenseMatrix@{$\sim$DenseMatrix}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{$\sim$DenseMatrix()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::$\sim$\textbf{ Dense\+Matrix}}



Definition at line 57 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{58   \{\}}

\end{DoxyCode}


\doxysubsubsection{Member Function Documentation}
\mbox{\label{classCppNoddy_1_1DenseMatrix_ab49459f057bf6cc5ec388184383ab48d}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!add@{add}}
\index{add@{add}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{add()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::add (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&}]{b }\end{DoxyParamCaption})}



Add a D\+E\+N\+SE matrix to this object. 


\begin{DoxyParams}{Parameters}
{\em b} & The D\+E\+N\+SE matrix to add to \textquotesingle{}this\textquotesingle{} \\
\hline
\end{DoxyParams}


Definition at line 76 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{76                                                           \{}
\DoxyCodeLine{77 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{78     \textcolor{comment}{// check number of columns at least match}}
\DoxyCodeLine{79     \textcolor{keywordflow}{if}((B.nrows() != m\_nr) || (B.ncols() != m\_nc)) \{}
\DoxyCodeLine{80       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.add has a geometry error.\(\backslash\)n"});}
\DoxyCodeLine{81       \textcolor{keywordflow}{throw} ExceptionGeom(problem, m\_nr, m\_nc, B.nrows(), B.ncols());}
\DoxyCodeLine{82     \}}
\DoxyCodeLine{83 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{84     std::transform(m\_matrix.begin(), m\_matrix.end(), B.m\_matrix.begin(), m\_matrix.begin(), std::plus< DenseVector<\_Type> >());}
\DoxyCodeLine{85   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1DenseMatrix_a03e8c0e941cb74c1a0b6f62e8cbaa91e}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!assign@{assign}}
\index{assign@{assign}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{assign()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::assign (\begin{DoxyParamCaption}\item[{\+\_\+\+Type}]{elt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Assign a value to the matrix but keep the same geometry. 


\begin{DoxyParams}{Parameters}
{\em elt} & The value to be assigned to all entries \\
\hline
\end{DoxyParams}


Definition at line 170 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{170                            \{}
\DoxyCodeLine{171       m\_matrix.assign(m\_matrix.size(), DenseVector<\_Type>(m\_nc, elt));}
\DoxyCodeLine{172     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a408fc2ad6d2f73e8a0c68c3d872d768d}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!begin@{begin}}
\index{begin@{begin}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{begin()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ row\+\_\+iter} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pass through of iterator calls. 

\begin{DoxyReturn}{Returns}
Iterator to the begin row 
\end{DoxyReturn}


Definition at line 176 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{176                      \{}
\DoxyCodeLine{177       \textcolor{keywordflow}{return} m\_matrix.begin();}
\DoxyCodeLine{178     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a30b55cfbf9ecdb6c7c76875e740af38d}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!begin@{begin}}
\index{begin@{begin}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{begin()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ row\+\_\+citer} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Pass through of iterator calls. 

\begin{DoxyReturn}{Returns}
Const iterator to the begin row 
\end{DoxyReturn}


Definition at line 200 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{200                             \{}
\DoxyCodeLine{201       \textcolor{keywordflow}{return} m\_matrix.begin();}
\DoxyCodeLine{202     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a1e194bccf5119d65c890f047c2b74911}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!dump@{dump}}
\index{dump@{dump}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{dump()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::dump\hspace{0.3cm}{\ttfamily [virtual]}}



Output the matrix to std\+::cout. 



Implements \textbf{ Cpp\+Noddy\+::\+Sequential\+\_\+\+Matrix\+\_\+base$<$ \+\_\+\+Type $>$} \doxyref{}{p.}{classCppNoddy_1_1Sequential__Matrix__base_a1988db797d0fafc92ccfae5afafdee92}.



Definition at line 223 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{223                                       \{}
\DoxyCodeLine{224     std::cout << \textcolor{stringliteral}{"DENSE mtx size = "} << nrows() << \textcolor{stringliteral}{" x "} << ncols() << \textcolor{stringliteral}{"; \(\backslash\)n"};}
\DoxyCodeLine{225     std::cout.precision(3);}
\DoxyCodeLine{226     std::cout << std::fixed;}
\DoxyCodeLine{227     std::cout.setf(std::ios::showpoint);}
\DoxyCodeLine{228     std::cout.setf(std::ios::showpos);}
\DoxyCodeLine{229     \textcolor{comment}{//std::cout.setf( std::ios::scientific );}}
\DoxyCodeLine{230     std::cout << \textcolor{stringliteral}{"-\/ start matrix \(\backslash\)n"};}
\DoxyCodeLine{231     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < nrows(); ++i) \{}
\DoxyCodeLine{232       std::cout << \textcolor{stringliteral}{" row "} << i << \textcolor{stringliteral}{" =  "};}
\DoxyCodeLine{233       \textcolor{keywordflow}{for}(std::size\_t j = 0; j < ncols(); ++j) \{}
\DoxyCodeLine{234         std::cout << m\_matrix[ i ][ j ] << \textcolor{stringliteral}{", "};}
\DoxyCodeLine{235       \}}
\DoxyCodeLine{236       std::cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{237     \}}
\DoxyCodeLine{238     std::cout << \textcolor{stringliteral}{"-\/ end matrix \(\backslash\)n"};}
\DoxyCodeLine{239   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a5b49f006c5f6ad62f9d068eb5dee8b60}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!end@{end}}
\index{end@{end}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{end()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ row\+\_\+iter} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pass through of iterator calls. 

\begin{DoxyReturn}{Returns}
Iterator to the end row 
\end{DoxyReturn}


Definition at line 182 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{182                    \{}
\DoxyCodeLine{183       \textcolor{keywordflow}{return} m\_matrix.end();}
\DoxyCodeLine{184     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a4dec5bbfc8831a1be7e7e2b1602e6ece}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!end@{end}}
\index{end@{end}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{end()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ row\+\_\+citer} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Pass through of iterator calls. 

\begin{DoxyReturn}{Returns}
Const iterator to the end row 
\end{DoxyReturn}


Definition at line 206 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{206                           \{}
\DoxyCodeLine{207       \textcolor{keywordflow}{return} m\_matrix.end();}
\DoxyCodeLine{208     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_aa1aea139b6cdeaa6c02a19624bfdf624}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!frob\_norm@{frob\_norm}}
\index{frob\_norm@{frob\_norm}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{frob\_norm()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
double \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::frob\+\_\+norm}



Return the sum of the two\+\_\+norm of all rows. 



Definition at line 213 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{213                                              \{}
\DoxyCodeLine{214     \textcolor{keywordtype}{double} sum(0.0);}
\DoxyCodeLine{215     \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{216       sum += m\_matrix[ row ].two\_norm();}
\DoxyCodeLine{217     \}}
\DoxyCodeLine{218     \textcolor{keywordflow}{return} sum;}
\DoxyCodeLine{219   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_ad714caf4fef4a4be93cdbc4bf5755ed7}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!get@{get}}
\index{get@{get}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{get()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
const \+\_\+\+Type \& \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::get (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{row,  }\item[{const std\+::size\+\_\+t \&}]{col }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Access operator. 



Implements \textbf{ Cpp\+Noddy\+::\+Sequential\+\_\+\+Matrix\+\_\+base$<$ \+\_\+\+Type $>$} \doxyref{}{p.}{classCppNoddy_1_1Sequential__Matrix__base_a70fa57a3637b367cd380af7bc2788541}.



Definition at line 323 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{323                                                      \{}
\DoxyCodeLine{324 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{325     \textcolor{keywordflow}{if}((row > m\_nr) || (row < 0)) \{}
\DoxyCodeLine{326       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.get has a range error.\(\backslash\)n"});}
\DoxyCodeLine{327       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nr, row, m\_nc, col);}
\DoxyCodeLine{328     \}}
\DoxyCodeLine{329 }
\DoxyCodeLine{330     \textcolor{keywordflow}{if}((col > m\_nc) || (col < 0)) \{}
\DoxyCodeLine{331       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.get has a range error.\(\backslash\)n"});}
\DoxyCodeLine{332       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nr, row, m\_nc, col);}
\DoxyCodeLine{333     \}}
\DoxyCodeLine{334 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{335     \textcolor{keywordflow}{return} m\_matrix[ row ][ col ];}
\DoxyCodeLine{336   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_aa8b0cab26713a2141bd704f4deb9f9dc}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!get\_col@{get\_col}}
\index{get\_col@{get\_col}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{get\_col()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::get\+\_\+col (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{col }\end{DoxyParamCaption}) const}



Get a column of the matrix. 


\begin{DoxyParams}{Parameters}
{\em col} & The column to get \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A D\+E\+N\+SE vector of the column of data 
\end{DoxyReturn}


Definition at line 249 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{249                                                                            \{}
\DoxyCodeLine{250     DenseVector<\_Type> X(m\_nr, 0.0);}
\DoxyCodeLine{251     \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{252       X[ row ] = m\_matrix[ row ][ col ];}
\DoxyCodeLine{253     \}}
\DoxyCodeLine{254     \textcolor{keywordflow}{return} X;}
\DoxyCodeLine{255   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+Dense\+Matrix$<$ D\+\_\+complex $>$\+::multiply().

\mbox{\label{classCppNoddy_1_1DenseMatrix_aba31dcdfbdfd9ab3769faba12eb2b572}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!inf\_norm@{inf\_norm}}
\index{inf\_norm@{inf\_norm}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{inf\_norm()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
double \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::inf\+\_\+norm}



Return the maximum inf\+\_\+norm of all rows. 



Definition at line 204 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{204                                             \{}
\DoxyCodeLine{205     \textcolor{keywordtype}{double} max(0.0);}
\DoxyCodeLine{206     \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{207       max = std::max(max, m\_matrix[ row ].inf\_norm());}
\DoxyCodeLine{208     \}}
\DoxyCodeLine{209     \textcolor{keywordflow}{return} max;}
\DoxyCodeLine{210   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1DenseMatrix_a3cc67cc500899230b829b7d23bf5c3ba}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!matrix\_to\_vector@{matrix\_to\_vector}}
\index{matrix\_to\_vector@{matrix\_to\_vector}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{matrix\_to\_vector()\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ double $>$\+::matrix\+\_\+to\+\_\+vector (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{padding }\end{DoxyParamCaption}) const}



Definition at line 287 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{287                                                                                           \{}
\DoxyCodeLine{288     DenseVector<double> V;}
\DoxyCodeLine{289     V.reserve(m\_nr * m\_nc);}
\DoxyCodeLine{290     \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{291       \textcolor{keywordflow}{for}(std::size\_t col = 0; col < m\_nc; ++col) \{}
\DoxyCodeLine{292         V.push\_back(m\_matrix[ row ][ col ]);}
\DoxyCodeLine{293       \}}
\DoxyCodeLine{294       \textcolor{keywordflow}{for}(std::size\_t col = 0; col < padding; ++col) \{}
\DoxyCodeLine{295         V.push\_back(0.0);}
\DoxyCodeLine{296       \}}
\DoxyCodeLine{297     \}}
\DoxyCodeLine{298     \textcolor{keywordflow}{return} V;}
\DoxyCodeLine{299   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_ac9cf7cab1d06649d036dc91a361edb31}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!matrix\_to\_vector@{matrix\_to\_vector}}
\index{matrix\_to\_vector@{matrix\_to\_vector}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{matrix\_to\_vector()\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ std\+::complex$<$ double $>$ $>$\+::matrix\+\_\+to\+\_\+vector (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{padding }\end{DoxyParamCaption}) const}



Definition at line 302 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{302                                                                                                        \{}
\DoxyCodeLine{303     DenseVector<double> V;}
\DoxyCodeLine{304     V.reserve(2 * m\_nr * m\_nc);}
\DoxyCodeLine{305     \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{306       \textcolor{keywordflow}{for}(std::size\_t col = 0; col < m\_nc; ++col) \{}
\DoxyCodeLine{307         V.push\_back(m\_matrix[ row ][ col ].real());}
\DoxyCodeLine{308         V.push\_back(m\_matrix[ row ][ col ].imag());}
\DoxyCodeLine{309       \}}
\DoxyCodeLine{310       \textcolor{keywordflow}{for}(std::size\_t col = 0; col < padding; ++col) \{}
\DoxyCodeLine{311         V.push\_back(0.0);}
\DoxyCodeLine{312         V.push\_back(0.0);}
\DoxyCodeLine{313       \}}
\DoxyCodeLine{314     \}}
\DoxyCodeLine{315     \textcolor{keywordflow}{return} V;}
\DoxyCodeLine{316   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a245951a19334813c18bd8021a3e00b0e}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!matrix\_to\_vector@{matrix\_to\_vector}}
\index{matrix\_to\_vector@{matrix\_to\_vector}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{matrix\_to\_vector()\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Vector}$<$double$>$ \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::matrix\+\_\+to\+\_\+vector (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{padding = {\ttfamily 0} }\end{DoxyParamCaption}) const}



Conversion to contiguous data in row major format Inefficient ... 

the void method is preferred 
\begin{DoxyParams}{Parameters}
{\em padding} & An integer padding hack \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A D\+E\+N\+SE vector containing the matrix 
\end{DoxyReturn}


Referenced by Cpp\+Noddy\+::\+Fortran\+Data\+::\+Fortran\+Data().

\mbox{\label{classCppNoddy_1_1DenseMatrix_a419fc9d379330ea80b1cbb51a6dd9f5d}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!matrix\_to\_vector@{matrix\_to\_vector}}
\index{matrix\_to\_vector@{matrix\_to\_vector}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{matrix\_to\_vector()\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ std\+::complex$<$ double $>$ $>$\+::matrix\+\_\+to\+\_\+vector (\begin{DoxyParamCaption}\item[{\textbf{ Dense\+Vector}$<$ double $>$ \&}]{p,  }\item[{const std\+::size\+\_\+t \&}]{padding }\end{DoxyParamCaption}) const}



Definition at line 258 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{258                                                                                                                 \{}
\DoxyCodeLine{259     p.reserve(2 * m\_nr * m\_nc);}
\DoxyCodeLine{260     \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{261       \textcolor{keywordflow}{for}(std::size\_t col = 0; col < m\_nc; ++col) \{}
\DoxyCodeLine{262         p.push\_back(m\_matrix[ row ][ col ].real());}
\DoxyCodeLine{263         p.push\_back(m\_matrix[ row ][ col ].imag());}
\DoxyCodeLine{264       \}}
\DoxyCodeLine{265       \textcolor{keywordflow}{for}(std::size\_t col = 0; col < padding; ++col) \{}
\DoxyCodeLine{266         p.push\_back(0.0);}
\DoxyCodeLine{267         p.push\_back(0.0);}
\DoxyCodeLine{268       \}}
\DoxyCodeLine{269     \}}
\DoxyCodeLine{270   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a121d73b3888e5e2a4005eac0c196e515}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!matrix\_to\_vector@{matrix\_to\_vector}}
\index{matrix\_to\_vector@{matrix\_to\_vector}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{matrix\_to\_vector()\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ double $>$\+::matrix\+\_\+to\+\_\+vector (\begin{DoxyParamCaption}\item[{\textbf{ Dense\+Vector}$<$ double $>$ \&}]{p,  }\item[{const std\+::size\+\_\+t \&}]{padding }\end{DoxyParamCaption}) const}



Definition at line 274 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{274                                                                                                    \{}
\DoxyCodeLine{275     p.reserve(m\_nr * m\_nc);}
\DoxyCodeLine{276     \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{277       \textcolor{keywordflow}{for}(std::size\_t col = 0; col < m\_nc; ++col) \{}
\DoxyCodeLine{278         p.push\_back(m\_matrix[ row ][ col ]);}
\DoxyCodeLine{279       \}}
\DoxyCodeLine{280       \textcolor{keywordflow}{for}(std::size\_t col = 0; col < padding; ++col) \{}
\DoxyCodeLine{281         p.push\_back(0.0);}
\DoxyCodeLine{282       \}}
\DoxyCodeLine{283     \}}
\DoxyCodeLine{284   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a4a42dc40b4616e4200a5bd130ebeb019}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!matrix\_to\_vector@{matrix\_to\_vector}}
\index{matrix\_to\_vector@{matrix\_to\_vector}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{matrix\_to\_vector()\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::matrix\+\_\+to\+\_\+vector (\begin{DoxyParamCaption}\item[{\textbf{ Dense\+Vector}$<$ double $>$ \&}]{p,  }\item[{const std\+::size\+\_\+t \&}]{padding = {\ttfamily 0} }\end{DoxyParamCaption}) const}



Conversion to contiguous data in row major format. 


\begin{DoxyParams}{Parameters}
{\em padding} & An integer padding hack \\
\hline
{\em p} & A D\+E\+N\+SE vector containing the matrix \\
\hline
\end{DoxyParams}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a52ac6f32c031dc2714c9731b31a39f11}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!max\_in\_col@{max\_in\_col}}
\index{max\_in\_col@{max\_in\_col}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{max\_in\_col()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
std\+::vector$<$ \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ $>$\+::iterator \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::max\+\_\+in\+\_\+col (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{col,  }\item[{\textbf{ row\+\_\+iter}}]{row\+\_\+min,  }\item[{\textbf{ row\+\_\+iter}}]{row\+\_\+max }\end{DoxyParamCaption}) const}



Find the maximum abs value in a column. 


\begin{DoxyParams}{Parameters}
{\em col} & The column offset to search through \\
\hline
{\em row\+\_\+min} & Iterator to the begin row \\
\hline
{\em row\+\_\+max} & Iterator to final row (N\+OT I\+N\+C\+L\+U\+S\+I\+VE) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator to the row that contains the maximum value 
\end{DoxyReturn}


Definition at line 171 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{172                                                                            \{}
\DoxyCodeLine{173     row\_iter index(row\_min);}
\DoxyCodeLine{174     \textcolor{keywordtype}{double} maxelt(std::abs(*(row\_min -\/> begin())));}
\DoxyCodeLine{175     \textcolor{keywordflow}{for}(row\_iter row = row\_min + 1; row != row\_max ; ++row) \{}
\DoxyCodeLine{176       \textcolor{keyword}{const} \textcolor{keywordtype}{double} elt(std::abs(*(row -\/> begin() + col)));}
\DoxyCodeLine{177       \textcolor{keywordflow}{if}(elt >= maxelt) \{}
\DoxyCodeLine{178         maxelt = elt;}
\DoxyCodeLine{179         index = row;}
\DoxyCodeLine{180       \}}
\DoxyCodeLine{181     \}}
\DoxyCodeLine{182     \textcolor{keywordflow}{return} index;}
\DoxyCodeLine{183   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a0cffb03d5e18b56501a922535d34a66c}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!multiply@{multiply}}
\index{multiply@{multiply}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{multiply()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::multiply (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&}]{b }\end{DoxyParamCaption}) const}



Right-\/multiply by a D\+E\+N\+SE matrix and return the result. 


\begin{DoxyParams}{Parameters}
{\em b} & The matrix to right-\/multiply by \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The matrix result of the multiplication 
\end{DoxyReturn}


Definition at line 149 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{149                                                                                    \{}
\DoxyCodeLine{150 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{151     \textcolor{comment}{// check number of columns at least match}}
\DoxyCodeLine{152     \textcolor{keywordflow}{if}(B.nrows() != m\_nc) \{}
\DoxyCodeLine{153       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.multiply has a geometry error.\(\backslash\)n"});}
\DoxyCodeLine{154       \textcolor{keywordflow}{throw} ExceptionGeom(problem, m\_nr, m\_nc, B.nrows(), B.ncols());}
\DoxyCodeLine{155     \}}
\DoxyCodeLine{156 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{157     \textcolor{comment}{// temporary object for the result}}
\DoxyCodeLine{158     DenseMatrix<\_Type> C(nrows(), B.ncols(), 0.0);}
\DoxyCodeLine{159     \textcolor{comment}{// loops thru the columns in the B matrix}}
\DoxyCodeLine{160     \textcolor{keywordflow}{for}(std::size\_t col\_in\_B = 0; col\_in\_B < B.ncols(); ++col\_in\_B) \{}
\DoxyCodeLine{161       \textcolor{comment}{// set the column in the result to be the matrix-\/vector}}
\DoxyCodeLine{162       \textcolor{comment}{// product of (*this).multiply( column in B )}}
\DoxyCodeLine{163       C.set\_col(col\_in\_B, multiply(B.get\_col(col\_in\_B)));}
\DoxyCodeLine{164     \}}
\DoxyCodeLine{165     \textcolor{keywordflow}{return} C;}
\DoxyCodeLine{166   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a86ef45cbe60a00783bef06490397680d}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!multiply@{multiply}}
\index{multiply@{multiply}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{multiply()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::multiply (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \&}]{x }\end{DoxyParamCaption}) const}



Right multiply the matrix by a D\+E\+N\+SE vector. 


\begin{DoxyParams}{Parameters}
{\em x} & The D\+E\+N\+SE vector to be multiplied \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The D\+E\+N\+SE vector of the multiplication 
\end{DoxyReturn}


Definition at line 132 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{132                                                                                    \{}
\DoxyCodeLine{133 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{134     \textcolor{comment}{// check number of columns at least match}}
\DoxyCodeLine{135     \textcolor{keywordflow}{if}(X.size() != m\_nc) \{}
\DoxyCodeLine{136       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.multiply has a geometry error.\(\backslash\)n"});}
\DoxyCodeLine{137       \textcolor{keywordflow}{throw} ExceptionGeom(problem, m\_nr, m\_nc, X.size(), 1);}
\DoxyCodeLine{138     \}}
\DoxyCodeLine{139 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{140     DenseVector<\_Type> temp;}
\DoxyCodeLine{141     temp.reserve(m\_nr);}
\DoxyCodeLine{142     \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{143       temp.push\_back(Utility::dot(m\_matrix[ row ], X));}
\DoxyCodeLine{144     \}}
\DoxyCodeLine{145     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{146   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Elt\+::contributed\+\_\+flux\+\_\+in\+\_\+left(), Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Elt\+::contributed\+\_\+flux\+\_\+out\+\_\+right(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Elt\+::get\+\_\+\+Q\+\_\+\+Taylor\+\_\+series(), and main().

\mbox{\label{classCppNoddy_1_1DenseMatrix_ad9142e2d96214177265c20211e05df84}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!ncols@{ncols}}
\index{ncols@{ncols}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{ncols()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
std\+::size\+\_\+t \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::ncols\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}
The number of columns 
\end{DoxyReturn}


Implements \textbf{ Cpp\+Noddy\+::\+Sequential\+\_\+\+Matrix\+\_\+base$<$ \+\_\+\+Type $>$} \doxyref{}{p.}{classCppNoddy_1_1Sequential__Matrix__base_ada968915fce07d8c89c6f87dcd2aea3b}.



Definition at line 383 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{383                                                    \{}
\DoxyCodeLine{384     \textcolor{keywordflow}{return} m\_nc;}
\DoxyCodeLine{385   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+Dense\+Matrix$<$ D\+\_\+complex $>$\+::add(), Cpp\+Noddy\+::\+Utility\+::multiply(), Cpp\+Noddy\+::\+Dense\+Matrix$<$ D\+\_\+complex $>$\+::multiply(), and Cpp\+Noddy\+::\+Dense\+Matrix$<$ D\+\_\+complex $>$\+::sub().

\mbox{\label{classCppNoddy_1_1DenseMatrix_a0514ba1ea862c991a932fb57855a2024}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!nelts@{nelts}}
\index{nelts@{nelts}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{nelts()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
std\+::size\+\_\+t \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::nelts\hspace{0.3cm}{\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}
The number of elements 
\end{DoxyReturn}


Implements \textbf{ Cpp\+Noddy\+::\+Sequential\+\_\+\+Matrix\+\_\+base$<$ \+\_\+\+Type $>$} \doxyref{}{p.}{classCppNoddy_1_1Sequential__Matrix__base_a964ce81c7338b7d587c4f37c0891a3b6}.



Definition at line 71 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{71                                             \{}
\DoxyCodeLine{72     \textcolor{keywordflow}{return} m\_nr * m\_nc;}
\DoxyCodeLine{73   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a4da100b151c13b8ec5fd57ad1cc79c84}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!nrows@{nrows}}
\index{nrows@{nrows}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{nrows()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
std\+::size\+\_\+t \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::nrows\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}
The number of rows 
\end{DoxyReturn}


Implements \textbf{ Cpp\+Noddy\+::\+Sequential\+\_\+\+Matrix\+\_\+base$<$ \+\_\+\+Type $>$} \doxyref{}{p.}{classCppNoddy_1_1Sequential__Matrix__base_a9ed1f9de408603df757bd78950b45e7e}.



Definition at line 378 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{378                                                    \{}
\DoxyCodeLine{379     \textcolor{keywordflow}{return} m\_nr;}
\DoxyCodeLine{380   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+Dense\+Matrix$<$ D\+\_\+complex $>$\+::add(), Cpp\+Noddy\+::\+Utility\+::multiply(), Cpp\+Noddy\+::\+Dense\+Matrix$<$ D\+\_\+complex $>$\+::multiply(), and Cpp\+Noddy\+::\+Dense\+Matrix$<$ D\+\_\+complex $>$\+::sub().

\mbox{\label{classCppNoddy_1_1DenseMatrix_a3628f028ad16a5ffd70c8928da0c861b}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!one\_norm@{one\_norm}}
\index{one\_norm@{one\_norm}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{one\_norm()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
double \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::one\+\_\+norm}



Return the maximum one\+\_\+norm of all rows. 



Definition at line 186 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{186                                             \{}
\DoxyCodeLine{187     \textcolor{keywordtype}{double} max(0.0);}
\DoxyCodeLine{188     \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{189       max = std::max(max, m\_matrix[ row ].one\_norm());}
\DoxyCodeLine{190     \}}
\DoxyCodeLine{191     \textcolor{keywordflow}{return} max;}
\DoxyCodeLine{192   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a84ecb165447190b11c1ff5c61306ce16}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!operator()@{operator()}}
\index{operator()@{operator()}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{operator()()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\+\_\+\+Type \& \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::operator() (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{row,  }\item[{const std\+::size\+\_\+t \&}]{col }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Access operator. 



Implements \textbf{ Cpp\+Noddy\+::\+Sequential\+\_\+\+Matrix\+\_\+base$<$ \+\_\+\+Type $>$} \doxyref{}{p.}{classCppNoddy_1_1Sequential__Matrix__base_a62315ee83fe50f6ed63431e3866f29c8}.



Definition at line 306 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{307                             \{}
\DoxyCodeLine{308 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{309     \textcolor{keywordflow}{if}((row > m\_nr) || (row < 0)) \{}
\DoxyCodeLine{310       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.() has a range error.\(\backslash\)n"});}
\DoxyCodeLine{311       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nr, row, m\_nc, col);}
\DoxyCodeLine{312     \}}
\DoxyCodeLine{313     \textcolor{keywordflow}{if}((col > m\_nc) || (col < 0)) \{}
\DoxyCodeLine{314       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.() has a range error.\(\backslash\)n"});}
\DoxyCodeLine{315       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nr, row, m\_nc, col);}
\DoxyCodeLine{316     \}}
\DoxyCodeLine{317 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{318     \textcolor{keywordflow}{return} m\_matrix[ row ][ col ];}
\DoxyCodeLine{319   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_ab6f33240a35f4c5bc2f1ac563c10393d}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!operator()@{operator()}}
\index{operator()@{operator()}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{operator()()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
const \+\_\+\+Type \& \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::operator() (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{row,  }\item[{const std\+::size\+\_\+t \&}]{col }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Access operator. 



Implements \textbf{ Cpp\+Noddy\+::\+Sequential\+\_\+\+Matrix\+\_\+base$<$ \+\_\+\+Type $>$} \doxyref{}{p.}{classCppNoddy_1_1Sequential__Matrix__base_aa6ceb89a9befb03886a43007cf46e40e}.



Definition at line 290 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{291                                   \{}
\DoxyCodeLine{292 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{293     \textcolor{keywordflow}{if}((row > m\_nr) || (row < 0)) \{}
\DoxyCodeLine{294       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.() has a range error.\(\backslash\)n"});}
\DoxyCodeLine{295       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nr, row, m\_nc, col);}
\DoxyCodeLine{296     \}}
\DoxyCodeLine{297     \textcolor{keywordflow}{if}((col > m\_nc) || (col < 0)) \{}
\DoxyCodeLine{298       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.() has a range error.\(\backslash\)n"});}
\DoxyCodeLine{299       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nr, row, m\_nc, col);}
\DoxyCodeLine{300     \}}
\DoxyCodeLine{301 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{302     \textcolor{keywordflow}{return} m\_matrix[ row ][ col ];}
\DoxyCodeLine{303   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a82938f917c6166f73573463930d11476}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{operator$\ast$()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Matrix}$<$\+\_\+\+Type$>$ \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::operator$\ast$ (\begin{DoxyParamCaption}\item[{const double \&}]{m }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



S\+I\+MD operator sugar. 



Definition at line 104 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{104                                                         \{}
\DoxyCodeLine{105       DenseMatrix<\_Type> temp(*\textcolor{keyword}{this});}
\DoxyCodeLine{106       temp.scale(m);}
\DoxyCodeLine{107       \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{108     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_ab914af515c1f8205146baac044fbbeff}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!operator+@{operator+}}
\index{operator+@{operator+}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{operator+()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Matrix}$<$\+\_\+\+Type$>$ \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::operator+ (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&}]{A }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 109 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{109                                                                     \{}
\DoxyCodeLine{110       DenseMatrix<\_Type> temp(*\textcolor{keyword}{this});}
\DoxyCodeLine{111       \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{112         \textcolor{keywordflow}{for}(std::size\_t col = 0; col < m\_nc; ++col) \{}
\DoxyCodeLine{113           temp(row, col) += A(row, col);}
\DoxyCodeLine{114         \}}
\DoxyCodeLine{115       \}}
\DoxyCodeLine{116       \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{117     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_ab5a77063500824f85e4219758697b482}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{operator-\/()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Matrix}$<$\+\_\+\+Type$>$ \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::operator-\/ (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&}]{A }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 118 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{118                                                                     \{}
\DoxyCodeLine{119       DenseMatrix<\_Type> temp(*\textcolor{keyword}{this});}
\DoxyCodeLine{120       \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{121         \textcolor{keywordflow}{for}(std::size\_t col = 0; col < m\_nc; ++col) \{}
\DoxyCodeLine{122           temp(row, col) -\/= A(row, col);}
\DoxyCodeLine{123         \}}
\DoxyCodeLine{124       \}}
\DoxyCodeLine{125       \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{126     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a3a5b63cc61eb5c486901e0981e429a97}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!operator=@{operator=}}
\index{operator=@{operator=}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{operator=()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \& \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&}]{source }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Assignment operator. 


\begin{DoxyParams}{Parameters}
{\em source} & The source object for the assignment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The newly assigned object 
\end{DoxyReturn}


Definition at line 61 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{61                                                                                            \{}
\DoxyCodeLine{62     \textcolor{keywordflow}{if}(\textcolor{keyword}{this} == \&source)}
\DoxyCodeLine{63       \textcolor{keywordflow}{return} * \textcolor{keyword}{this};}
\DoxyCodeLine{64     m\_matrix = source.m\_matrix;}
\DoxyCodeLine{65     m\_nr = source.m\_nr;}
\DoxyCodeLine{66     m\_nc = source.m\_nc;}
\DoxyCodeLine{67     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{68   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_ac2319ee2f472dae546ee4bd70a777728}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!operator[]@{operator[]}}
\index{operator[]@{operator[]}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{operator[]()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \& \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::operator[$\,$] (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{row }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Operator overloading for R\+OW access. 


\begin{DoxyParams}{Parameters}
{\em row} & The row to access \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The D\+E\+N\+SE vector of the row data 
\end{DoxyReturn}


Definition at line 356 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{356                                                                                  \{}
\DoxyCodeLine{357 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{358     \textcolor{keywordflow}{if}((row > m\_nr) || (row < 0)) \{}
\DoxyCodeLine{359       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.get\_row has a range error.\(\backslash\)n"});}
\DoxyCodeLine{360       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nr, row);}
\DoxyCodeLine{361     \}}
\DoxyCodeLine{362 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{363     \textcolor{keywordflow}{return} m\_matrix[ row ];}
\DoxyCodeLine{364   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_aadb6d7b63d73e6b4d0777da5dadc2fa2}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!operator[]@{operator[]}}
\index{operator[]@{operator[]}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{operator[]()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
const \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \& \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::operator[$\,$] (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{row }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Operator overloading for R\+OW access. 


\begin{DoxyParams}{Parameters}
{\em row} & The row to access \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The D\+E\+N\+SE vector of the row data 
\end{DoxyReturn}


Definition at line 367 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{367                                                                                              \{}
\DoxyCodeLine{368 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{369     \textcolor{keywordflow}{if}((row > m\_nr) || (row < 0)) \{}
\DoxyCodeLine{370       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.get\_row has a range error.\(\backslash\)n"});}
\DoxyCodeLine{371       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nr, row);}
\DoxyCodeLine{372     \}}
\DoxyCodeLine{373 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{374     \textcolor{keywordflow}{return} m\_matrix[ row ];}
\DoxyCodeLine{375   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a62925eaf0d14522de3196dbca495fe8a}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!rbegin@{rbegin}}
\index{rbegin@{rbegin}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{rbegin()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ row\+\_\+riter} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::rbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pass through of iterator calls. 

\begin{DoxyReturn}{Returns}
Reverse iterator to the begin row 
\end{DoxyReturn}


Definition at line 188 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{188                        \{}
\DoxyCodeLine{189       \textcolor{keywordflow}{return} m\_matrix.rbegin();}
\DoxyCodeLine{190     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_ac99f2b87c56ce0a0e080eaac89d2b785}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!rbegin@{rbegin}}
\index{rbegin@{rbegin}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{rbegin()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ row\+\_\+criter} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::rbegin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Pass through of iterator calls. 

\begin{DoxyReturn}{Returns}
Const reverse iterator to the begin row 
\end{DoxyReturn}


Definition at line 212 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{212                               \{}
\DoxyCodeLine{213       \textcolor{keywordflow}{return} m\_matrix.rbegin();}
\DoxyCodeLine{214     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a9e7656c80d94324e8fa871c0057dae42}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!rend@{rend}}
\index{rend@{rend}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{rend()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ row\+\_\+riter} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::rend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Pass through of iterator calls. 

\begin{DoxyReturn}{Returns}
Reverse iterator to the end row 
\end{DoxyReturn}


Definition at line 194 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{194                      \{}
\DoxyCodeLine{195       \textcolor{keywordflow}{return} m\_matrix.rend();}
\DoxyCodeLine{196     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a9477cc0294a81c9bd38f1c1ba664f68b}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!rend@{rend}}
\index{rend@{rend}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{rend()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ row\+\_\+criter} \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::rend (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Pass through of iterator calls. 

\begin{DoxyReturn}{Returns}
Const reverse iterator to the end row 
\end{DoxyReturn}


Definition at line 218 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{218                             \{}
\DoxyCodeLine{219       \textcolor{keywordflow}{return} m\_matrix.rend();}
\DoxyCodeLine{220     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_ac40828c85557b523079cc37868f58873}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!scale@{scale}}
\index{scale@{scale}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{scale()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::scale (\begin{DoxyParamCaption}\item[{const \+\_\+\+Type \&}]{mult }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Scale all matrix elements by a scalar. 


\begin{DoxyParams}{Parameters}
{\em mult} & The scalar multiplier \\
\hline
\end{DoxyParams}


Implements \textbf{ Cpp\+Noddy\+::\+Sequential\+\_\+\+Matrix\+\_\+base$<$ \+\_\+\+Type $>$} \doxyref{}{p.}{classCppNoddy_1_1Sequential__Matrix__base_a0d5696cf9bada8aa9c25aeee5f43fa8f}.



Definition at line 100 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{100                                                   \{}
\DoxyCodeLine{101     std::transform(m\_matrix.begin(), m\_matrix.end(), m\_matrix.begin(), scale\_functor< DenseVector<\_Type>, \_Type >(mult));}
\DoxyCodeLine{102   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+Equation\+\_\+1matrix$<$ D\+\_\+complex $>$\+::get\+\_\+jacobian\+\_\+of\+\_\+matrix0\+\_\+mult\+\_\+vector(), Cpp\+Noddy\+::\+Equation\+\_\+2matrix$<$ D\+\_\+complex $>$\+::get\+\_\+jacobian\+\_\+of\+\_\+matrix1\+\_\+mult\+\_\+vector(), Cpp\+Noddy\+::\+Equation\+\_\+3matrix$<$ \+\_\+\+Type $>$\+::get\+\_\+jacobian\+\_\+of\+\_\+matrix2\+\_\+mult\+\_\+vector(), main(), and Cpp\+Noddy\+::\+Dense\+Matrix$<$ D\+\_\+complex $>$\+::operator$\ast$().

\mbox{\label{classCppNoddy_1_1DenseMatrix_a86b0b0a2264b04599561685bd529c07d}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!set@{set}}
\index{set@{set}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{set()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\+\_\+\+Type \& \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::set (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{row,  }\item[{const std\+::size\+\_\+t \&}]{col }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Access operator. 



Implements \textbf{ Cpp\+Noddy\+::\+Sequential\+\_\+\+Matrix\+\_\+base$<$ \+\_\+\+Type $>$} \doxyref{}{p.}{classCppNoddy_1_1Sequential__Matrix__base_a78cdd7b54cc2d76e8c9df83ef0423525}.



Definition at line 340 of file Dense\+Matrix.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{341                          \{}
\DoxyCodeLine{342 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{343     \textcolor{keywordflow}{if}((row > m\_nr) || (row < 0)) \{}
\DoxyCodeLine{344       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.set has a range error.\(\backslash\)n"});}
\DoxyCodeLine{345       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nr, row, m\_nc, col);}
\DoxyCodeLine{346     \}}
\DoxyCodeLine{347     \textcolor{keywordflow}{if}((col > m\_nc) || (col < 0)) \{}
\DoxyCodeLine{348       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.set has a range error.\(\backslash\)n"});}
\DoxyCodeLine{349       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nr, row, m\_nc, col);}
\DoxyCodeLine{350     \}}
\DoxyCodeLine{351 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{352     \textcolor{keywordflow}{return} m\_matrix[ row ][ col ];}
\DoxyCodeLine{353   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1DenseMatrix_a59f7f071fc8c93aa70a1513862e29a4f}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!set\_col@{set\_col}}
\index{set\_col@{set\_col}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{set\_col()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::set\+\_\+col (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{col,  }\item[{const \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \&}]{x }\end{DoxyParamCaption})}



Set a column of the matrix. 


\begin{DoxyParams}{Parameters}
{\em col} & The column to be set \\
\hline
{\em x} & The D\+E\+N\+SE vector of column information \\
\hline
\end{DoxyParams}


Definition at line 242 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{242                                                                                     \{}
\DoxyCodeLine{243     \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{244       m\_matrix[ row ][ col ] = X[ row ];}
\DoxyCodeLine{245     \}}
\DoxyCodeLine{246   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+One\+D\+\_\+\+Hyperbolic\+\_\+\+System\+::\+Jac\+\_\+flux\+\_\+fn(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Hyperbolic\+\_\+\+System\+::\+Jac\+\_\+flux\+\_\+fn\+\_\+x(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Hyperbolic\+\_\+\+System\+::\+Jac\+\_\+flux\+\_\+fn\+\_\+y(), Cpp\+Noddy\+::\+Residual$<$ D\+\_\+complex $>$\+::jacobian(), and Cpp\+Noddy\+::\+Dense\+Matrix$<$ D\+\_\+complex $>$\+::multiply().

\mbox{\label{classCppNoddy_1_1DenseMatrix_ac96b16cfbf65de793628eb724761bc12}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!sub@{sub}}
\index{sub@{sub}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{sub()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::sub (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \&}]{b }\end{DoxyParamCaption})}



Subtract a D\+E\+N\+SE matrix from this object. 


\begin{DoxyParams}{Parameters}
{\em b} & The D\+E\+N\+SE matrix to subtract from \textquotesingle{}this\textquotesingle{} \\
\hline
\end{DoxyParams}


Definition at line 88 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{88                                                           \{}
\DoxyCodeLine{89 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{90     \textcolor{comment}{// check number of columns at least match}}
\DoxyCodeLine{91     \textcolor{keywordflow}{if}((B.nrows() != m\_nr) || (B.ncols() != m\_nc)) \{}
\DoxyCodeLine{92       std::string problem(\textcolor{stringliteral}{"The DenseMatrix.sub has a geometry error.\(\backslash\)n"});}
\DoxyCodeLine{93       \textcolor{keywordflow}{throw} ExceptionGeom(problem, m\_nr, m\_nc, B.nrows(), B.ncols());}
\DoxyCodeLine{94     \}}
\DoxyCodeLine{95 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{96     std::transform(m\_matrix.begin(), m\_matrix.end(), B.m\_matrix.begin(), m\_matrix.begin(), std::minus< DenseVector<\_Type> >());}
\DoxyCodeLine{97   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+Equation\+\_\+1matrix$<$ D\+\_\+complex $>$\+::get\+\_\+jacobian\+\_\+of\+\_\+matrix0\+\_\+mult\+\_\+vector(), Cpp\+Noddy\+::\+Equation\+\_\+2matrix$<$ D\+\_\+complex $>$\+::get\+\_\+jacobian\+\_\+of\+\_\+matrix1\+\_\+mult\+\_\+vector(), Cpp\+Noddy\+::\+Equation\+\_\+3matrix$<$ \+\_\+\+Type $>$\+::get\+\_\+jacobian\+\_\+of\+\_\+matrix2\+\_\+mult\+\_\+vector(), and main().

\mbox{\label{classCppNoddy_1_1DenseMatrix_a9c2a2a4940730d842bd0e9114b415795}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!transpose@{transpose}}
\index{transpose@{transpose}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{transpose()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::transpose}



Transpose the matrix. 



Definition at line 105 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{105                                      \{}
\DoxyCodeLine{106     \textcolor{keywordflow}{if}(nrows() == ncols()) \{}
\DoxyCodeLine{107       \textcolor{comment}{// square matrix needs no temp object}}
\DoxyCodeLine{108       \textcolor{comment}{// loop through upper half diagonal of the matrix}}
\DoxyCodeLine{109       \textcolor{keywordflow}{for}(std::size\_t i = 0; i < nrows(); ++i) \{}
\DoxyCodeLine{110         \textcolor{keywordflow}{for}(std::size\_t j = i + 1; j < ncols(); ++j) \{}
\DoxyCodeLine{111           \textcolor{comment}{// swap elements}}
\DoxyCodeLine{112           std::swap(m\_matrix[ i ][ j ], m\_matrix[ j ][ i ]);}
\DoxyCodeLine{113         \}}
\DoxyCodeLine{114       \}}
\DoxyCodeLine{115     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{116       std::vector< DenseVector<\_Type> > temp;}
\DoxyCodeLine{117       temp.resize(m\_nc);}
\DoxyCodeLine{118       \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nc; ++row) \{}
\DoxyCodeLine{119         temp[ row ].resize(m\_nr);}
\DoxyCodeLine{120       \}}
\DoxyCodeLine{121       \textcolor{keywordflow}{for}(std::size\_t i = 0; i < nrows(); ++i) \{}
\DoxyCodeLine{122         \textcolor{keywordflow}{for}(std::size\_t j = 0; j < ncols(); ++j) \{}
\DoxyCodeLine{123           temp[ j ][ i ] = m\_matrix[ i ][ j ];}
\DoxyCodeLine{124         \}}
\DoxyCodeLine{125       \}}
\DoxyCodeLine{126       m\_matrix = temp;}
\DoxyCodeLine{127       std::swap(m\_nr, m\_nc);}
\DoxyCodeLine{128     \}}
\DoxyCodeLine{129   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+Fortran\+Data\+::\+Fortran\+Data().

\mbox{\label{classCppNoddy_1_1DenseMatrix_ad900c1a3eb878a5fe0c1fca4ff52856e}} 
\index{CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}!two\_norm@{two\_norm}}
\index{two\_norm@{two\_norm}!CppNoddy::DenseMatrix$<$ \_Type $>$@{CppNoddy::DenseMatrix$<$ \_Type $>$}}
\doxyparagraph{two\_norm()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
double \textbf{ Cpp\+Noddy\+::\+Dense\+Matrix}$<$ \+\_\+\+Type $>$\+::two\+\_\+norm}



Rreturn the maximum two\+\_\+norm of all rows. 



Definition at line 195 of file Dense\+Matrix.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{195                                             \{}
\DoxyCodeLine{196     \textcolor{keywordtype}{double} max(0.0);}
\DoxyCodeLine{197     \textcolor{keywordflow}{for}(std::size\_t row = 0; row < m\_nr; ++row) \{}
\DoxyCodeLine{198       max = std::max(max, m\_matrix[ row ].two\_norm());}
\DoxyCodeLine{199     \}}
\DoxyCodeLine{200     \textcolor{keywordflow}{return} max;}
\DoxyCodeLine{201   \}}

\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/\textbf{ Dense\+Matrix.\+h}\item 
src/\textbf{ Dense\+Matrix.\+cpp}\end{DoxyCompactItemize}
