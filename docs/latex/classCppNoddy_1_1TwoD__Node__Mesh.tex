\doxysubsection{Cpp\+Noddy\+::Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$ Class Template Reference}
\label{classCppNoddy_1_1TwoD__Node__Mesh}\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}


A two dimensional mesh utility object.  




{\ttfamily \#include $<$Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Two\+D\+\_\+\+Node\+\_\+\+Mesh} ()
\item 
\textbf{ Two\+D\+\_\+\+Node\+\_\+\+Mesh} (const \textbf{ Dense\+Vector}$<$ double $>$ \&x\+\_\+nodes, const \textbf{ Dense\+Vector}$<$ double $>$ \&y\+\_\+nodes, const std\+::size\+\_\+t nvars)
\begin{DoxyCompactList}\small\item\em ctor \end{DoxyCompactList}\item 
\textbf{ Two\+D\+\_\+\+Node\+\_\+\+Mesh} (const double left, const double right, const double bottom, const double top, const std\+::size\+\_\+t nx, const std\+::size\+\_\+t ny, const std\+::size\+\_\+t nvars)
\begin{DoxyCompactList}\small\item\em ctor \end{DoxyCompactList}\item 
\textbf{ Two\+D\+\_\+\+Node\+\_\+\+Mesh} (std\+::string filename, const std\+::size\+\_\+t nx, const std\+::size\+\_\+t ny, const std\+::size\+\_\+t nv)
\item 
virtual \textbf{ $\sim$\+Two\+D\+\_\+\+Node\+\_\+\+Mesh} ()
\begin{DoxyCompactList}\small\item\em dtor \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \textbf{ operator()} (const std\+::size\+\_\+t nodex, const std\+::size\+\_\+t nodey)
\begin{DoxyCompactList}\small\item\em Access operator for a nodal point that returns a vector. \end{DoxyCompactList}\item 
\+\_\+\+Type \& \textbf{ operator()} (const std\+::size\+\_\+t nodex, const std\+::size\+\_\+t nodey, const std\+::size\+\_\+t var)
\begin{DoxyCompactList}\small\item\em Access operator for a nodal point/variable in the mesh. \end{DoxyCompactList}\item 
const \+\_\+\+Type \& \textbf{ operator()} (const std\+::size\+\_\+t nodex, const std\+::size\+\_\+t nodey, const std\+::size\+\_\+t var) const
\begin{DoxyCompactList}\small\item\em Const access operator for a nodal point/variable in the mesh. \end{DoxyCompactList}\item 
std\+::pair$<$ double, double $>$ \textbf{ coord} (const std\+::size\+\_\+t nodex, const std\+::size\+\_\+t nodey) const
\begin{DoxyCompactList}\small\item\em Access the nodal position -\/ as a pair. \end{DoxyCompactList}\item 
double \& \textbf{ xcoord} (const std\+::size\+\_\+t nodex)
\begin{DoxyCompactList}\small\item\em Access the x-\/nodal (first index) position. \end{DoxyCompactList}\item 
double \& \textbf{ ycoord} (const std\+::size\+\_\+t nodey)
\begin{DoxyCompactList}\small\item\em Access the y-\/nodal (second index) position. \end{DoxyCompactList}\item 
void \textbf{ set\+\_\+nodes\+\_\+vars} (const std\+::size\+\_\+t nodex, const std\+::size\+\_\+t nodey, const \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \&\textbf{ U})
\begin{DoxyCompactList}\small\item\em Set the variables stored at A S\+P\+E\+C\+I\+F\+I\+ED node. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \textbf{ get\+\_\+nodes\+\_\+vars} (const std\+::size\+\_\+t nodex, const std\+::size\+\_\+t nodey) const
\begin{DoxyCompactList}\small\item\em Get the variables stored at A S\+P\+E\+C\+I\+F\+I\+ED node -- equivalent to mesh(nodex,nodey). \end{DoxyCompactList}\item 
\textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$ \textbf{ get\+\_\+xsection\+\_\+at\+\_\+xnode} (const std\+::size\+\_\+t nodex) const
\begin{DoxyCompactList}\small\item\em Get a cross section of the 2D mesh at a specified (constant) x node. \end{DoxyCompactList}\item 
\textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$ \textbf{ get\+\_\+xsection\+\_\+at\+\_\+ynode} (const std\+::size\+\_\+t nodey) const
\begin{DoxyCompactList}\small\item\em Get a cross section of the 2D mesh at a specified (constant) y node. \end{DoxyCompactList}\item 
\textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$ \textbf{ get\+\_\+xsection\+\_\+at\+\_\+x1} (const double x) const
\begin{DoxyCompactList}\small\item\em Get a cross section of the 2D mesh at a specified (constant) x node. \end{DoxyCompactList}\item 
void \textbf{ assign} (const \+\_\+\+Type elt)
\begin{DoxyCompactList}\small\item\em Assign an element to all entries in the mesh. \end{DoxyCompactList}\item 
std\+::pair$<$ std\+::size\+\_\+t, std\+::size\+\_\+t $>$ \textbf{ get\+\_\+nnodes} () const
\begin{DoxyCompactList}\small\item\em Get the number of nodes in the two directions of the 2D mesh. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \textbf{ get\+\_\+nvars} () const
\begin{DoxyCompactList}\small\item\em Get the number of variables that are stored at each node. \end{DoxyCompactList}\item 
const \textbf{ Dense\+Vector}$<$ double $>$ \& \textbf{ xnodes} () const
\begin{DoxyCompactList}\small\item\em Access the vector of x-\/nodal positions. \end{DoxyCompactList}\item 
const \textbf{ Dense\+Vector}$<$ double $>$ \& \textbf{ ynodes} () const
\begin{DoxyCompactList}\small\item\em Access the vector of y-\/nodal positions. \end{DoxyCompactList}\item 
\textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \textbf{ get\+\_\+var\+\_\+as\+\_\+matrix} (std\+::size\+\_\+t var) const
\begin{DoxyCompactList}\small\item\em Return a matrix corresponding to each nodal point in the mesh Each matrix element will contain a specified variable number. \end{DoxyCompactList}\item 
void \textbf{ remesh1} (const \textbf{ Dense\+Vector}$<$ double $>$ \&newX, const \textbf{ Dense\+Vector}$<$ double $>$ \&newY)
\begin{DoxyCompactList}\small\item\em Interpolate this mesh data (bilinearly) into a new mesh with nodal points defined in the argument list. \end{DoxyCompactList}\item 
void \textbf{ dump} () const
\begin{DoxyCompactList}\small\item\em A simple method for dumping data to std\+::cout. \end{DoxyCompactList}\item 
void \textbf{ dump} (std\+::string filename) const
\begin{DoxyCompactList}\small\item\em A simple method for dumping data to a file. \end{DoxyCompactList}\item 
void \textbf{ dump\+\_\+var} (std\+::string filename, const unsigned var) const
\begin{DoxyCompactList}\small\item\em A simple method for dumping a single variable to a file with no nodal information. \end{DoxyCompactList}\item 
void \textbf{ read} (std\+::string filename, const bool reset=false)
\begin{DoxyCompactList}\small\item\em A simple method for reading data from a file. \end{DoxyCompactList}\item 
void \textbf{ dump\+\_\+gnu} (std\+::string filename) const
\begin{DoxyCompactList}\small\item\em A simple method for dumping data to a file for gnuplot surface plotting. \end{DoxyCompactList}\item 
void \textbf{ normalise} (const std\+::size\+\_\+t \&var)
\begin{DoxyCompactList}\small\item\em Normalise all data in the mesh based on one variable. \end{DoxyCompactList}\item 
void \textbf{ scale} (const \+\_\+\+Type \&value)
\begin{DoxyCompactList}\small\item\em Calls the vector \char`\"{}scale\char`\"{} method for the whole mesh data. \end{DoxyCompactList}\item 
void \textbf{ normalise\+\_\+real\+\_\+part} (const std\+::size\+\_\+t \&var)
\begin{DoxyCompactList}\small\item\em Normalise the mesh such that the real part of variable \textquotesingle{}var\textquotesingle{} has a real part of unity, and is then the largest real part across the whole mesh. \end{DoxyCompactList}\item 
double \textbf{ max\+\_\+abs\+\_\+real\+\_\+part} (unsigned var)
\begin{DoxyCompactList}\small\item\em Find the maximum stored absolute value in the mesh for a given variable -- no interpolation is used. \end{DoxyCompactList}\item 
double \textbf{ max\+\_\+abs} (unsigned var)
\begin{DoxyCompactList}\small\item\em Find the maximum stored absolute value in the mesh for a given variable -- no interpolation is used. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \textbf{ get\+\_\+interpolated\+\_\+vars} (const double \&x, const double \&y)
\begin{DoxyCompactList}\small\item\em Get a bilinearly interpolated value at a specified point. \end{DoxyCompactList}\item 
void \textbf{ normalise} (const std\+::size\+\_\+t \&var)
\item 
void \textbf{ normalise} (const std\+::size\+\_\+t \&var)
\item 
double \textbf{ max\+\_\+abs\+\_\+real\+\_\+part} (unsigned var)
\item 
double \textbf{ max\+\_\+abs\+\_\+real\+\_\+part} (unsigned var)
\item 
void \textbf{ dump\+\_\+gnu} (std\+::string filename) const
\item 
void \textbf{ dump\+\_\+gnu} (std\+::string filename) const
\item 
void \textbf{ read} (std\+::string filename, bool reset)
\item 
void \textbf{ read} (std\+::string filename, bool reset)
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::size\+\_\+t \textbf{ m\+\_\+nx}
\item 
std\+::size\+\_\+t \textbf{ m\+\_\+ny}
\item 
std\+::size\+\_\+t \textbf{ m\+\_\+nv}
\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ m\+\_\+X}
\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ m\+\_\+Y}
\item 
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \textbf{ m\+\_\+vars}
\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
\subsubsection*{template$<$typename \+\_\+\+Type$>$\newline
class Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$}

A two dimensional mesh utility object. 

Definition at line 19 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.



\doxysubsubsection{Constructor \& Destructor Documentation}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_af268736c85aecf89e6ec8ed5e86ef018}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!TwoD\_Node\_Mesh@{TwoD\_Node\_Mesh}}
\index{TwoD\_Node\_Mesh@{TwoD\_Node\_Mesh}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{TwoD\_Node\_Mesh()\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::\textbf{ Two\+D\+\_\+\+Node\+\_\+\+Mesh} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 22 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{23     \{\}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_acf4a40735e5f9bdae066baca06a1be52}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!TwoD\_Node\_Mesh@{TwoD\_Node\_Mesh}}
\index{TwoD\_Node\_Mesh@{TwoD\_Node\_Mesh}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{TwoD\_Node\_Mesh()\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::\textbf{ Two\+D\+\_\+\+Node\+\_\+\+Mesh} (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{x\+\_\+nodes,  }\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{y\+\_\+nodes,  }\item[{const std\+::size\+\_\+t}]{nvars }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



ctor 



Definition at line 26 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{27                                           :}
\DoxyCodeLine{28       m\_nx(x\_nodes.size()), m\_ny(y\_nodes.size()), m\_nv(nvars), m\_X(x\_nodes), m\_Y(y\_nodes) \{}
\DoxyCodeLine{29       \textcolor{comment}{// we'll store the data as ( x, y, v ) -\/>  x * ny * nv + y * nv + v}}
\DoxyCodeLine{30       m\_vars = DenseVector<\_Type>(m\_nx * m\_ny * m\_nv, 0.0);}
\DoxyCodeLine{31     \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+nv, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+nx, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+ny, and Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+vars.

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_ae4ddaf270169fc08dbe720d7d2d4c16b}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!TwoD\_Node\_Mesh@{TwoD\_Node\_Mesh}}
\index{TwoD\_Node\_Mesh@{TwoD\_Node\_Mesh}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{TwoD\_Node\_Mesh()\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::\textbf{ Two\+D\+\_\+\+Node\+\_\+\+Mesh} (\begin{DoxyParamCaption}\item[{const double}]{left,  }\item[{const double}]{right,  }\item[{const double}]{bottom,  }\item[{const double}]{top,  }\item[{const std\+::size\+\_\+t}]{nx,  }\item[{const std\+::size\+\_\+t}]{ny,  }\item[{const std\+::size\+\_\+t}]{nvars }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



ctor 



Definition at line 34 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{35                                                                                   :}
\DoxyCodeLine{36       m\_nx(nx), m\_ny(ny), m\_nv(nvars) \{}
\DoxyCodeLine{37       \{}
\DoxyCodeLine{38         m\_X.reserve(m\_nx);}
\DoxyCodeLine{39         \textcolor{keyword}{const} \textcolor{keywordtype}{double} delta = (right -\/ left) / (m\_nx -\/ 1);}
\DoxyCodeLine{40         \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_nx; ++i) \{}
\DoxyCodeLine{41           m\_X.push\_back(left + delta * i);}
\DoxyCodeLine{42         \}}
\DoxyCodeLine{43       \}}
\DoxyCodeLine{44       \{}
\DoxyCodeLine{45         m\_Y.reserve(m\_ny);}
\DoxyCodeLine{46         \textcolor{keyword}{const} \textcolor{keywordtype}{double} delta = (top -\/ bottom) / (m\_ny -\/ 1);}
\DoxyCodeLine{47         \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_ny; ++i) \{}
\DoxyCodeLine{48           m\_Y.push\_back(bottom + delta * i);}
\DoxyCodeLine{49         \}}
\DoxyCodeLine{50       \}}
\DoxyCodeLine{51       \textcolor{comment}{// we'll store the data as ( x, y, v ) -\/>  x * ny * nv + y * nv + v}}
\DoxyCodeLine{52       m\_vars = DenseVector<\_Type>(m\_nx * m\_ny * m\_nv, 0.0);}
\DoxyCodeLine{53     \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+nv, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+nx, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+ny, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+vars, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+X, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+Y, Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::push\+\_\+back(), and Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::reserve().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a77793597a2f20a6d32c747c1362d4265}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!TwoD\_Node\_Mesh@{TwoD\_Node\_Mesh}}
\index{TwoD\_Node\_Mesh@{TwoD\_Node\_Mesh}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{TwoD\_Node\_Mesh()\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::\textbf{ Two\+D\+\_\+\+Node\+\_\+\+Mesh} (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{const std\+::size\+\_\+t}]{nx,  }\item[{const std\+::size\+\_\+t}]{ny,  }\item[{const std\+::size\+\_\+t}]{nv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 56 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{56                                                                                                     :}
\DoxyCodeLine{57       m\_nx(nx), m\_ny(ny), m\_nv(nv) \{}
\DoxyCodeLine{58       \textcolor{comment}{// need storage for the coordinates}}
\DoxyCodeLine{59       m\_X = DenseVector<double>(nx, 0.0);}
\DoxyCodeLine{60       m\_Y = DenseVector<double>(ny, 0.0);}
\DoxyCodeLine{61       \textcolor{comment}{// we'll store the data as ( x, y, v ) -\/>  x * ny * nv + y * nv + v}}
\DoxyCodeLine{62       m\_vars = DenseVector<\_Type>(nx * ny * nv, 0.0);}
\DoxyCodeLine{63       \textcolor{comment}{// now read the mesh from the given filename}}
\DoxyCodeLine{64       read(filename, \textcolor{keyword}{true});}
\DoxyCodeLine{65     \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+vars, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+X, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+Y, and Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::read().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a4f0d9f66dea349cf2c81df7cf4d09dff}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!````~TwoD\_Node\_Mesh@{$\sim$TwoD\_Node\_Mesh}}
\index{````~TwoD\_Node\_Mesh@{$\sim$TwoD\_Node\_Mesh}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{$\sim$TwoD\_Node\_Mesh()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
virtual \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::$\sim$\textbf{ Two\+D\+\_\+\+Node\+\_\+\+Mesh} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



dtor 



Definition at line 68 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{69     \{\}}

\end{DoxyCode}


\doxysubsubsection{Member Function Documentation}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a805f8d2f06ce2a74629ff988b62676b0}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!assign@{assign}}
\index{assign@{assign}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{assign()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::assign (\begin{DoxyParamCaption}\item[{const \+\_\+\+Type}]{elt }\end{DoxyParamCaption})}



Assign an element to all entries in the mesh. 


\begin{DoxyParams}{Parameters}
{\em elt} & The element to be assigned to the mesh \\
\hline
\end{DoxyParams}


Definition at line 52 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{52                                                     \{}
\DoxyCodeLine{53     m\_vars.assign(m\_nx * m\_ny * m\_nv, elt);}
\DoxyCodeLine{54   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_afe6a515be72c7c34414097093c37896f}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!coord@{coord}}
\index{coord@{coord}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{coord()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
std\+::pair$<$ double, double $>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::coord (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{nodex,  }\item[{const std\+::size\+\_\+t}]{nodey }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Access the nodal position -\/ as a pair. 


\begin{DoxyParams}{Parameters}
{\em nodex} & The x nodal position to return \\
\hline
{\em nodey} & The y nodal position to return \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The spatial position of this node as a pair 
\end{DoxyReturn}


Definition at line 369 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{369                                                                                                                 \{}
\DoxyCodeLine{370 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{371     \textcolor{keywordflow}{if}(nodex > m\_nx -\/ 1 || nodey > m\_ny -\/ 1) \{}
\DoxyCodeLine{372       std::string problem;}
\DoxyCodeLine{373       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.coord method is trying to \(\backslash\)n"};}
\DoxyCodeLine{374       problem += \textcolor{stringliteral}{" access a nodal point that is not in the mesh. \(\backslash\)n"};}
\DoxyCodeLine{375       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nx, nodex, m\_ny, nodey);}
\DoxyCodeLine{376     \}}
\DoxyCodeLine{377 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{378     std::pair< double, double > pos;}
\DoxyCodeLine{379     pos.first = m\_X[ nodex ];}
\DoxyCodeLine{380     pos.second = m\_Y[ nodey ];}
\DoxyCodeLine{381     \textcolor{keywordflow}{return} pos;}
\DoxyCodeLine{382   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_ada14236beba194e538ec2cac40399ee4}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!dump@{dump}}
\index{dump@{dump}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{dump()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::dump}



A simple method for dumping data to std\+::cout. 



Definition at line 318 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{318                                          \{}
\DoxyCodeLine{319     \textcolor{keywordflow}{for}(std::size\_t var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{320       std::cout << \textcolor{stringliteral}{"Variable : "} << var << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{321       std::cout << \textcolor{stringliteral}{" x = "};}
\DoxyCodeLine{322       \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_nx; ++i) \{}
\DoxyCodeLine{323         std::cout << m\_X[ i ] << \textcolor{stringliteral}{", "};}
\DoxyCodeLine{324       \}}
\DoxyCodeLine{325 }
\DoxyCodeLine{326       std::cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{327       \textcolor{keywordflow}{for}(std::size\_t j = 0; j < m\_ny; ++j) \{}
\DoxyCodeLine{328         std::cout << \textcolor{stringliteral}{" y = "} << m\_Y[ j ] << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{329         \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_nx; ++i) \{}
\DoxyCodeLine{330           std::cout << m\_vars[(i * m\_ny + j) * m\_nv + var ] << \textcolor{stringliteral}{", "};}
\DoxyCodeLine{331         \}}
\DoxyCodeLine{332         std::cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{333       \}}
\DoxyCodeLine{334     \}}
\DoxyCodeLine{335   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a7ac9a679e8fd90264e91bf7a9e58ba3f}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!dump@{dump}}
\index{dump@{dump}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{dump()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::dump (\begin{DoxyParamCaption}\item[{std\+::string}]{filename }\end{DoxyParamCaption}) const}



A simple method for dumping data to a file. 


\begin{DoxyParams}{Parameters}
{\em filename} & The filename to write the data to (will overwrite) \\
\hline
\end{DoxyParams}


Definition at line 455 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{455                                                            \{}
\DoxyCodeLine{456     std::ofstream dump;}
\DoxyCodeLine{457     dump.open(filename.c\_str());}
\DoxyCodeLine{458     dump.precision(15);}
\DoxyCodeLine{459     dump.setf(std::ios::showpoint);}
\DoxyCodeLine{460     dump.setf(std::ios::showpos);}
\DoxyCodeLine{461     dump.setf(std::ios::scientific);}
\DoxyCodeLine{462     \textcolor{comment}{//dump << m\_nx << " " << m\_ny << " " << m\_nv << "\(\backslash\)n";}}
\DoxyCodeLine{463     dump.precision(9);}
\DoxyCodeLine{464     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_nx; ++i) \{}
\DoxyCodeLine{465       \textcolor{keywordflow}{for}(std::size\_t j = 0; j < m\_ny; ++j) \{}
\DoxyCodeLine{466         dump << m\_X[ i ] << \textcolor{stringliteral}{" "} << m\_Y[ j ] << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{467         \textcolor{keywordflow}{for}(std::size\_t var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{468           dump << m\_vars[(i * m\_ny + j) * m\_nv + var ] << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{469         \}}
\DoxyCodeLine{470         dump << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{471       \}}
\DoxyCodeLine{472     \}}
\DoxyCodeLine{473   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_acb1d3f7ec0037f9950f1965c5b7c9a92}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!dump\_gnu@{dump\_gnu}}
\index{dump\_gnu@{dump\_gnu}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{dump\_gnu()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::dump\+\_\+gnu (\begin{DoxyParamCaption}\item[{std\+::string}]{filename }\end{DoxyParamCaption}) const}



A simple method for dumping data to a file for gnuplot surface plotting. 


\begin{DoxyParams}{Parameters}
{\em filename} & The filename to write the data to (will overwrite) \\
\hline
\end{DoxyParams}


Referenced by main().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a69aafacd29706602063ea3259b6edd14}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!dump\_gnu@{dump\_gnu}}
\index{dump\_gnu@{dump\_gnu}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{dump\_gnu()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ double $>$\+::dump\+\_\+gnu (\begin{DoxyParamCaption}\item[{std\+::string}]{filename }\end{DoxyParamCaption}) const}



Definition at line 395 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{395                                                                 \{}
\DoxyCodeLine{396     std::ofstream dump;}
\DoxyCodeLine{397     dump.open(filename.c\_str());}
\DoxyCodeLine{398     dump.precision(15);}
\DoxyCodeLine{399     dump.setf(std::ios::showpoint);}
\DoxyCodeLine{400     dump.setf(std::ios::showpos);}
\DoxyCodeLine{401     dump.setf(std::ios::scientific);}
\DoxyCodeLine{402     \textcolor{comment}{//}}
\DoxyCodeLine{403     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_nx; ++i) \{}
\DoxyCodeLine{404       \textcolor{keywordflow}{for}(std::size\_t j = 0; j < m\_ny; ++j) \{}
\DoxyCodeLine{405         dump << m\_X[ i ] << \textcolor{stringliteral}{" "} << m\_Y[ j ] << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{406         \textcolor{keywordflow}{for}(std::size\_t var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{407           dump << m\_vars[(i * m\_ny + j) * m\_nv + var ] << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{408         \}}
\DoxyCodeLine{409         dump << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{410       \}}
\DoxyCodeLine{411       dump << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{412     \}}
\DoxyCodeLine{413     dump.close();}
\DoxyCodeLine{414   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_ae60b8b7671d83a18cfaaf17a6dd2db87}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!dump\_gnu@{dump\_gnu}}
\index{dump\_gnu@{dump\_gnu}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{dump\_gnu()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \textbf{ D\+\_\+complex} $>$\+::dump\+\_\+gnu (\begin{DoxyParamCaption}\item[{std\+::string}]{filename }\end{DoxyParamCaption}) const}



Definition at line 417 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{417                                                                    \{}
\DoxyCodeLine{418     std::ofstream dump;}
\DoxyCodeLine{419     dump.open(filename.c\_str());}
\DoxyCodeLine{420     dump.precision(15);}
\DoxyCodeLine{421     dump.setf(std::ios::showpoint);}
\DoxyCodeLine{422     dump.setf(std::ios::showpos);}
\DoxyCodeLine{423     dump.setf(std::ios::scientific);}
\DoxyCodeLine{424     \textcolor{comment}{//}}
\DoxyCodeLine{425     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_nx; ++i) \{}
\DoxyCodeLine{426       \textcolor{keywordflow}{for}(std::size\_t j = 0; j < m\_ny; ++j) \{}
\DoxyCodeLine{427         dump << m\_X[ i ] << \textcolor{stringliteral}{" "} << m\_Y[ j ] << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{428         \textcolor{keywordflow}{for}(std::size\_t var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{429           dump << real(m\_vars[(i * m\_ny + j) * m\_nv + var ]) << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{430           dump << imag(m\_vars[(i * m\_ny + j) * m\_nv + var ]) << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{431         \}}
\DoxyCodeLine{432         dump << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{433       \}}
\DoxyCodeLine{434       dump << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{435     \}}
\DoxyCodeLine{436     dump.close();}
\DoxyCodeLine{437   \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Utility\+::imag(), and Cpp\+Noddy\+::\+Utility\+::real().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_ad7cddb90f1b5893dbf882955aba02210}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!dump\_var@{dump\_var}}
\index{dump\_var@{dump\_var}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{dump\_var()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::dump\+\_\+var (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{const unsigned}]{var }\end{DoxyParamCaption}) const}



A simple method for dumping a single variable to a file with no nodal information. 


\begin{DoxyParams}{Parameters}
{\em filename} & The filename to write the data to (will overwrite) \\
\hline
{\em var} & The index of the variable to be dumped to output \\
\hline
\end{DoxyParams}


Definition at line 440 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{440                                                                                    \{}
\DoxyCodeLine{441     std::ofstream dump;}
\DoxyCodeLine{442     dump.open(filename.c\_str());}
\DoxyCodeLine{443     dump.precision(15);}
\DoxyCodeLine{444     dump.setf(std::ios::showpoint);}
\DoxyCodeLine{445     dump.setf(std::ios::showpos);}
\DoxyCodeLine{446     dump.setf(std::ios::scientific);}
\DoxyCodeLine{447     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_nx; ++i) \{}
\DoxyCodeLine{448       \textcolor{keywordflow}{for}(std::size\_t j = 0; j < m\_ny; ++j) \{}
\DoxyCodeLine{449         dump << m\_vars[(i * m\_ny + j) * m\_nv + var ] << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{450       \}}
\DoxyCodeLine{451     \}}
\DoxyCodeLine{452   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_ad17fd12c39c6b47649186f49af27f175}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!get\_interpolated\_vars@{get\_interpolated\_vars}}
\index{get\_interpolated\_vars@{get\_interpolated\_vars}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{get\_interpolated\_vars()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Vector}$<$\+\_\+\+Type$>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::get\+\_\+interpolated\+\_\+vars (\begin{DoxyParamCaption}\item[{const double \&}]{x,  }\item[{const double \&}]{y }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Get a bilinearly interpolated value at a specified point. 


\begin{DoxyParams}{Parameters}
{\em x} & x-\/coordinate in the 2D mesh \\
\hline
{\em y} & y-\/coordinate in the 2D mesh \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector of bilinearly interpolated values 
\end{DoxyReturn}


Definition at line 255 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{255                                                                                \{}
\DoxyCodeLine{256       \textcolor{keyword}{const} \textcolor{keywordtype}{double} tol(1.e-\/10);}
\DoxyCodeLine{257       \textcolor{comment}{// check start and end}}
\DoxyCodeLine{258       \textcolor{keywordflow}{if}((x < m\_X[0] -\/ tol) || (x > m\_X[m\_nx-\/1] + tol)) \{}
\DoxyCodeLine{259         std::string problem;}
\DoxyCodeLine{260         problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.get\_interpolated\_vars method has been called with \(\backslash\)n"};}
\DoxyCodeLine{261         problem += \textcolor{stringliteral}{" an x coordinate that lies outside the mesh. \(\backslash\)n"};}
\DoxyCodeLine{262         \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{263       \}}
\DoxyCodeLine{264       \textcolor{comment}{// check start and end}}
\DoxyCodeLine{265       \textcolor{keywordflow}{if}((y < m\_Y[0] -\/ tol) || (y > m\_Y[m\_ny-\/1] + tol)) \{}
\DoxyCodeLine{266         std::string problem;}
\DoxyCodeLine{267         problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.get\_interpolated\_vars method has been called with \(\backslash\)n"};}
\DoxyCodeLine{268         problem += \textcolor{stringliteral}{" a y coordinate that lies outside the mesh. \(\backslash\)n"};}
\DoxyCodeLine{269         \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{270       \}}
\DoxyCodeLine{271       \textcolor{keywordtype}{int} bottom\_j(-\/1);}
\DoxyCodeLine{272       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j = 0; j < m\_ny-\/1; ++j) \{}
\DoxyCodeLine{273         \textcolor{keywordflow}{if}((y >= m\_Y[j] -\/ tol) \&\& (y <= m\_Y[j+1] + tol)) \{}
\DoxyCodeLine{274           bottom\_j = j;}
\DoxyCodeLine{275         \}}
\DoxyCodeLine{276         \textcolor{comment}{//if ( abs(y-\/Y[j]) < tol )}}
\DoxyCodeLine{277         \textcolor{comment}{//\{}}
\DoxyCodeLine{278         \textcolor{comment}{//bottom\_j = j;}}
\DoxyCodeLine{279         \textcolor{comment}{//\}}}
\DoxyCodeLine{280         \textcolor{comment}{//if ( abs(y-\/m\_Y[j+1]) < tol )}}
\DoxyCodeLine{281         \textcolor{comment}{//\{}}
\DoxyCodeLine{282         \textcolor{comment}{//bottom\_j = j+1;}}
\DoxyCodeLine{283         \textcolor{comment}{//\}}}
\DoxyCodeLine{284       \}}
\DoxyCodeLine{285       \textcolor{comment}{//std::cout << y << " " << m\_Y[bottom\_j] << " " << m\_Y[bottom\_j+1] << "\(\backslash\)n";}}
\DoxyCodeLine{286       \textcolor{keywordflow}{if}(bottom\_j == -\/1) \{}
\DoxyCodeLine{287         std::string problem;}
\DoxyCodeLine{288         problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.get\_interpolated\_vars method is broken.\(\backslash\)n"};}
\DoxyCodeLine{289         \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{290       \}}
\DoxyCodeLine{291       \textcolor{comment}{//}}
\DoxyCodeLine{292       OneD\_Node\_Mesh<\_Type> bottom\_row = get\_xsection\_at\_ynode(bottom\_j);}
\DoxyCodeLine{293       OneD\_Node\_Mesh<\_Type> top\_row = get\_xsection\_at\_ynode(bottom\_j+1);}
\DoxyCodeLine{294       \textcolor{keyword}{const} \textcolor{keywordtype}{double} y1 = m\_Y[ bottom\_j ];}
\DoxyCodeLine{295       \textcolor{keyword}{const} \textcolor{keywordtype}{double} y2 = m\_Y[ bottom\_j+1 ];}
\DoxyCodeLine{296       DenseVector<\_Type> result = top\_row.get\_interpolated\_vars(x)*(y-\/y1)/(y2-\/y1)}
\DoxyCodeLine{297                                   + bottom\_row.get\_interpolated\_vars(x)*(y2-\/y)/(y2-\/y1);}
\DoxyCodeLine{298       \textcolor{comment}{//std::cout << "x,y,interp: " << x << " " << y << " " << result[0] << "\(\backslash\)n";}}
\DoxyCodeLine{299       \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{300     \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+One\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::get\+\_\+interpolated\+\_\+vars(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+xsection\+\_\+at\+\_\+ynode(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+nx, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+ny, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+X, and Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+Y.

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a1152cbed74ef1db0b04053af3603f003}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!get\_nnodes@{get\_nnodes}}
\index{get\_nnodes@{get\_nnodes}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{get\_nnodes()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
std\+::pair$<$ std\+::size\+\_\+t, std\+::size\+\_\+t $>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::get\+\_\+nnodes}



Get the number of nodes in the two directions of the 2D mesh. 

\begin{DoxyReturn}{Returns}
A pair consisting of the number of nodes in the 2 directions 
\end{DoxyReturn}


Definition at line 57 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{57                                                                           \{}
\DoxyCodeLine{58     std::pair< std::size\_t, std::size\_t > nodes;}
\DoxyCodeLine{59     nodes.first = m\_nx;}
\DoxyCodeLine{60     nodes.second = m\_ny;}
\DoxyCodeLine{61     \textcolor{keywordflow}{return} nodes;}
\DoxyCodeLine{62   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+F\+T\+::idft\+\_\+with\+\_\+ishift().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a947ec949381092ca33f0571fdf28fe9f}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!get\_nodes\_vars@{get\_nodes\_vars}}
\index{get\_nodes\_vars@{get\_nodes\_vars}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{get\_nodes\_vars()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::get\+\_\+nodes\+\_\+vars (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{nodex,  }\item[{const std\+::size\+\_\+t}]{nodey }\end{DoxyParamCaption}) const}



Get the variables stored at A S\+P\+E\+C\+I\+F\+I\+ED node -- equivalent to mesh(nodex,nodey). 


\begin{DoxyParams}{Parameters}
{\em nodex} & The x nodal index to be returned \\
\hline
{\em nodey} & The y nodal index to be returned \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The vector of V\+A\+R\+I\+A\+B\+L\+ES stored at this nodal point 
\end{DoxyReturn}


Definition at line 37 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{37                                                                                                              \{}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{39     \textcolor{keywordflow}{if}(nodex > m\_nx -\/ 1 || nodey > m\_ny -\/ 1) \{}
\DoxyCodeLine{40       std::string problem;}
\DoxyCodeLine{41       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.get\_nodes\_vars method is trying to \(\backslash\)n"};}
\DoxyCodeLine{42       problem += \textcolor{stringliteral}{" access a nodal point that is not in the mesh. \(\backslash\)n"};}
\DoxyCodeLine{43       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nx, nodex, m\_ny, nodey);}
\DoxyCodeLine{44     \}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{46     \textcolor{comment}{// construct a vector with m\_nv elements starting from a pointer}}
\DoxyCodeLine{47     DenseVector<\_Type> nodes\_vars(m\_nv, \&m\_vars[(nodex * m\_ny + nodey) * m\_nv ]);}
\DoxyCodeLine{48     \textcolor{keywordflow}{return} nodes\_vars;}
\DoxyCodeLine{49   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a9bf82f38344885b45bfa7049effffa45}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!get\_nvars@{get\_nvars}}
\index{get\_nvars@{get\_nvars}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{get\_nvars()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
std\+::size\+\_\+t \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::get\+\_\+nvars}



Get the number of variables that are stored at each node. 

\begin{DoxyReturn}{Returns}
The number of variables that have data stored at each nodal point 
\end{DoxyReturn}


Definition at line 65 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{65                                                    \{}
\DoxyCodeLine{66     \textcolor{keywordflow}{return} m\_nv;}
\DoxyCodeLine{67   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+F\+T\+::idft\+\_\+with\+\_\+ishift().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a52a1cda886159f32dfa6d17c60f51c8b}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!get\_var\_as\_matrix@{get\_var\_as\_matrix}}
\index{get\_var\_as\_matrix@{get\_var\_as\_matrix}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{get\_var\_as\_matrix()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Matrix}$<$ \+\_\+\+Type $>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::get\+\_\+var\+\_\+as\+\_\+matrix (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{var }\end{DoxyParamCaption}) const}



Return a matrix corresponding to each nodal point in the mesh Each matrix element will contain a specified variable number. 


\begin{DoxyParams}{Parameters}
{\em var} & The variable number to be accessed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A dense matrix of the specified variable 
\end{DoxyReturn}


Definition at line 80 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{80                                                                                  \{}
\DoxyCodeLine{81 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{82     \textcolor{keywordflow}{if}(var > m\_nv -\/ 1) \{}
\DoxyCodeLine{83       std::string problem;}
\DoxyCodeLine{84       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.get\_var\_as\_matrix method is trying to use a \(\backslash\)n"};}
\DoxyCodeLine{85       problem += \textcolor{stringliteral}{" variable index bigger than the number of variables in the mesh. \(\backslash\)n"};}
\DoxyCodeLine{86       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nv, var);}
\DoxyCodeLine{87     \}}
\DoxyCodeLine{88 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{89     DenseMatrix<\_Type> temp(m\_nx, m\_ny, 0.0);}
\DoxyCodeLine{90     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_nx; ++i) \{}
\DoxyCodeLine{91       \textcolor{keywordflow}{for}(std::size\_t j = 0; j < m\_ny; ++j) \{}
\DoxyCodeLine{92         temp(i, j) = m\_vars[(i * m\_ny + j) * m\_nv + var ];}
\DoxyCodeLine{93       \}}
\DoxyCodeLine{94     \}}
\DoxyCodeLine{95     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{96   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a3765c206783bacd659c5a5f023769ab1}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!get\_xsection\_at\_x1@{get\_xsection\_at\_x1}}
\index{get\_xsection\_at\_x1@{get\_xsection\_at\_x1}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{get\_xsection\_at\_x1()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$\+\_\+\+Type$>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::get\+\_\+xsection\+\_\+at\+\_\+x1 (\begin{DoxyParamCaption}\item[{const double}]{x }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get a cross section of the 2D mesh at a specified (constant) x node. 


\begin{DoxyParams}{Parameters}
{\em nodex} & The x nodal index at which the cross section is to be taken \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A 1D nodal mesh 
\end{DoxyReturn}


Definition at line 135 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{135                                                                    \{}
\DoxyCodeLine{136       \textcolor{keywordtype}{unsigned} I(0);}
\DoxyCodeLine{137       OneD\_Node\_Mesh<\_Type> xsection(m\_Y, m\_nv);}
\DoxyCodeLine{138       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i = 0; i<m\_nx-\/1; ++i) \{}
\DoxyCodeLine{139         \textcolor{keywordflow}{if}((m\_X[i]< x) \&\& (m\_X[i+1]>x)) \{}
\DoxyCodeLine{140           I=i;}
\DoxyCodeLine{141         \}}
\DoxyCodeLine{142       \}}
\DoxyCodeLine{143       \textcolor{keywordtype}{double} dx\_ratio((x-\/m\_X[I])/(m\_X[I+1]-\/m\_X[I]));}
\DoxyCodeLine{144       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j = 0; j<m\_ny; ++j) \{}
\DoxyCodeLine{145         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var<m\_nv; ++var) \{}
\DoxyCodeLine{146           xsection(j,var) = this-\/>operator()(I,j,var)+(this-\/>operator()(I+1,j,var)-\/this-\/>operator()(I,j,var))*dx\_ratio;}
\DoxyCodeLine{147         \}}
\DoxyCodeLine{148       \}}
\DoxyCodeLine{149       \textcolor{keywordflow}{return} xsection;}
\DoxyCodeLine{150     \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+nv, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+nx, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+ny, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+X, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+Y, and Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::operator()().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a7d9781b1bc14efd556f8eaf88e5ef33b}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!get\_xsection\_at\_xnode@{get\_xsection\_at\_xnode}}
\index{get\_xsection\_at\_xnode@{get\_xsection\_at\_xnode}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{get\_xsection\_at\_xnode()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::get\+\_\+xsection\+\_\+at\+\_\+xnode (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{nodex }\end{DoxyParamCaption}) const}



Get a cross section of the 2D mesh at a specified (constant) x node. 


\begin{DoxyParams}{Parameters}
{\em nodex} & The x nodal index at which the cross section is to be taken \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A 1D nodal mesh 
\end{DoxyReturn}


Definition at line 299 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{299                                                                                                 \{}
\DoxyCodeLine{300     OneD\_Node\_Mesh<\_Type> xsection(m\_Y, m\_nv);}
\DoxyCodeLine{301     \textcolor{keywordflow}{for}(std::size\_t nodey = 0; nodey < m\_ny; ++nodey) \{}
\DoxyCodeLine{302       xsection.set\_nodes\_vars(nodey, \textcolor{keyword}{this} -\/> get\_nodes\_vars(nodex, nodey));}
\DoxyCodeLine{303     \}}
\DoxyCodeLine{304     \textcolor{keywordflow}{return} xsection;}
\DoxyCodeLine{305   \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+One\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::set\+\_\+nodes\+\_\+vars().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_af236881475ab6dd4103df1d60b0bd0ae}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!get\_xsection\_at\_ynode@{get\_xsection\_at\_ynode}}
\index{get\_xsection\_at\_ynode@{get\_xsection\_at\_ynode}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{get\_xsection\_at\_ynode()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::get\+\_\+xsection\+\_\+at\+\_\+ynode (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{nodey }\end{DoxyParamCaption}) const}



Get a cross section of the 2D mesh at a specified (constant) y node. 


\begin{DoxyParams}{Parameters}
{\em nodey} & The y nodal index at which the cross section is to be taken \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A 1D nodal mesh 
\end{DoxyReturn}


Definition at line 308 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{308                                                                                                 \{}
\DoxyCodeLine{309     OneD\_Node\_Mesh<\_Type> xsection(m\_X, m\_nv);}
\DoxyCodeLine{310     \textcolor{keywordflow}{for}(std::size\_t nodex = 0; nodex < m\_nx; ++nodex) \{}
\DoxyCodeLine{311       xsection.set\_nodes\_vars(nodex, \textcolor{keyword}{this} -\/> get\_nodes\_vars(nodex, nodey));}
\DoxyCodeLine{312     \}}
\DoxyCodeLine{313     \textcolor{keywordflow}{return} xsection;}
\DoxyCodeLine{314   \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+One\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::set\+\_\+nodes\+\_\+vars().



Referenced by Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+interpolated\+\_\+vars(), and Cpp\+Noddy\+::\+F\+T\+::idft\+\_\+with\+\_\+ishift().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_af35a86718a31deaa50236de82b10260d}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!max\_abs@{max\_abs}}
\index{max\_abs@{max\_abs}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{max\_abs()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
double \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::max\+\_\+abs (\begin{DoxyParamCaption}\item[{unsigned}]{var }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Find the maximum stored absolute value in the mesh for a given variable -- no interpolation is used. 


\begin{DoxyParams}{Parameters}
{\em var} & The variable index whose maximum is being asked for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of the maximum (abs value) 
\end{DoxyReturn}


Definition at line 237 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{237                                  \{}
\DoxyCodeLine{238       \textcolor{keywordtype}{double} max(0.0);}
\DoxyCodeLine{239       \textcolor{comment}{// step through the nodes}}
\DoxyCodeLine{240       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} nodex = 0; nodex < m\_X.size(); ++nodex) \{}
\DoxyCodeLine{241         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} nodey = 0; nodey < m\_Y.size(); ++nodey) \{}
\DoxyCodeLine{242           \textcolor{keywordflow}{if}(std::abs(m\_vars[(nodex * m\_ny + nodey) * m\_nv + var ]) > max) \{}
\DoxyCodeLine{243             max = std::abs(m\_vars[(nodex * m\_ny + nodey) * m\_nv + var ]);}
\DoxyCodeLine{244           \}}
\DoxyCodeLine{245         \}}
\DoxyCodeLine{246       \}}
\DoxyCodeLine{247       \textcolor{keywordflow}{return} max;}
\DoxyCodeLine{248     \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+nv, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+ny, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+vars, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+X, Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+Y, and Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::size().



Referenced by main().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a89c95c429db4245e5c2bb5ec8e1d8f10}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!max\_abs\_real\_part@{max\_abs\_real\_part}}
\index{max\_abs\_real\_part@{max\_abs\_real\_part}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{max\_abs\_real\_part()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
double \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::max\+\_\+abs\+\_\+real\+\_\+part (\begin{DoxyParamCaption}\item[{unsigned}]{var }\end{DoxyParamCaption})}



Find the maximum stored absolute value in the mesh for a given variable -- no interpolation is used. 


\begin{DoxyParams}{Parameters}
{\em var} & The variable index whose maximum is being asked for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of the maximum (abs value) 
\end{DoxyReturn}


Referenced by Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::normalise\+\_\+real\+\_\+part().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a53a420bc4f11e48dbf7a1a29c0b60aa1}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!max\_abs\_real\_part@{max\_abs\_real\_part}}
\index{max\_abs\_real\_part@{max\_abs\_real\_part}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{max\_abs\_real\_part()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily double \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \textbf{ D\+\_\+complex} $>$\+::max\+\_\+abs\+\_\+real\+\_\+part (\begin{DoxyParamCaption}\item[{unsigned}]{var }\end{DoxyParamCaption})}



Definition at line 368 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{368                                                                   \{}
\DoxyCodeLine{369     \textcolor{keywordtype}{double} max(0.0);}
\DoxyCodeLine{370     \textcolor{comment}{// step through the nodes}}
\DoxyCodeLine{371     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} nodex = 0; nodex < m\_X.size(); ++nodex) \{}
\DoxyCodeLine{372       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} nodey = 0; nodey < m\_Y.size(); ++nodey) \{}
\DoxyCodeLine{373         \textcolor{keywordflow}{if}(std::abs(m\_vars[(nodex * m\_ny + nodey) * m\_nv + var ].real()) > max) \{}
\DoxyCodeLine{374           max = std::abs(m\_vars[(nodex * m\_ny + nodey) * m\_nv + var ].real());}
\DoxyCodeLine{375         \}}
\DoxyCodeLine{376       \}}
\DoxyCodeLine{377     \}}
\DoxyCodeLine{378     \textcolor{keywordflow}{return} max;}
\DoxyCodeLine{379   \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Utility\+::real().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_aade230f956c96268a60a9c0817d37261}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!max\_abs\_real\_part@{max\_abs\_real\_part}}
\index{max\_abs\_real\_part@{max\_abs\_real\_part}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{max\_abs\_real\_part()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily double \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ double $>$\+::max\+\_\+abs\+\_\+real\+\_\+part (\begin{DoxyParamCaption}\item[{unsigned}]{var }\end{DoxyParamCaption})}



Definition at line 382 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{382                                                                \{}
\DoxyCodeLine{383 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{384     \textcolor{comment}{// check start \& end}}
\DoxyCodeLine{385     std::string problem;}
\DoxyCodeLine{386     problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.max\_abs\_real\_part method has been called for \(\backslash\)n"};}
\DoxyCodeLine{387     problem += \textcolor{stringliteral}{" a mesh with element type of double (rather than D\_complex)."};}
\DoxyCodeLine{388     \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{389 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{390     \textcolor{comment}{// just call the max\_abs}}
\DoxyCodeLine{391     \textcolor{keywordflow}{return} max\_abs(var);}
\DoxyCodeLine{392   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a91a57e0341c533b54a8188b4bfd2185d}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!normalise@{normalise}}
\index{normalise@{normalise}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{normalise()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::normalise (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{var }\end{DoxyParamCaption})}



Normalise all data in the mesh based on one variable. 


\begin{DoxyParams}{Parameters}
{\em var} & This var will have its peak (absolute) value as +/-\/unity following the normalisation. All other variables will also be rescaled by the same amount. \\
\hline
\end{DoxyParams}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a438d74fe000dba17955c6ef151d728a4}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!normalise@{normalise}}
\index{normalise@{normalise}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{normalise()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ double $>$\+::normalise (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{var }\end{DoxyParamCaption})}



Definition at line 339 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{339                                                              \{}
\DoxyCodeLine{340     \textcolor{keywordtype}{double} maxval(max\_abs(var));}
\DoxyCodeLine{341     m\_vars.scale(1./maxval);}
\DoxyCodeLine{342   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a21f51f746f95e67dc09c0ff4e07eeeeb}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!normalise@{normalise}}
\index{normalise@{normalise}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{normalise()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \textbf{ D\+\_\+complex} $>$\+::normalise (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{var }\end{DoxyParamCaption})}



Definition at line 345 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{345                                                                 \{}
\DoxyCodeLine{346     \textcolor{comment}{//std::cout << "[DEBUG] asked to normalise a complex mesh\(\backslash\)n";}}
\DoxyCodeLine{347     \textcolor{keywordtype}{unsigned} max\_nx(0);}
\DoxyCodeLine{348     \textcolor{keywordtype}{unsigned} max\_ny(0);}
\DoxyCodeLine{349     \textcolor{keywordtype}{double} max(0.0);}
\DoxyCodeLine{350     \textcolor{comment}{// step through the nodes}}
\DoxyCodeLine{351     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} nodex = 0; nodex < m\_X.size(); ++nodex) \{}
\DoxyCodeLine{352       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} nodey = 0; nodey < m\_Y.size(); ++nodey) \{}
\DoxyCodeLine{353         \textcolor{keywordflow}{if}(std::abs(m\_vars[(nodex * m\_ny + nodey) * m\_nv + var ]) > max) \{}
\DoxyCodeLine{354           max = std::abs(m\_vars[(nodex * m\_ny + nodey) * m\_nv + var ]);}
\DoxyCodeLine{355           max\_nx = nodex;}
\DoxyCodeLine{356           max\_ny = nodey;}
\DoxyCodeLine{357         \}}
\DoxyCodeLine{358       \}}
\DoxyCodeLine{359     \}}
\DoxyCodeLine{360     D\_complex factor(m\_vars[(max\_nx * m\_ny + max\_ny) * m\_nv + var ]);}
\DoxyCodeLine{361     \textcolor{comment}{//std::cout << "[DEBUG] MAX |variable| had complex value of " << factor << "\(\backslash\)n";}}
\DoxyCodeLine{362     m\_vars.scale(1./factor);}
\DoxyCodeLine{363   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a59975db6313ecd5802c648f61af3350d}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!normalise\_real\_part@{normalise\_real\_part}}
\index{normalise\_real\_part@{normalise\_real\_part}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{normalise\_real\_part()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::normalise\+\_\+real\+\_\+part (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t \&}]{var }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Normalise the mesh such that the real part of variable \textquotesingle{}var\textquotesingle{} has a real part of unity, and is then the largest real part across the whole mesh. 


\begin{DoxyParams}{Parameters}
{\em var} & The variable to be normalised \\
\hline
\end{DoxyParams}


Definition at line 224 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{224                                                    \{}
\DoxyCodeLine{225       \textcolor{keywordtype}{double} maxval(max\_abs\_real\_part(var));}
\DoxyCodeLine{226       m\_vars.scale(1./maxval);}
\DoxyCodeLine{227     \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+vars, and Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::max\+\_\+abs\+\_\+real\+\_\+part().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a5a20d46ce6da565f336b2bdbb22cd40e}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!operator()@{operator()}}
\index{operator()@{operator()}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{operator()()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::operator() (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{nodex,  }\item[{const std\+::size\+\_\+t}]{nodey }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access operator for a nodal point that returns a vector. 


\begin{DoxyParams}{Parameters}
{\em nodex} & The nodal index value in the first direction \\
\hline
{\em nodey} & The nodal index value in the second direction \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The vector of variables stored at the node 
\end{DoxyReturn}


Definition at line 317 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{317                                                                                                            \{}
\DoxyCodeLine{318 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{319     \textcolor{keywordflow}{if}(nodex > m\_nx -\/ 1 || nodey > m\_ny -\/ 1) \{}
\DoxyCodeLine{320       std::string problem;}
\DoxyCodeLine{321       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.operator() method is trying to \(\backslash\)n"};}
\DoxyCodeLine{322       problem += \textcolor{stringliteral}{" access a nodal point that is not in the mesh. \(\backslash\)n"};}
\DoxyCodeLine{323       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nx, nodex, m\_ny, nodey);}
\DoxyCodeLine{324     \}}
\DoxyCodeLine{325 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{326     \textcolor{keywordflow}{return} get\_nodes\_vars(nodex, nodey);}
\DoxyCodeLine{327   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+xsection\+\_\+at\+\_\+x1().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_aadfbe6795cb7d486740a852f33b5b704}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!operator()@{operator()}}
\index{operator()@{operator()}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{operator()()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\+\_\+\+Type \& \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::operator() (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{nodex,  }\item[{const std\+::size\+\_\+t}]{nodey,  }\item[{const std\+::size\+\_\+t}]{var }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access operator for a nodal point/variable in the mesh. 


\begin{DoxyParams}{Parameters}
{\em nodex} & The nodal index value in the first direction \\
\hline
{\em nodey} & The nodal index value in the second direction \\
\hline
{\em var} & The variable index to be accessed \\
\hline
\end{DoxyParams}


Definition at line 331 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{331                                                                                                                    \{}
\DoxyCodeLine{332 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{333     \textcolor{keywordflow}{if}(nodex > m\_nx -\/ 1 || nodey > m\_ny -\/ 1) \{}
\DoxyCodeLine{334       std::string problem;}
\DoxyCodeLine{335       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.operator() method is trying to \(\backslash\)n"};}
\DoxyCodeLine{336       problem += \textcolor{stringliteral}{" access a nodal point that is not in the mesh. \(\backslash\)n"};}
\DoxyCodeLine{337       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nx, nodex, m\_ny, nodey);}
\DoxyCodeLine{338     \}}
\DoxyCodeLine{339     \textcolor{keywordflow}{if}(var > m\_nv -\/ 1) \{}
\DoxyCodeLine{340       std::string problem;}
\DoxyCodeLine{341       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.operator() method is trying to \(\backslash\)n"};}
\DoxyCodeLine{342       problem += \textcolor{stringliteral}{" access a variable index that is not in the mesh. \(\backslash\)n"};}
\DoxyCodeLine{343       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nv, var);}
\DoxyCodeLine{344     \}}
\DoxyCodeLine{345 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{346     \textcolor{keywordflow}{return} m\_vars[(nodex * m\_ny + nodey) * m\_nv + var ];}
\DoxyCodeLine{347   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a68a2f72e539be1d8347799569116c00e}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!operator()@{operator()}}
\index{operator()@{operator()}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{operator()()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
const \+\_\+\+Type \& \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::operator() (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{nodex,  }\item[{const std\+::size\+\_\+t}]{nodey,  }\item[{const std\+::size\+\_\+t}]{var }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Const access operator for a nodal point/variable in the mesh. 


\begin{DoxyParams}{Parameters}
{\em nodex} & The nodal index value in the first direction \\
\hline
{\em nodey} & The nodal index value in the second direction \\
\hline
{\em var} & The variable index to be accessed \\
\hline
\end{DoxyParams}


Definition at line 350 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{350                                                                                                                                \{}
\DoxyCodeLine{351 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{352     \textcolor{keywordflow}{if}(nodex > m\_nx -\/ 1 || nodey > m\_ny -\/ 1) \{}
\DoxyCodeLine{353       std::string problem;}
\DoxyCodeLine{354       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.operator() method is trying to \(\backslash\)n"};}
\DoxyCodeLine{355       problem += \textcolor{stringliteral}{" access a nodal point that is not in the mesh. \(\backslash\)n"};}
\DoxyCodeLine{356       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nx, nodex, m\_ny, nodey);}
\DoxyCodeLine{357     \}}
\DoxyCodeLine{358     \textcolor{keywordflow}{if}(var > m\_nv -\/ 1) \{}
\DoxyCodeLine{359       std::string problem;}
\DoxyCodeLine{360       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.operator() method is trying to \(\backslash\)n"};}
\DoxyCodeLine{361       problem += \textcolor{stringliteral}{" access a variable index that is not in the mesh. \(\backslash\)n"};}
\DoxyCodeLine{362       \textcolor{keywordflow}{throw} ExceptionRange(problem, m\_nv, var);}
\DoxyCodeLine{363     \}}
\DoxyCodeLine{364 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{365     \textcolor{keywordflow}{return} m\_vars[(nodex * m\_ny + nodey) * m\_nv + var ];}
\DoxyCodeLine{366   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a9db98f144f56466857e1624b212aeec2}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!read@{read}}
\index{read@{read}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{read()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ double $>$\+::read (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{bool}]{reset }\end{DoxyParamCaption})}



Definition at line 476 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{476                                                                   \{}
\DoxyCodeLine{477     std::ifstream dump;}
\DoxyCodeLine{478     dump.open(filename.c\_str());}
\DoxyCodeLine{479     \textcolor{keywordflow}{if}(dump.good() != \textcolor{keyword}{true}) \{}
\DoxyCodeLine{480       std::string problem;}
\DoxyCodeLine{481       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.read method is trying to read a \(\backslash\)n"};}
\DoxyCodeLine{482       problem += \textcolor{stringliteral}{" file ("} + filename + \textcolor{stringliteral}{") that doesn't exist.\(\backslash\)n"};}
\DoxyCodeLine{483       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{484     \}}
\DoxyCodeLine{485     dump.precision(15);}
\DoxyCodeLine{486     dump.setf(std::ios::showpoint);}
\DoxyCodeLine{487     dump.setf(std::ios::showpos);}
\DoxyCodeLine{488     dump.setf(std::ios::scientific);}
\DoxyCodeLine{489     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_nx; ++i) \{}
\DoxyCodeLine{490       \textcolor{keywordflow}{for}(std::size\_t j = 0; j < m\_ny; ++j) \{}
\DoxyCodeLine{491         \textcolor{keywordtype}{double} x, y;}
\DoxyCodeLine{492         dump >> x;}
\DoxyCodeLine{493         dump >> y;}
\DoxyCodeLine{494         \textcolor{keywordflow}{for}(std::size\_t var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{495           \textcolor{keywordtype}{double} value;}
\DoxyCodeLine{496           dump >> value;}
\DoxyCodeLine{497           m\_vars[(i * m\_ny + j) * m\_nv + var ] = value;}
\DoxyCodeLine{498         \}}
\DoxyCodeLine{499         \textcolor{keywordflow}{if}(reset != \textcolor{keyword}{true}) \{}
\DoxyCodeLine{500           \textcolor{comment}{// if not reseting the mesh we should check the node positions}}
\DoxyCodeLine{501           \textcolor{keywordflow}{if}((std::fabs(x -\/ m\_X[ i ]) > 1.e-\/6) || (std::fabs(y -\/ m\_Y[ j ]) > 1.e-\/6)) \{}
\DoxyCodeLine{502             std::cout << \textcolor{stringliteral}{" Read x = "} << x << \textcolor{stringliteral}{" Expected x = "} << m\_X[ i ] << \textcolor{stringliteral}{"; Read y = "} << y << \textcolor{stringliteral}{" Expected y = "} << m\_Y[ j ] << \textcolor{stringliteral}{" \(\backslash\)n"};}
\DoxyCodeLine{503             std::cout << \textcolor{stringliteral}{" Absolute differences are "} << fabs(x -\/ m\_X[i]) << \textcolor{stringliteral}{" and "} << fabs(y -\/ m\_Y[j]) << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{504             std::string problem;}
\DoxyCodeLine{505             problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.read method is trying to read a \(\backslash\)n"};}
\DoxyCodeLine{506             problem += \textcolor{stringliteral}{" file whose nodal points are in a different position. \(\backslash\)n"};}
\DoxyCodeLine{507             \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{508           \}}
\DoxyCodeLine{509         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{510           m\_X[ i ] = x;}
\DoxyCodeLine{511           m\_Y[ j ] = y;}
\DoxyCodeLine{512         \}}
\DoxyCodeLine{513       \}}
\DoxyCodeLine{514     \}}
\DoxyCodeLine{515   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a6a88c0e4c4d60efbcf76d3f93989afc4}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!read@{read}}
\index{read@{read}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{read()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \textbf{ D\+\_\+complex} $>$\+::read (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{bool}]{reset }\end{DoxyParamCaption})}



Definition at line 519 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{519                                                                      \{}
\DoxyCodeLine{520     std::ifstream dump;}
\DoxyCodeLine{521     dump.open(filename.c\_str());}
\DoxyCodeLine{522     dump.precision(15);}
\DoxyCodeLine{523     dump.setf(std::ios::showpoint);}
\DoxyCodeLine{524     dump.setf(std::ios::showpos);}
\DoxyCodeLine{525     dump.setf(std::ios::scientific);}
\DoxyCodeLine{526     \textcolor{comment}{//}}
\DoxyCodeLine{527     \textcolor{comment}{// 18/06/2017: switched i and j below for consistency with double}}
\DoxyCodeLine{528     \textcolor{comment}{//}}
\DoxyCodeLine{529     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_nx; ++i) \{}
\DoxyCodeLine{530       \textcolor{keywordflow}{for}(std::size\_t j = 0; j < m\_ny; ++j) \{}
\DoxyCodeLine{531         \textcolor{keywordtype}{double} x, y;}
\DoxyCodeLine{532         dump >> x;}
\DoxyCodeLine{533         dump >> y;}
\DoxyCodeLine{534         \textcolor{keywordflow}{for}(std::size\_t var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{535           \textcolor{keywordtype}{double} value\_r, value\_i;}
\DoxyCodeLine{536           dump >> value\_r;}
\DoxyCodeLine{537           dump >> value\_i;}
\DoxyCodeLine{538           m\_vars[(i * m\_ny + j) * m\_nv + var ] = D\_complex(value\_r, value\_i);}
\DoxyCodeLine{539         \}}
\DoxyCodeLine{540         \textcolor{keywordflow}{if}(reset != \textcolor{keyword}{true}) \{}
\DoxyCodeLine{541           \textcolor{comment}{// if not reseting the mesh we should check the node positions}}
\DoxyCodeLine{542           \textcolor{keywordflow}{if}((std::fabs(x -\/ m\_X[ i ]) > 1.e-\/6) || (std::fabs(y -\/ m\_Y[ j ]) > 1.e-\/6)) \{}
\DoxyCodeLine{543             std::cout << \textcolor{stringliteral}{" Read x = "} << x << \textcolor{stringliteral}{" Expected x = "} << m\_X[ i ] << \textcolor{stringliteral}{"; Read y = "} << y << \textcolor{stringliteral}{" Expected y = "} << m\_Y[ j ] << \textcolor{stringliteral}{" \(\backslash\)n"};}
\DoxyCodeLine{544             std::cout << \textcolor{stringliteral}{" Absolute differences are "} << fabs(x -\/ m\_X[i]) << \textcolor{stringliteral}{" and "} << fabs(y -\/ m\_Y[j]) << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{545             std::string problem;}
\DoxyCodeLine{546             problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.read method is trying to read a \(\backslash\)n"};}
\DoxyCodeLine{547             problem += \textcolor{stringliteral}{" file whose nodal points are in a different position. \(\backslash\)n"};}
\DoxyCodeLine{548             \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{549           \}}
\DoxyCodeLine{550         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{551           m\_X[ i ] = x;}
\DoxyCodeLine{552           m\_Y[ j ] = y;}
\DoxyCodeLine{553         \}}
\DoxyCodeLine{554       \}}
\DoxyCodeLine{555     \}}
\DoxyCodeLine{556   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a8aabd8793f5c6cbe7cbe91aaf76588c7}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!read@{read}}
\index{read@{read}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{read()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::read (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{const bool}]{reset = {\ttfamily false} }\end{DoxyParamCaption})}



A simple method for reading data from a file. 


\begin{DoxyParams}{Parameters}
{\em filename} & The filename to write the data to (will overwrite) \\
\hline
{\em reset} & Will reset the nodal positions using those from the file \\
\hline
\end{DoxyParams}


Referenced by Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_ac927976c26dfbe35da3cd741ecd3a36a}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!remesh1@{remesh1}}
\index{remesh1@{remesh1}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{remesh1()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::remesh1 (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{newX,  }\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{newY }\end{DoxyParamCaption})}



Interpolate this mesh data (bilinearly) into a new mesh with nodal points defined in the argument list. 

Not written to be efficient, so you probably don\textquotesingle{}t want to do any repeated calls with this method. 
\begin{DoxyParams}{Parameters}
{\em newX} & The x-\/nodal coordinates to be used in the new mesh. \\
\hline
{\em newY} & The y-\/nodal coordinates to be used in the new mesh. \\
\hline
\end{DoxyParams}


Definition at line 99 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{99                                                                                                       \{}
\DoxyCodeLine{100 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{101     \textcolor{comment}{// check start \& end}}
\DoxyCodeLine{102     \textcolor{keywordflow}{if}(std::abs(m\_X[ 0 ] -\/ newX[ 0 ]) > 1.e-\/10 ||}
\DoxyCodeLine{103         std::abs(m\_X[ m\_X.size() -\/ 1 ] -\/ newX[ newX.size() -\/ 1 ]) > 1.e-\/10) \{}
\DoxyCodeLine{104       std::string problem;}
\DoxyCodeLine{105       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.remesh1 method has been called with \(\backslash\)n"};}
\DoxyCodeLine{106       problem += \textcolor{stringliteral}{" a passed X coordinate vector that has different start and/or \(\backslash\)n"};}
\DoxyCodeLine{107       problem += \textcolor{stringliteral}{" end points from the instantiated object. \(\backslash\)n"};}
\DoxyCodeLine{108       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{109     \}}
\DoxyCodeLine{110     \textcolor{comment}{// check monotonic node positions}}
\DoxyCodeLine{111     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < newX.size() -\/ 1; ++i) \{}
\DoxyCodeLine{112       \textcolor{keywordflow}{if}(newX[ i ] >= newX[ i + 1 ]) \{}
\DoxyCodeLine{113         std::string problem;}
\DoxyCodeLine{114         problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.remesh1 method has been passed \(\backslash\)n"};}
\DoxyCodeLine{115         problem += \textcolor{stringliteral}{" a non-\/monotonic X coordinate vector. \(\backslash\)n"};}
\DoxyCodeLine{116         problem += Utility::stringify(newX[ i ], 6) + \textcolor{stringliteral}{" vs. "} + Utility::stringify(newX[ i + 1 ], 6);}
\DoxyCodeLine{117         \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{118       \}}
\DoxyCodeLine{119     \}}
\DoxyCodeLine{120     \textcolor{comment}{// check start and end}}
\DoxyCodeLine{121     \textcolor{keywordflow}{if}(std::abs(m\_Y[ 0 ] -\/ newY[ 0 ]) > 1.e-\/10 ||}
\DoxyCodeLine{122         std::abs(m\_Y[ m\_Y.size() -\/ 1 ] -\/ newY[ newY.size() -\/ 1 ]) > 1.e-\/10) \{}
\DoxyCodeLine{123       std::string problem;}
\DoxyCodeLine{124       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.remesh1 method has been called with \(\backslash\)n"};}
\DoxyCodeLine{125       problem += \textcolor{stringliteral}{" a passed Y coordinate vector that has different start and/or \(\backslash\)n"};}
\DoxyCodeLine{126       problem += \textcolor{stringliteral}{" end points from the instantiated object. \(\backslash\)n"};}
\DoxyCodeLine{127       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{128     \}}
\DoxyCodeLine{129     \textcolor{comment}{// check monotonic node positions}}
\DoxyCodeLine{130     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < newY.size() -\/ 1; ++i) \{}
\DoxyCodeLine{131       \textcolor{keywordflow}{if}(newY[ i ] >= newY[ i + 1 ]) \{}
\DoxyCodeLine{132         std::string problem;}
\DoxyCodeLine{133         problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.remesh1 method has been passed \(\backslash\)n"};}
\DoxyCodeLine{134         problem += \textcolor{stringliteral}{" a non-\/monotonic Y coordinate vector. \(\backslash\)n"};}
\DoxyCodeLine{135         problem += Utility::stringify(newY[ i ], 6) + \textcolor{stringliteral}{" vs. "} + Utility::stringify(newY[ i + 1 ], 6);}
\DoxyCodeLine{136         \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{137       \}}
\DoxyCodeLine{138     \}}
\DoxyCodeLine{139 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{140 }
\DoxyCodeLine{141     \textcolor{comment}{// new variables storage}}
\DoxyCodeLine{142     DenseVector<\_Type> newvars(newX.size() * newY.size() * m\_nv, 0.0);}
\DoxyCodeLine{143 }
\DoxyCodeLine{144     \textcolor{comment}{// left boundary}}
\DoxyCodeLine{145     \{}
\DoxyCodeLine{146       std::size\_t xnode(0);}
\DoxyCodeLine{147       \textcolor{comment}{// bottom left corner copy}}
\DoxyCodeLine{148       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{149         newvars[(xnode * newY.size() + 0) * m\_nv + var ] = get\_nodes\_vars(0, 0)[ var ];}
\DoxyCodeLine{150       \}}
\DoxyCodeLine{151       \textcolor{keywordflow}{for}(std::size\_t ynode = 1; ynode < newY.size() -\/ 1; ++ynode) \{}
\DoxyCodeLine{152         std::size\_t left\_i(0);    \textcolor{comment}{// bracketing index}}
\DoxyCodeLine{153         std::size\_t below\_j(0);   \textcolor{comment}{// bracketing index}}
\DoxyCodeLine{154         \textcolor{keywordtype}{double} deltaY(0.0);}
\DoxyCodeLine{155         \textcolor{comment}{// loop through the source mesh and find the bracket-\/nodes}}
\DoxyCodeLine{156         \textcolor{keywordflow}{for}(std::size\_t j = 0; j < m\_Y.size() -\/ 1; ++j) \{}
\DoxyCodeLine{157           \textcolor{keywordflow}{if}((m\_Y[ j ] <= newY[ ynode ]) \&\& (newY[ ynode ] < m\_Y[ j + 1 ])) \{}
\DoxyCodeLine{158             below\_j = j;}
\DoxyCodeLine{159             deltaY = newY[ ynode ] -\/ m\_Y[ j ];}
\DoxyCodeLine{160           \}}
\DoxyCodeLine{161         \}}
\DoxyCodeLine{162         DenseVector<\_Type> dvarsdY = (get\_nodes\_vars(left\_i, below\_j + 1) -\/ get\_nodes\_vars(left\_i, below\_j))}
\DoxyCodeLine{163                                      / (coord(left\_i, below\_j + 1).second -\/ coord(left\_i, below\_j).second);}
\DoxyCodeLine{164         DenseVector<\_Type> interpolated\_vars = get\_nodes\_vars(left\_i, below\_j) + dvarsdY * deltaY;}
\DoxyCodeLine{165         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{166           newvars[(xnode * newY.size() + ynode) * m\_nv + var ] = interpolated\_vars[ var ];}
\DoxyCodeLine{167         \}}
\DoxyCodeLine{168       \}}
\DoxyCodeLine{169       \textcolor{comment}{// top left corner copy}}
\DoxyCodeLine{170       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{171         newvars[(xnode * newY.size() + newY.size() -\/ 1) * m\_nv + var ] = get\_nodes\_vars(0, m\_ny -\/ 1)[ var ];}
\DoxyCodeLine{172       \}}
\DoxyCodeLine{173     \}}
\DoxyCodeLine{174     \textcolor{comment}{// right boundary}}
\DoxyCodeLine{175     \{}
\DoxyCodeLine{176       std::size\_t xnode(newX.size() -\/ 1);}
\DoxyCodeLine{177       \textcolor{comment}{// bottom right corner copy}}
\DoxyCodeLine{178       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{179         newvars[(xnode * newY.size() + 0) * m\_nv + var ] = get\_nodes\_vars(m\_nx -\/ 1, 0)[ var ];}
\DoxyCodeLine{180       \}}
\DoxyCodeLine{181       \textcolor{keywordflow}{for}(std::size\_t ynode = 1; ynode < newY.size() -\/ 1; ++ynode) \{}
\DoxyCodeLine{182         std::size\_t left\_i(m\_X.size() -\/ 1);    \textcolor{comment}{// bracketing index}}
\DoxyCodeLine{183         std::size\_t below\_j(0);   \textcolor{comment}{// bracketing index}}
\DoxyCodeLine{184         \textcolor{keywordtype}{double} deltaY(0.0);}
\DoxyCodeLine{185         \textcolor{comment}{// loop through the source mesh and find the bracket-\/nodes}}
\DoxyCodeLine{186         \textcolor{keywordflow}{for}(std::size\_t j = 0; j < m\_Y.size() -\/ 1; ++j) \{}
\DoxyCodeLine{187           \textcolor{keywordflow}{if}((m\_Y[ j ] <= newY[ ynode ]) \&\& (newY[ ynode ] < m\_Y[ j + 1 ])) \{}
\DoxyCodeLine{188             below\_j = j;}
\DoxyCodeLine{189             deltaY = newY[ ynode ] -\/ m\_Y[ j ];}
\DoxyCodeLine{190           \}}
\DoxyCodeLine{191         \}}
\DoxyCodeLine{192         DenseVector<\_Type> dvarsdY = (get\_nodes\_vars(left\_i, below\_j + 1) -\/ get\_nodes\_vars(left\_i, below\_j))}
\DoxyCodeLine{193                                      / (coord(left\_i, below\_j + 1).second -\/ coord(left\_i, below\_j).second);}
\DoxyCodeLine{194         DenseVector<\_Type> interpolated\_vars = get\_nodes\_vars(left\_i, below\_j) + dvarsdY * deltaY;}
\DoxyCodeLine{195         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{196           newvars[(xnode * newY.size() + ynode) * m\_nv + var ] = interpolated\_vars[ var ];}
\DoxyCodeLine{197         \}}
\DoxyCodeLine{198       \}}
\DoxyCodeLine{199       \textcolor{comment}{// bottom right corner copy}}
\DoxyCodeLine{200       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{201         newvars[(xnode * newY.size() + newY.size() -\/ 1) * m\_nv + var ] = get\_nodes\_vars(m\_nx -\/ 1, m\_ny -\/ 1)[ var ];}
\DoxyCodeLine{202       \}}
\DoxyCodeLine{203     \}}
\DoxyCodeLine{204     \textcolor{comment}{// bottom boundary}}
\DoxyCodeLine{205     \{}
\DoxyCodeLine{206       std::size\_t ynode(0);}
\DoxyCodeLine{207       \textcolor{keywordflow}{for}(std::size\_t xnode = 1; xnode < newX.size() -\/ 1; ++xnode) \{}
\DoxyCodeLine{208         std::size\_t left\_i(0);    \textcolor{comment}{// bracketing index}}
\DoxyCodeLine{209         std::size\_t below\_j(0);   \textcolor{comment}{// bracketing index}}
\DoxyCodeLine{210         \textcolor{keywordtype}{double} deltaX(0.0);}
\DoxyCodeLine{211         \textcolor{comment}{// loop through the source mesh and find the bracket-\/nodes}}
\DoxyCodeLine{212         \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_X.size() -\/ 1; ++i) \{}
\DoxyCodeLine{213           \textcolor{keywordflow}{if}((m\_X[ i ] <= newX[ xnode ]) \&\& (newX[ xnode ] < m\_X[ i + 1 ])) \{}
\DoxyCodeLine{214             left\_i = i;}
\DoxyCodeLine{215             deltaX = newX[ xnode ] -\/ m\_X[ i ];}
\DoxyCodeLine{216           \}}
\DoxyCodeLine{217         \}}
\DoxyCodeLine{218         DenseVector<\_Type> dvarsdX = (get\_nodes\_vars(left\_i + 1, below\_j) -\/ get\_nodes\_vars(left\_i, below\_j))}
\DoxyCodeLine{219                                      / (coord(left\_i + 1, below\_j).first -\/ coord(left\_i, below\_j).first);}
\DoxyCodeLine{220         DenseVector<\_Type> interpolated\_vars = get\_nodes\_vars(left\_i, below\_j) + dvarsdX * deltaX;}
\DoxyCodeLine{221         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{222           newvars[(xnode * newY.size() + ynode) * m\_nv + var ] = interpolated\_vars[ var ];}
\DoxyCodeLine{223         \}}
\DoxyCodeLine{224       \}}
\DoxyCodeLine{225     \}}
\DoxyCodeLine{226     \textcolor{comment}{// top boundary}}
\DoxyCodeLine{227     \{}
\DoxyCodeLine{228       std::size\_t ynode(newY.size() -\/ 1);}
\DoxyCodeLine{229       \textcolor{keywordflow}{for}(std::size\_t xnode = 1; xnode < newX.size() -\/ 1; ++xnode) \{}
\DoxyCodeLine{230         std::size\_t left\_i(0);    \textcolor{comment}{// bracketing index}}
\DoxyCodeLine{231         std::size\_t below\_j(m\_Y.size() -\/ 1);   \textcolor{comment}{// bracketing index}}
\DoxyCodeLine{232         \textcolor{keywordtype}{double} deltaX(0.0);}
\DoxyCodeLine{233         \textcolor{comment}{// loop through the source mesh and find the bracket-\/nodes}}
\DoxyCodeLine{234         \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_X.size() -\/ 1; ++i) \{}
\DoxyCodeLine{235           \textcolor{keywordflow}{if}((m\_X[ i ] <= newX[ xnode ]) \&\& (newX[ xnode ] < m\_X[ i + 1 ])) \{}
\DoxyCodeLine{236             left\_i = i;}
\DoxyCodeLine{237             deltaX = newX[ xnode ] -\/ m\_X[ i ];}
\DoxyCodeLine{238           \}}
\DoxyCodeLine{239         \}}
\DoxyCodeLine{240         DenseVector<\_Type> dvarsdX = (get\_nodes\_vars(left\_i + 1, below\_j) -\/ get\_nodes\_vars(left\_i, below\_j))}
\DoxyCodeLine{241                                      / (coord(left\_i + 1, below\_j).first -\/ coord(left\_i, below\_j).first);}
\DoxyCodeLine{242         DenseVector<\_Type> interpolated\_vars = get\_nodes\_vars(left\_i, below\_j) + dvarsdX * deltaX;}
\DoxyCodeLine{243         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{244           newvars[(xnode * newY.size() + ynode) * m\_nv + var ] = interpolated\_vars[ var ];}
\DoxyCodeLine{245         \}}
\DoxyCodeLine{246       \}}
\DoxyCodeLine{247     \}}
\DoxyCodeLine{248     \textcolor{comment}{// loop thru interior nodes of the destination mesh one node at a time}}
\DoxyCodeLine{249     \textcolor{keywordflow}{for}(std::size\_t xnode = 1; xnode < newX.size() -\/ 1; ++xnode) \{}
\DoxyCodeLine{250       \textcolor{keywordflow}{for}(std::size\_t ynode = 1; ynode < newY.size() -\/ 1; ++ynode) \{}
\DoxyCodeLine{251         std::size\_t left\_i(0);    \textcolor{comment}{// bracketing index}}
\DoxyCodeLine{252         std::size\_t below\_j(0);   \textcolor{comment}{// bracketing index}}
\DoxyCodeLine{253         \textcolor{comment}{// loop through the source mesh and find the bracket-\/nodes}}
\DoxyCodeLine{254         \textcolor{keywordflow}{for}(std::size\_t i = 0; i < m\_X.size() -\/ 1; ++i) \{}
\DoxyCodeLine{255           \textcolor{keywordflow}{if}((m\_X[ i ] <= newX[ xnode ]) \&\& (newX[ xnode ] < m\_X[ i + 1 ])) \{}
\DoxyCodeLine{256             left\_i = i;}
\DoxyCodeLine{257           \}}
\DoxyCodeLine{258         \}}
\DoxyCodeLine{259         \textcolor{comment}{// loop through the source mesh and find the bracket-\/nodes}}
\DoxyCodeLine{260         \textcolor{keywordflow}{for}(std::size\_t j = 0; j < m\_Y.size() -\/ 1; ++j) \{}
\DoxyCodeLine{261           \textcolor{keywordflow}{if}((m\_Y[ j ] <= newY[ ynode ]) \&\& (newY[ ynode ] < m\_Y[ j + 1 ])) \{}
\DoxyCodeLine{262             below\_j = j;}
\DoxyCodeLine{263           \}}
\DoxyCodeLine{264         \}}
\DoxyCodeLine{265         DenseVector<\_Type> dvarsdX = (get\_nodes\_vars(left\_i + 1, below\_j) -\/ get\_nodes\_vars(left\_i, below\_j))}
\DoxyCodeLine{266                                      / (coord(left\_i + 1, below\_j).first -\/ coord(left\_i, below\_j).first);}
\DoxyCodeLine{267         DenseVector<\_Type> dvarsdY = (get\_nodes\_vars(left\_i, below\_j + 1) -\/ get\_nodes\_vars(left\_i, below\_j))}
\DoxyCodeLine{268                                      / (coord(left\_i, below\_j + 1).second -\/ coord(left\_i, below\_j).second);}
\DoxyCodeLine{269 }
\DoxyCodeLine{270         DenseVector<\_Type> interpolated\_vars\_bottom =}
\DoxyCodeLine{271           (get\_nodes\_vars(left\_i, below\_j) * (coord(left\_i + 1, below\_j).first -\/ newX[ xnode ])}
\DoxyCodeLine{272            + get\_nodes\_vars(left\_i + 1, below\_j) * (newX[ xnode ] -\/ coord(left\_i, below\_j).first)) /}
\DoxyCodeLine{273           (coord(left\_i + 1, below\_j).first -\/ coord(left\_i, below\_j).first);}
\DoxyCodeLine{274 }
\DoxyCodeLine{275         DenseVector<\_Type> interpolated\_vars\_top =}
\DoxyCodeLine{276           (get\_nodes\_vars(left\_i, below\_j + 1) * (coord(left\_i + 1, below\_j + 1).first -\/ newX[ xnode ])}
\DoxyCodeLine{277            + get\_nodes\_vars(left\_i + 1, below\_j + 1) * (newX[ xnode ] -\/ coord(left\_i, below\_j + 1).first)) /}
\DoxyCodeLine{278           (coord(left\_i + 1, below\_j + 1).first -\/ coord(left\_i, below\_j + 1).first);}
\DoxyCodeLine{279 }
\DoxyCodeLine{280         DenseVector<\_Type> interpolated\_vars =}
\DoxyCodeLine{281           (interpolated\_vars\_bottom * (coord(left\_i, below\_j + 1).second -\/ newY[ ynode ])}
\DoxyCodeLine{282            +  interpolated\_vars\_top * (newY[ ynode ] -\/ coord(left\_i, below\_j).second)) /}
\DoxyCodeLine{283           (coord(left\_i, below\_j + 1).second -\/ coord(left\_i, below\_j).second);}
\DoxyCodeLine{284 }
\DoxyCodeLine{285         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{286           newvars[(xnode * newY.size() + ynode) * m\_nv + var ] = interpolated\_vars[ var ];}
\DoxyCodeLine{287         \}}
\DoxyCodeLine{288       \}}
\DoxyCodeLine{289     \}}
\DoxyCodeLine{290     \textcolor{comment}{// finally replace the old nodes with the new ones}}
\DoxyCodeLine{291     m\_X = newX;}
\DoxyCodeLine{292     m\_Y = newY;}
\DoxyCodeLine{293     m\_nx = newX.size();}
\DoxyCodeLine{294     m\_ny = newY.size();}
\DoxyCodeLine{295     m\_vars = newvars;}
\DoxyCodeLine{296   \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::size(), and Cpp\+Noddy\+::\+Utility\+::stringify().



Referenced by main().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_acbcdb59fd193ba48bb3f57002d4c28e2}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!scale@{scale}}
\index{scale@{scale}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{scale()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::scale (\begin{DoxyParamCaption}\item[{const \+\_\+\+Type \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Calls the vector \char`\"{}scale\char`\"{} method for the whole mesh data. 


\begin{DoxyParams}{Parameters}
{\em value} & The value to be used in the scale operation ~\newline
 \\
\hline
\end{DoxyParams}


Definition at line 216 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{216                                    \{}
\DoxyCodeLine{217       m\_vars.scale(value);}
\DoxyCodeLine{218     \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+vars.

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_afb9e7f528defe8068ab8c481fa2cd988}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!set\_nodes\_vars@{set\_nodes\_vars}}
\index{set\_nodes\_vars@{set\_nodes\_vars}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{set\_nodes\_vars()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
void \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::set\+\_\+nodes\+\_\+vars (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{nodex,  }\item[{const std\+::size\+\_\+t}]{nodey,  }\item[{const \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \&}]{U }\end{DoxyParamCaption})}



Set the variables stored at A S\+P\+E\+C\+I\+F\+I\+ED node. 


\begin{DoxyParams}{Parameters}
{\em nodex} & The x nodal index to be set \\
\hline
{\em nodey} & The y nodal index to be set \\
\hline
{\em U} & The vector of V\+A\+R\+I\+A\+B\+L\+ES to be written to this nodal point \\
\hline
\end{DoxyParams}


Definition at line 20 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{20                                                                                                                       \{}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#ifdef PARANOID}}
\DoxyCodeLine{22     \textcolor{keywordflow}{if}(U.size() > m\_nv) \{}
\DoxyCodeLine{23       std::string problem;}
\DoxyCodeLine{24       problem = \textcolor{stringliteral}{" The TwoD\_Node\_Mesh.set\_nodes\_vars method is trying to use a \(\backslash\)n"};}
\DoxyCodeLine{25       problem += \textcolor{stringliteral}{" vector that has more entries than variables stored in the mesh. \(\backslash\)n"};}
\DoxyCodeLine{26       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{27     \}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{29     \textcolor{comment}{// assign contents of U to the member data}}
\DoxyCodeLine{30     std::size\_t offset((nodex * m\_ny + nodey) * m\_nv);}
\DoxyCodeLine{31     \textcolor{keywordflow}{for}(std::size\_t var = 0; var < m\_nv; ++var) \{}
\DoxyCodeLine{32       m\_vars[ offset++ ] = U[ var ];}
\DoxyCodeLine{33     \}}
\DoxyCodeLine{34   \}}

\end{DoxyCode}


References U.



Referenced by Cpp\+Noddy\+::\+F\+T\+::dft\+\_\+with\+\_\+shift(), and Cpp\+Noddy\+::\+F\+T\+::idft\+\_\+with\+\_\+ishift().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a501158c5aa29ea3e579b6591333b1ccb}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!xcoord@{xcoord}}
\index{xcoord@{xcoord}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{xcoord()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
double\& \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::xcoord (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{nodex }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access the x-\/nodal (first index) position. 


\begin{DoxyParams}{Parameters}
{\em nodex} & The x nodal index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The x-\/coordinate of the node 
\end{DoxyReturn}


Definition at line 98 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{98                                           \{}
\DoxyCodeLine{99       \textcolor{keywordflow}{return} m\_X[nodex];}
\DoxyCodeLine{100     \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+X.



Referenced by Cpp\+Noddy\+::\+F\+T\+::dft\+\_\+with\+\_\+shift(), and Cpp\+Noddy\+::\+F\+T\+::idft\+\_\+with\+\_\+ishift().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a7d7b4a57943701df85ef02616beecbbb}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!xnodes@{xnodes}}
\index{xnodes@{xnodes}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{xnodes()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
const \textbf{ Dense\+Vector}$<$ double $>$ \& \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::xnodes}



Access the vector of x-\/nodal positions. 

\begin{DoxyReturn}{Returns}
A vector of the nodal positions for this mesh 
\end{DoxyReturn}


Definition at line 70 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{70                                                                  \{}
\DoxyCodeLine{71     \textcolor{keywordflow}{return} m\_X;}
\DoxyCodeLine{72   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+F\+T\+::idft\+\_\+with\+\_\+ishift().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_ade7852b96de55d56c9886d78357c7ff3}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!ycoord@{ycoord}}
\index{ycoord@{ycoord}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{ycoord()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
double\& \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::ycoord (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{nodey }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access the y-\/nodal (second index) position. 


\begin{DoxyParams}{Parameters}
{\em nodex} & The y nodal index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The y-\/coordinate of the node 
\end{DoxyReturn}


Definition at line 105 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{105                                           \{}
\DoxyCodeLine{106       \textcolor{keywordflow}{return} m\_Y[nodey];}
\DoxyCodeLine{107     \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::m\+\_\+Y.

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_aa69df3f12d609204a860bd855f66cdb2}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!ynodes@{ynodes}}
\index{ynodes@{ynodes}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{ynodes()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
const \textbf{ Dense\+Vector}$<$ double $>$ \& \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::ynodes}



Access the vector of y-\/nodal positions. 

\begin{DoxyReturn}{Returns}
A vector of the nodal positions for this mesh 
\end{DoxyReturn}


Definition at line 75 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{75                                                                  \{}
\DoxyCodeLine{76     \textcolor{keywordflow}{return} m\_Y;}
\DoxyCodeLine{77   \}}

\end{DoxyCode}


Referenced by Cpp\+Noddy\+::\+F\+T\+::idft\+\_\+with\+\_\+ishift().



\doxysubsubsection{Member Data Documentation}
\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_ab6c54ed558c286dce33418b64db7b23c}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!m\_nv@{m\_nv}}
\index{m\_nv@{m\_nv}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{m\_nv}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
std\+::size\+\_\+t \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::m\+\_\+nv\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 306 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.



Referenced by Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+xsection\+\_\+at\+\_\+x1(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::max\+\_\+abs(), and Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_afd9dddb29fc488b0cbd5bc0b9ea2c0a7}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!m\_nx@{m\_nx}}
\index{m\_nx@{m\_nx}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{m\_nx}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
std\+::size\+\_\+t \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::m\+\_\+nx\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 306 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.



Referenced by Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+interpolated\+\_\+vars(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+xsection\+\_\+at\+\_\+x1(), and Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a93f5c00811556987930090142a8dfefe}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!m\_ny@{m\_ny}}
\index{m\_ny@{m\_ny}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{m\_ny}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
std\+::size\+\_\+t \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::m\+\_\+ny\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 306 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.



Referenced by Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+interpolated\+\_\+vars(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+xsection\+\_\+at\+\_\+x1(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::max\+\_\+abs(), and Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a4cc920ca0af3d402cb9e37755e4e6d25}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!m\_vars@{m\_vars}}
\index{m\_vars@{m\_vars}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{m\_vars}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Vector}$<$\+\_\+\+Type$>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::m\+\_\+vars\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 312 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.



Referenced by Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::max\+\_\+abs(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::normalise\+\_\+real\+\_\+part(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::scale(), and Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_af5665964b876a072b29f869cd8b2b4fa}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!m\_X@{m\_X}}
\index{m\_X@{m\_X}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{m\_X}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Vector}$<$double$>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::m\+\_\+X\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 308 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.



Referenced by Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+interpolated\+\_\+vars(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+xsection\+\_\+at\+\_\+x1(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::max\+\_\+abs(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh(), and Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::xcoord().

\mbox{\label{classCppNoddy_1_1TwoD__Node__Mesh_a22ba263b02fd32e683fef5a753ec8a50}} 
\index{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}!m\_Y@{m\_Y}}
\index{m\_Y@{m\_Y}!CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$@{CppNoddy::TwoD\_Node\_Mesh$<$ \_Type $>$}}
\doxyparagraph{m\_Y}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type $>$ \\
\textbf{ Dense\+Vector}$<$double$>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type $>$\+::m\+\_\+Y\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 310 of file Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h.



Referenced by Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+interpolated\+\_\+vars(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::get\+\_\+xsection\+\_\+at\+\_\+x1(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::max\+\_\+abs(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh(), and Cpp\+Noddy\+::\+Two\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type $>$\+::ycoord().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/\textbf{ Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+h}\item 
src/\textbf{ Two\+D\+\_\+\+Node\+\_\+\+Mesh.\+cpp}\end{DoxyCompactItemize}
