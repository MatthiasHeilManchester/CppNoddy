\doxysubsection{Tests/\+H\+Y\+P\+\_\+2\+D/\+H\+Y\+P2\+D\+Nonlinear\+AdvectionX.cpp File Reference}
\label{HYP2DNonlinearAdvectionX_8cpp}\index{Tests/HYP\_2D/HYP2DNonlinearAdvectionX.cpp@{Tests/HYP\_2D/HYP2DNonlinearAdvectionX.cpp}}
{\ttfamily \#include $<$Two\+D\+\_\+\+H\+Y\+P\+\_\+bundle.\+h$>$}\newline
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Cpp\+Noddy\+::\+Example\+::\+Nlin\+Adv}
\begin{DoxyCompactList}\small\item\em Define the system. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \textbf{ Cpp\+Noddy}
\begin{DoxyCompactList}\small\item\em A collection of OO numerical routines aimed at simple (typical) applied problems in continuum mechanics. \end{DoxyCompactList}\item 
 \textbf{ Cpp\+Noddy\+::\+Example}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Cpp\+Noddy\+::\+Example\+::\+Q\+\_\+init} (const double \&x, const double \&y, \textbf{ Dense\+Vector}$<$ double $>$ \&q)
\begin{DoxyCompactList}\small\item\em Set the initial state of the system. \end{DoxyCompactList}\item 
int \textbf{ main} ()
\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
Solving the 1D `nonlinear advection equation' \[ Q_t + \left ( \frac{Q^2}{2} \right )_x = 0 \quad \mbox{where} \quad Q=Q(x,y,t) \] using a T\+VD Lax-\/\+Friedrichs scheme for $ (x,y)\in[-1,1]\times[-1,1]$. The initial condition is a sine distribution. 

\doxysubsubsection{Function Documentation}
\mbox{\label{HYP2DNonlinearAdvectionX_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}} 
\index{HYP2DNonlinearAdvectionX.cpp@{HYP2DNonlinearAdvectionX.cpp}!main@{main}}
\index{main@{main}!HYP2DNonlinearAdvectionX.cpp@{HYP2DNonlinearAdvectionX.cpp}}
\doxyparagraph{main()}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 76 of file H\+Y\+P2\+D\+Nonlinear\+Advection\+X.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{77 \{}
\DoxyCodeLine{78 }
\DoxyCodeLine{79   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{80   cout << \textcolor{stringliteral}{"=== Hyperbolic: 2D nonlinear advection in x =========\(\backslash\)n"};}
\DoxyCodeLine{81   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{82 }
\DoxyCodeLine{83   \textcolor{comment}{// define the domain/mesh}}
\DoxyCodeLine{84   \textcolor{keyword}{const} \textcolor{keywordtype}{double} west =  1.0;}
\DoxyCodeLine{85   \textcolor{keyword}{const} \textcolor{keywordtype}{double} east = 0.0;}
\DoxyCodeLine{86   \textcolor{keyword}{const} \textcolor{keywordtype}{double} south =  0.0;}
\DoxyCodeLine{87   \textcolor{keyword}{const} \textcolor{keywordtype}{double} north = 1.0;}
\DoxyCodeLine{88   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} N = 51;}
\DoxyCodeLine{89   DenseVector<double> faces\_x = Utility::uniform\_node\_vector( east, west, N );}
\DoxyCodeLine{90   DenseVector<double> faces\_y = Utility::uniform\_node\_vector( south, north, N );}
\DoxyCodeLine{91 }
\DoxyCodeLine{92   Example::NlinAdv conservative\_problem;}
\DoxyCodeLine{93   TwoD\_TVDLF\_Mesh NlinAdv\_mesh( faces\_x, faces\_y, \&conservative\_problem, Example::Q\_init );}
\DoxyCodeLine{94   NlinAdv\_mesh.set\_limiter( 0 );}
\DoxyCodeLine{95 }
\DoxyCodeLine{96   \textcolor{keywordtype}{double} asym( 0.0 );}
\DoxyCodeLine{97   \textcolor{keywordtype}{unsigned} loop\_counter( 0 );}
\DoxyCodeLine{98   DenseVector<double> x1( 2, 0.0 );}
\DoxyCodeLine{99   x1[ 0 ] = 0.75;}
\DoxyCodeLine{100   x1[ 1 ] = 0.5;}
\DoxyCodeLine{101   DenseVector<double> x2( 2, 0.0 );}
\DoxyCodeLine{102   x2[ 0 ] = 0.25;}
\DoxyCodeLine{103   x2[ 1 ] = 0.5;}
\DoxyCodeLine{104   \textcolor{keywordflow}{do}}
\DoxyCodeLine{105   \{}
\DoxyCodeLine{106     NlinAdv\_mesh.update( 0.49 );}
\DoxyCodeLine{107     asym = std::max( asym, std::abs( NlinAdv\_mesh.get\_point\_values( x1 )[0] + NlinAdv\_mesh.get\_point\_values( x2 )[0] ) );}
\DoxyCodeLine{108     ++loop\_counter;}
\DoxyCodeLine{109   \}}
\DoxyCodeLine{110   \textcolor{keywordflow}{while} ( ( NlinAdv\_mesh.get\_time() < 0.4 ) \&\& ( loop\_counter < 1000 ) );}
\DoxyCodeLine{111 }
\DoxyCodeLine{112   \textcolor{comment}{// problem should be antisymmetric about x = 1/2}}
\DoxyCodeLine{113   \textcolor{keywordflow}{if} ( ( asym > 1.e-\/10 ) || ( loop\_counter >= 1000 ) )}
\DoxyCodeLine{114   \{}
\DoxyCodeLine{115     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;31;48m  * FAILED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{116     cout << \textcolor{stringliteral}{"asymmetry = "} << asym << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{117     cout << \textcolor{stringliteral}{"loop counter = "} << loop\_counter << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{118     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{119   \}}
\DoxyCodeLine{120   \textcolor{keywordflow}{else}}
\DoxyCodeLine{121   \{}
\DoxyCodeLine{122     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;32;48m  * PASSED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{123     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{124   \}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 \} \textcolor{comment}{// end of main()}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+point\+\_\+values(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+time(), Cpp\+Noddy\+::\+Example\+::\+Q\+\_\+init(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::set\+\_\+limiter(), Cpp\+Noddy\+::\+Utility\+::uniform\+\_\+node\+\_\+vector(), and Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::update().

