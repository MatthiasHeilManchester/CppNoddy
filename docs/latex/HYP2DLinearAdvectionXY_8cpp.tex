\doxysubsection{Tests/\+H\+Y\+P\+\_\+2\+D/\+H\+Y\+P2\+D\+Linear\+Advection\+XY.cpp File Reference}
\label{HYP2DLinearAdvectionXY_8cpp}\index{Tests/HYP\_2D/HYP2DLinearAdvectionXY.cpp@{Tests/HYP\_2D/HYP2DLinearAdvectionXY.cpp}}
{\ttfamily \#include $<$Two\+D\+\_\+\+H\+Y\+P\+\_\+bundle.\+h$>$}\newline
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Cpp\+Noddy\+::\+Example\+::\+Nlin\+Adv}
\begin{DoxyCompactList}\small\item\em Define the system. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \textbf{ Cpp\+Noddy}
\begin{DoxyCompactList}\small\item\em A collection of OO numerical routines aimed at simple (typical) applied problems in continuum mechanics. \end{DoxyCompactList}\item 
 \textbf{ Cpp\+Noddy\+::\+Example}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Cpp\+Noddy\+::\+Example\+::\+Q\+\_\+init} (const double \&x, const double \&y, \textbf{ Dense\+Vector}$<$ double $>$ \&q)
\begin{DoxyCompactList}\small\item\em Set the initial state of the system. \end{DoxyCompactList}\item 
int \textbf{ main} ()
\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
Solving the 2D advection equation \[ Q_t + \left ( \frac{Q}{\sqrt{2}} \right )_x + \left ( \frac{Q}{\sqrt{2}} \right )_y= 0 \quad \mbox{where} \quad Q=Q(x,y,t) \] using a T\+VD Lax-\/\+Friedrichs scheme for $ (x,y)\in[-1,1]\times[-1,1]$. The initial condition is a step. 

\doxysubsubsection{Function Documentation}
\mbox{\label{HYP2DLinearAdvectionXY_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}} 
\index{HYP2DLinearAdvectionXY.cpp@{HYP2DLinearAdvectionXY.cpp}!main@{main}}
\index{main@{main}!HYP2DLinearAdvectionXY.cpp@{HYP2DLinearAdvectionXY.cpp}}
\doxyparagraph{main()}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 65 of file H\+Y\+P2\+D\+Linear\+Advection\+X\+Y.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{66 \{}
\DoxyCodeLine{67 }
\DoxyCodeLine{68   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{69   cout << \textcolor{stringliteral}{"=== Hyperbolic: 2D linear advection at an angle =====\(\backslash\)n"};}
\DoxyCodeLine{70   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{71 }
\DoxyCodeLine{72   \textcolor{comment}{// define the domain/mesh}}
\DoxyCodeLine{73   \textcolor{keyword}{const} \textcolor{keywordtype}{double} west =  1.0;}
\DoxyCodeLine{74   \textcolor{keyword}{const} \textcolor{keywordtype}{double} east = -\/1.0;}
\DoxyCodeLine{75   \textcolor{keyword}{const} \textcolor{keywordtype}{double} south =  -\/1.0;}
\DoxyCodeLine{76   \textcolor{keyword}{const} \textcolor{keywordtype}{double} north = 1.0;}
\DoxyCodeLine{77   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} N = 51;}
\DoxyCodeLine{78   DenseVector<double> faces\_x = Utility::uniform\_node\_vector( east, west, N );}
\DoxyCodeLine{79   DenseVector<double> faces\_y = Utility::uniform\_node\_vector( south, north, N );}
\DoxyCodeLine{80 }
\DoxyCodeLine{81   Example::NlinAdv conservative\_problem;}
\DoxyCodeLine{82   TwoD\_TVDLF\_Mesh NlinAdv\_mesh( faces\_x, faces\_y, \&conservative\_problem, Example::Q\_init );}
\DoxyCodeLine{83   NlinAdv\_mesh.set\_limiter( 1 );}
\DoxyCodeLine{84 }
\DoxyCodeLine{85   \textcolor{keywordtype}{double} asym( 0.0 );}
\DoxyCodeLine{86   \textcolor{keywordtype}{unsigned} loop\_counter( 0 );}
\DoxyCodeLine{87   DenseVector<double> x1( 2, 0.0 );}
\DoxyCodeLine{88   x1[ 0 ] = 0.2;}
\DoxyCodeLine{89   x1[ 1 ] = 0.4;}
\DoxyCodeLine{90   DenseVector<double> x2( 2, 0.0 );}
\DoxyCodeLine{91   x2[ 0 ] = 0.4;}
\DoxyCodeLine{92   x2[ 1 ] = 0.2;}
\DoxyCodeLine{93   \textcolor{keywordflow}{do}}
\DoxyCodeLine{94   \{}
\DoxyCodeLine{95     NlinAdv\_mesh.update( 0.49 );}
\DoxyCodeLine{96     asym = std::max( asym, std::abs( NlinAdv\_mesh.get\_point\_values( x1 )[0] -\/ NlinAdv\_mesh.get\_point\_values( x2 )[0] ) );}
\DoxyCodeLine{97     ++loop\_counter;}
\DoxyCodeLine{98   \}}
\DoxyCodeLine{99   \textcolor{keywordflow}{while} ( ( NlinAdv\_mesh.get\_time() < 1.0 ) \&\& ( loop\_counter < 20 ) );}
\DoxyCodeLine{100 }
\DoxyCodeLine{101   \textcolor{comment}{// problem should be antisymmetric about y = x}}
\DoxyCodeLine{102   \textcolor{keywordflow}{if} ( ( asym > 5.e-\/10 ) || ( loop\_counter >= 1000 ) )}
\DoxyCodeLine{103   \{}
\DoxyCodeLine{104     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;31;48m  * FAILED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{105     cout << \textcolor{stringliteral}{"asymmetry = "} << asym << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{106     cout << \textcolor{stringliteral}{"loop counter = "} << loop\_counter << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{107     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{108   \}}
\DoxyCodeLine{109   \textcolor{keywordflow}{else}}
\DoxyCodeLine{110   \{}
\DoxyCodeLine{111     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;32;48m  * PASSED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{112     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{113   \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115 \} \textcolor{comment}{// end of main()}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+point\+\_\+values(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+time(), Cpp\+Noddy\+::\+Example\+::\+Q\+\_\+init(), Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::set\+\_\+limiter(), Cpp\+Noddy\+::\+Utility\+::uniform\+\_\+node\+\_\+vector(), and Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::update().

