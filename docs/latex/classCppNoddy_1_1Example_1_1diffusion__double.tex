\doxysubsection{Cpp\+Noddy\+::Example\+::diffusion\+\_\+double Class Reference}
\label{classCppNoddy_1_1Example_1_1diffusion__double}\index{CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}}
Inheritance diagram for Cpp\+Noddy\+::Example\+::diffusion\+\_\+double\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6.000000cm]{classCppNoddy_1_1Example_1_1diffusion__double}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ diffusion\+\_\+double} ()
\begin{DoxyCompactList}\small\item\em The problem is 2nd order and real. \end{DoxyCompactList}\item 
void \textbf{ residual\+\_\+fn} (const \textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ z}, \textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ f}) const
\begin{DoxyCompactList}\small\item\em Define a nonlinear advection diffusion problem. \end{DoxyCompactList}\item 
void \textbf{ jacobian} (const \textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ z}, \textbf{ Dense\+Matrix}$<$ double $>$ \&jac) const
\begin{DoxyCompactList}\small\item\em Provide the exact Jacobian rather than using finite-\/differences. \end{DoxyCompactList}\item 
void \textbf{ matrix0} (const \textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ z}, \textbf{ Dense\+Matrix}$<$ double $>$ \&\textbf{ m}) const
\begin{DoxyCompactList}\small\item\em Define the matrix in terms of the current state vector. \end{DoxyCompactList}\item 
void \textbf{ matrix1} (const \textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ z}, \textbf{ Dense\+Matrix}$<$ double $>$ \&\textbf{ m}) const
\begin{DoxyCompactList}\small\item\em Define the unsteady terms by providing the mass matrix. \end{DoxyCompactList}\item 
void \textbf{ matrix2} (const \textbf{ Dense\+Vector}$<$ double $>$ \&\textbf{ z}, \textbf{ Dense\+Matrix}$<$ double $>$ \&\textbf{ m}) const
\begin{DoxyCompactList}\small\item\em Define the matrix for the current state vector. \end{DoxyCompactList}\item 
void \textbf{ get\+\_\+jacobian\+\_\+of\+\_\+matrix0\+\_\+mult\+\_\+vector} (const \textbf{ Dense\+Vector}$<$ double $>$ \&state, const \textbf{ Dense\+Vector}$<$ double $>$ \&vec, \textbf{ Dense\+Matrix}$<$ double $>$ \&\textbf{ h}) const
\begin{DoxyCompactList}\small\item\em Return the product of the Jacobian-\/of-\/the-\/matrix and a vector \textquotesingle{}vec\textquotesingle{} when the equation has a given \textquotesingle{}state\textquotesingle{}. \end{DoxyCompactList}\item 
void \textbf{ get\+\_\+jacobian\+\_\+of\+\_\+matrix1\+\_\+mult\+\_\+vector} (const \textbf{ Dense\+Vector}$<$ double $>$ \&state, const \textbf{ Dense\+Vector}$<$ double $>$ \&vec, \textbf{ Dense\+Matrix}$<$ double $>$ \&\textbf{ h}) const
\begin{DoxyCompactList}\small\item\em Return the product of the Jacobian-\/of-\/the-\/matrix and a vector \textquotesingle{}vec\textquotesingle{} when the equation has a given \textquotesingle{}state\textquotesingle{}. \end{DoxyCompactList}\item 
void \textbf{ get\+\_\+jacobian\+\_\+of\+\_\+matrix2\+\_\+mult\+\_\+vector} (const \textbf{ Dense\+Vector}$<$ double $>$ \&state, const \textbf{ Dense\+Vector}$<$ double $>$ \&vec, \textbf{ Dense\+Matrix}$<$ double $>$ \&\textbf{ h}) const
\begin{DoxyCompactList}\small\item\em Return the product of the Jacobian-\/of-\/the-\/matrix and a vector \textquotesingle{}vec\textquotesingle{} when the equation has a given \textquotesingle{}state\textquotesingle{}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}


\doxysubsubsection{Detailed Description}


Definition at line 31 of file I\+B\+V\+P\+Linear.\+cpp.



\doxysubsubsection{Constructor \& Destructor Documentation}
\mbox{\label{classCppNoddy_1_1Example_1_1diffusion__double_aa2d92c8bfe3f70389c24dadd27ae20a3}} 
\index{CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}!diffusion\_double@{diffusion\_double}}
\index{diffusion\_double@{diffusion\_double}!CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}}
\doxyparagraph{diffusion\_double()}
{\footnotesize\ttfamily Cpp\+Noddy\+::\+Example\+::diffusion\+\_\+double\+::diffusion\+\_\+double (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



The problem is 2nd order and real. 



Definition at line 35 of file I\+B\+V\+P\+Linear.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{35 : Equation\_3matrix<double> ( 2 ) \{\}}

\end{DoxyCode}


\doxysubsubsection{Member Function Documentation}
\mbox{\label{classCppNoddy_1_1Example_1_1diffusion__double_a133f3b9ca63244fc1e55988aa840b0a5}} 
\index{CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}!get\_jacobian\_of\_matrix0\_mult\_vector@{get\_jacobian\_of\_matrix0\_mult\_vector}}
\index{get\_jacobian\_of\_matrix0\_mult\_vector@{get\_jacobian\_of\_matrix0\_mult\_vector}!CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}}
\doxyparagraph{get\_jacobian\_of\_matrix0\_mult\_vector()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::diffusion\+\_\+double\+::get\+\_\+jacobian\+\_\+of\+\_\+matrix0\+\_\+mult\+\_\+vector (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{state,  }\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{vec,  }\item[{\textbf{ Dense\+Matrix}$<$ double $>$ \&}]{h }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Return the product of the Jacobian-\/of-\/the-\/matrix and a vector \textquotesingle{}vec\textquotesingle{} when the equation has a given \textquotesingle{}state\textquotesingle{}. 

The user should overload this if concerned about performance of the solver. If not overloaded, the default is to finite difference the Jacobian-\/of-\/the-\/matrix. 
\begin{DoxyParams}{Parameters}
{\em state} & The current state variables -- used for clarity when overloaded by the user instead of expecting the user to access the member data. \\
\hline
{\em vec} & The vector that will be multiplied by the Jacobian-\/of-\/the-\/matrix \\
\hline
{\em h} & The resulting 2D matrix \\
\hline
\end{DoxyParams}


Reimplemented from \textbf{ Cpp\+Noddy\+::\+Equation\+\_\+1matrix$<$ double, double $>$} \doxyref{}{p.}{classCppNoddy_1_1Equation__1matrix_a293c22844ca906668d9c13945438fa09}.



Definition at line 70 of file I\+B\+V\+P\+Linear.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{71       \{}
\DoxyCodeLine{72         \textcolor{comment}{// constant matrix}}
\DoxyCodeLine{73       \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1Example_1_1diffusion__double_a028bb89e2067065ea24229a7a2b3647d}} 
\index{CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}!get\_jacobian\_of\_matrix1\_mult\_vector@{get\_jacobian\_of\_matrix1\_mult\_vector}}
\index{get\_jacobian\_of\_matrix1\_mult\_vector@{get\_jacobian\_of\_matrix1\_mult\_vector}!CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}}
\doxyparagraph{get\_jacobian\_of\_matrix1\_mult\_vector()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::diffusion\+\_\+double\+::get\+\_\+jacobian\+\_\+of\+\_\+matrix1\+\_\+mult\+\_\+vector (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{state,  }\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{vec,  }\item[{\textbf{ Dense\+Matrix}$<$ double $>$ \&}]{h }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Return the product of the Jacobian-\/of-\/the-\/matrix and a vector \textquotesingle{}vec\textquotesingle{} when the equation has a given \textquotesingle{}state\textquotesingle{}. 

The user should overload this if concerned about performance of the solver. If not overloaded, the default is to finite difference the Jacobian-\/of-\/the-\/matrix. 
\begin{DoxyParams}{Parameters}
{\em state} & The current state variables -- used for clarity when overloaded by the user instead of expecting the user to access the member data. \\
\hline
{\em vec} & The vector that will be multiplied by the Jacobian-\/of-\/the-\/matrix \\
\hline
{\em h} & The resulting 2D matrix \\
\hline
\end{DoxyParams}


Reimplemented from \textbf{ Cpp\+Noddy\+::\+Equation\+\_\+2matrix$<$ double, double $>$} \doxyref{}{p.}{classCppNoddy_1_1Equation__2matrix_a5b3040cf23a1a082ebab4a819102ceee}.



Definition at line 74 of file I\+B\+V\+P\+Linear.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{75       \{}
\DoxyCodeLine{76         \textcolor{comment}{// constant matrix}}
\DoxyCodeLine{77       \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1Example_1_1diffusion__double_a03dfcd13480734fed9bc5c11129233a9}} 
\index{CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}!get\_jacobian\_of\_matrix2\_mult\_vector@{get\_jacobian\_of\_matrix2\_mult\_vector}}
\index{get\_jacobian\_of\_matrix2\_mult\_vector@{get\_jacobian\_of\_matrix2\_mult\_vector}!CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}}
\doxyparagraph{get\_jacobian\_of\_matrix2\_mult\_vector()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::diffusion\+\_\+double\+::get\+\_\+jacobian\+\_\+of\+\_\+matrix2\+\_\+mult\+\_\+vector (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{state,  }\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{vec,  }\item[{\textbf{ Dense\+Matrix}$<$ double $>$ \&}]{h }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Return the product of the Jacobian-\/of-\/the-\/matrix and a vector \textquotesingle{}vec\textquotesingle{} when the equation has a given \textquotesingle{}state\textquotesingle{}. 

The user should overload this if concerned about performance of the solver. If not overloaded, the default is to finite difference the Jacobian-\/of-\/the-\/matrix. 
\begin{DoxyParams}{Parameters}
{\em state} & The current state variables -- used for clarity when overloaded by the user instead of expecting the user to access the member data. \\
\hline
{\em vec} & The vector that will be multiplied by the Jacobian-\/of-\/the-\/matrix \\
\hline
{\em h} & The resulting 2D matrix \\
\hline
\end{DoxyParams}


Reimplemented from \textbf{ Cpp\+Noddy\+::\+Equation\+\_\+3matrix$<$ double $>$} \doxyref{}{p.}{classCppNoddy_1_1Equation__3matrix_af5f3eddaa1cbdb8901d6abf313fa2ceb}.



Definition at line 78 of file I\+B\+V\+P\+Linear.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{79       \{}
\DoxyCodeLine{80         \textcolor{comment}{// constant matrix}}
\DoxyCodeLine{81       \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1Example_1_1diffusion__double_a090549efbd12f282fe7419894d817c8c}} 
\index{CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}!jacobian@{jacobian}}
\index{jacobian@{jacobian}!CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}}
\doxyparagraph{jacobian()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::diffusion\+\_\+double\+::jacobian (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{z,  }\item[{\textbf{ Dense\+Matrix}$<$ double $>$ \&}]{jac }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Provide the exact Jacobian rather than using finite-\/differences. 



Reimplemented from \textbf{ Cpp\+Noddy\+::\+Residual$<$ double $>$} \doxyref{}{p.}{classCppNoddy_1_1Residual_a663b7f936049d9b47e9ae2e18ea3d926}.



Definition at line 46 of file I\+B\+V\+P\+Linear.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{47       \{}
\DoxyCodeLine{48         jac( 0, Ud ) = 1.0;}
\DoxyCodeLine{49       \}}

\end{DoxyCode}


References Ud.

\mbox{\label{classCppNoddy_1_1Example_1_1diffusion__double_ae04037119d03387bbe088b72d3da3cc5}} 
\index{CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}!matrix0@{matrix0}}
\index{matrix0@{matrix0}!CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}}
\doxyparagraph{matrix0()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::diffusion\+\_\+double\+::matrix0 (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{x,  }\item[{\textbf{ Dense\+Matrix}$<$ double $>$ \&}]{m }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Define the matrix in terms of the current state vector. 


\begin{DoxyParams}{Parameters}
{\em x} & The current state vector. \\
\hline
{\em m} & The matrix. \\
\hline
\end{DoxyParams}


Reimplemented from \textbf{ Cpp\+Noddy\+::\+Equation\+\_\+1matrix$<$ double, double $>$} \doxyref{}{p.}{classCppNoddy_1_1Equation__1matrix_af3f73a36fb2ec75a03f0298874d30e4c}.



Definition at line 51 of file I\+B\+V\+P\+Linear.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{52       \{}
\DoxyCodeLine{53         Utils\_Fill::fill\_identity(m);}
\DoxyCodeLine{54       \}}

\end{DoxyCode}


References Utils\+\_\+\+Fill\+::fill\+\_\+identity(), and m.

\mbox{\label{classCppNoddy_1_1Example_1_1diffusion__double_a8339b8facf829469ed6d3dcf818c0030}} 
\index{CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}!matrix1@{matrix1}}
\index{matrix1@{matrix1}!CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}}
\doxyparagraph{matrix1()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::diffusion\+\_\+double\+::matrix1 (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{z,  }\item[{\textbf{ Dense\+Matrix}$<$ double $>$ \&}]{m }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Define the unsteady terms by providing the mass matrix. 



Reimplemented from \textbf{ Cpp\+Noddy\+::\+Equation\+\_\+2matrix$<$ double, double $>$} \doxyref{}{p.}{classCppNoddy_1_1Equation__2matrix_a362eab539b08f747e8360d5d1a0934e8}.



Definition at line 57 of file I\+B\+V\+P\+Linear.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{58       \{}
\DoxyCodeLine{59         \textcolor{comment}{// eqn 1 variable 0}}
\DoxyCodeLine{60         m( 1, 0 ) = -\/1.0;}
\DoxyCodeLine{61       \}}

\end{DoxyCode}


References m.

\mbox{\label{classCppNoddy_1_1Example_1_1diffusion__double_a8e96bb00b79fd0424dac3605f8acfe9d}} 
\index{CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}!matrix2@{matrix2}}
\index{matrix2@{matrix2}!CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}}
\doxyparagraph{matrix2()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::diffusion\+\_\+double\+::matrix2 (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{state,  }\item[{\textbf{ Dense\+Matrix}$<$ double $>$ \&}]{m }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Define the matrix for the current state vector. 


\begin{DoxyParams}{Parameters}
{\em state} & The current state vector. \\
\hline
{\em m} & The matrix. \\
\hline
\end{DoxyParams}


Reimplemented from \textbf{ Cpp\+Noddy\+::\+Equation\+\_\+3matrix$<$ double $>$} \doxyref{}{p.}{classCppNoddy_1_1Equation__3matrix_a4bba4557bf702e028c4bd7deb09df688}.



Definition at line 63 of file I\+B\+V\+P\+Linear.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{64       \{}
\DoxyCodeLine{65         \textcolor{comment}{// eqn 1 variable 0}}
\DoxyCodeLine{66         m( 1, 0 ) = -\/1.0;}
\DoxyCodeLine{67       \}}

\end{DoxyCode}


References m.

\mbox{\label{classCppNoddy_1_1Example_1_1diffusion__double_a3c589cdb6a54a3639e7362b7b0f258bb}} 
\index{CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}!residual\_fn@{residual\_fn}}
\index{residual\_fn@{residual\_fn}!CppNoddy::Example::diffusion\_double@{CppNoddy::Example::diffusion\_double}}
\doxyparagraph{residual\_fn()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Example\+::diffusion\+\_\+double\+::residual\+\_\+fn (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{z,  }\item[{\textbf{ Dense\+Vector}$<$ double $>$ \&}]{f }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Define a nonlinear advection diffusion problem. 



Reimplemented from \textbf{ Cpp\+Noddy\+::\+Residual$<$ double $>$} \doxyref{}{p.}{classCppNoddy_1_1Residual_a8016270e2cd26406a3681087f4a105c8}.



Definition at line 38 of file I\+B\+V\+P\+Linear.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{39       \{}
\DoxyCodeLine{40         \textcolor{comment}{// The system}}
\DoxyCodeLine{41         f[ U ] = z[ Ud ];}
\DoxyCodeLine{42         f[ Ud ] = source( coord(2), coord(0), coord(1) );}
\DoxyCodeLine{43       \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Residual\+\_\+with\+\_\+coords$<$ double, double $>$\+::coord(), f, Cpp\+Noddy\+::\+Example\+::source(), Cpp\+Noddy\+::\+Example\+::\+U(), Ud, and Cpp\+Noddy\+::\+Example\+::z().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Tests/double\+\_\+\+I\+B\+V\+P/\textbf{ I\+B\+V\+P\+Linear.\+cpp}\end{DoxyCompactItemize}
