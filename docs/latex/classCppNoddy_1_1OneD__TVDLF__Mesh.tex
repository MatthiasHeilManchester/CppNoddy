\doxysubsection{Cpp\+Noddy\+::One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh Class Reference}
\label{classCppNoddy_1_1OneD__TVDLF__Mesh}\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}


{\ttfamily \#include $<$One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh} (const \textbf{ Dense\+Vector}$<$ double $>$ \&X, \textbf{ One\+D\+\_\+\+Hyperbolic\+\_\+\+System} $\ast$ptr, fn\+\_\+ptr init\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Constructor for the Finite Volume Mesh using linear elements. \end{DoxyCompactList}\item 
\textbf{ $\sim$\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh} ()
\begin{DoxyCompactList}\small\item\em Empty desctructor. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ get\+\_\+mid\+\_\+node\+\_\+vector} () const
\begin{DoxyCompactList}\small\item\em Get the nodal positions in the middle of each element. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ get\+\_\+face\+\_\+pos\+\_\+vector} () const
\begin{DoxyCompactList}\small\item\em Get the positions of the element faces. \end{DoxyCompactList}\item 
void \textbf{ set\+\_\+limiter} (unsigned id)
\begin{DoxyCompactList}\small\item\em Set the limiter type to be applied in the slope values. \end{DoxyCompactList}\item 
double \textbf{ update} (const double \&C\+FL, const double \&max\+\_\+dt=std\+::numeric\+\_\+limits$<$ long double $>$\+::max())
\begin{DoxyCompactList}\small\item\em Update all the elements in this mesh to a new time step. \end{DoxyCompactList}\item 
void \textbf{ update\+\_\+to} (const double \&C\+FL, const double \&t\+\_\+end)
\begin{DoxyCompactList}\small\item\em Update all the elements in this mesh to a U\+S\+ER S\+P\+E\+C\+I\+F\+I\+ED time step. \end{DoxyCompactList}\item 
double \textbf{ update\+\_\+to\+\_\+red} (const double \&C\+FL, const double \&max\+\_\+dt)
\item 
double \textbf{ update\+\_\+to\+\_\+black} (const double \&C\+FL, const double \&max\+\_\+dt)
\item 
const double \& \textbf{ get\+\_\+time} () const
\begin{DoxyCompactList}\small\item\em Get a const reference to the time value for the current mesh. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ integrate} () const
\begin{DoxyCompactList}\small\item\em Integrate the concentration values across the entire mesh. \end{DoxyCompactList}\item 
\textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ double $>$ \textbf{ get\+\_\+soln} (std\+::string location=\char`\"{}centre\char`\"{}, std\+::string colour=\char`\"{}black\char`\"{})
\begin{DoxyCompactList}\small\item\em Get a One\+D\+\_\+\+Mesh$<$double$>$ object containing the one dimensional data in the usual format. \end{DoxyCompactList}\item 
\textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ double $>$ \textbf{ get\+\_\+slope} ()
\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}


Definition at line 19 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.



\doxysubsubsection{Constructor \& Destructor Documentation}
\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_a8d4a5b71c405e560d9bf6282eeb71bdc}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!OneD\_TVDLF\_Mesh@{OneD\_TVDLF\_Mesh}}
\index{OneD\_TVDLF\_Mesh@{OneD\_TVDLF\_Mesh}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{OneD\_TVDLF\_Mesh()}
{\footnotesize\ttfamily Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{X,  }\item[{\textbf{ One\+D\+\_\+\+Hyperbolic\+\_\+\+System} $\ast$}]{ptr,  }\item[{fn\+\_\+ptr}]{init\+\_\+ptr }\end{DoxyParamCaption})}



Constructor for the Finite Volume Mesh using linear elements. 


\begin{DoxyParams}{Parameters}
{\em X} & A vector of nodal locations at which the element F\+A\+C\+ES will positioned \\
\hline
{\em ptr} & A pointer to the hyperbolic system applied to this mesh \\
\hline
{\em init\+\_\+ptr} & A pointer to a function that defines the initial conditions\\
\hline
{\em X} & A vector of nodal locations at which the element F\+A\+C\+ES will positioned \\
\hline
\end{DoxyParams}


Definition at line 17 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{19                                                     \{}
\DoxyCodeLine{20     MESH\_TIME = 0.0;}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{22     std::cout << \textcolor{stringliteral}{"DEBUG: Starting construction of a OneD\_TVDLF\_Mesh object. \(\backslash\)n"};}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{24     \textcolor{keywordtype}{unsigned} N = X.size();}
\DoxyCodeLine{25     \textcolor{keywordflow}{if}(N <= 2) \{}
\DoxyCodeLine{26       std::string problem;}
\DoxyCodeLine{27       problem = \textcolor{stringliteral}{" The OneD\_TVDLF\_Mesh object is trying to construct itself \(\backslash\)n"};}
\DoxyCodeLine{28       problem += \textcolor{stringliteral}{" with just one element! \(\backslash\)n"};}
\DoxyCodeLine{29       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{30     \}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{32     std::cout << \textcolor{stringliteral}{"\(\backslash\)nDEBUG: configuration of the black mesh \(\backslash\)n"};}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{34     \textcolor{comment}{// set up the fn ptr to the initial conditions fn}}
\DoxyCodeLine{35     p\_Q\_INIT = init\_ptr;}
\DoxyCodeLine{36     \textcolor{comment}{// store the order of the conservative system here for simplicity}}
\DoxyCodeLine{37     ORDER\_OF\_SYSTEM = ptr -\/> get\_order();}
\DoxyCodeLine{38 }
\DoxyCodeLine{39     \textcolor{comment}{// set up the black elements}}
\DoxyCodeLine{40     \{}
\DoxyCodeLine{41       \textcolor{comment}{// first elt}}
\DoxyCodeLine{42       BLACK\_ELTS.push\_back(OneD\_TVDLF\_Elt(X[0], X[1], ptr, \textcolor{keyword}{true}, -\/1));}
\DoxyCodeLine{43       \textcolor{keywordflow}{for}(std::size\_t i = 1; i <= N -\/ 3; ++i) \{}
\DoxyCodeLine{44         \textcolor{comment}{// interior elts}}
\DoxyCodeLine{45         BLACK\_ELTS.push\_back(OneD\_TVDLF\_Elt(X[i], X[i+1], ptr));}
\DoxyCodeLine{46       \}}
\DoxyCodeLine{47       \textcolor{comment}{// last elt}}
\DoxyCodeLine{48       BLACK\_ELTS.push\_back(OneD\_TVDLF\_Elt(X[N-\/2], X[N-\/1], ptr, \textcolor{keyword}{true}, 1));}
\DoxyCodeLine{49     \}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{51     std::cout << \textcolor{stringliteral}{"\(\backslash\)nDEBUG: configuration of the red mesh \(\backslash\)n"};}
\DoxyCodeLine{52 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{53     \textcolor{comment}{// set up the red elements}}
\DoxyCodeLine{54     \{}
\DoxyCodeLine{55       \textcolor{comment}{// first elt}}
\DoxyCodeLine{56       RED\_ELTS.push\_back(OneD\_TVDLF\_Elt(X[0], (X[1] + X[0]) / 2, ptr, \textcolor{keyword}{true}, -\/1));}
\DoxyCodeLine{57       \textcolor{comment}{// interior elts}}
\DoxyCodeLine{58       \textcolor{keywordflow}{for}(std::size\_t i = 1; i <= N -\/ 2; ++i) \{}
\DoxyCodeLine{59         \textcolor{comment}{// interior elts}}
\DoxyCodeLine{60         RED\_ELTS.push\_back(OneD\_TVDLF\_Elt((X[i-\/1] + X[i]) / 2, (X[i] + X[i+1]) / 2, ptr));}
\DoxyCodeLine{61       \}}
\DoxyCodeLine{62       \textcolor{comment}{// last elt}}
\DoxyCodeLine{63       RED\_ELTS.push\_back(OneD\_TVDLF\_Elt((X[N-\/2] + X[N-\/1]) / 2, X[N-\/1], ptr, \textcolor{keyword}{true}, 1));}
\DoxyCodeLine{64     \}}
\DoxyCodeLine{65 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{66     std::cout << \textcolor{stringliteral}{"\(\backslash\)nDEBUG: linking the two meshes \(\backslash\)n"};}
\DoxyCodeLine{67 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{68     \textcolor{comment}{// the only tricky part for this scheme is the mesh interconnections}}
\DoxyCodeLine{69     \textcolor{comment}{// black to red is easy enough}}
\DoxyCodeLine{70     elt\_iter er = RED\_ELTS.begin();}
\DoxyCodeLine{71     elt\_iter eb = BLACK\_ELTS.begin();}
\DoxyCodeLine{72     DenseVector<double> s\_left(2, 0.);}
\DoxyCodeLine{73     s\_left[ 0 ] = -\/1.;}
\DoxyCodeLine{74     s\_left[ 1 ] = 0.;}
\DoxyCodeLine{75     DenseVector<double> s\_right(2, 0.);}
\DoxyCodeLine{76     s\_right[ 0 ] = 0.;}
\DoxyCodeLine{77     s\_right[ 1 ] = 1.;}
\DoxyCodeLine{78     DenseVector<double> s\_whole(2, 0.);}
\DoxyCodeLine{79     s\_whole[ 0 ] = -\/1.;}
\DoxyCodeLine{80     s\_whole[ 1 ] = 1.;}
\DoxyCodeLine{81     DenseVector<double> s\_gen(2, 0.);}
\DoxyCodeLine{82     \textcolor{comment}{// loop over red elts -\/-\/ and define which black elts contribute}}
\DoxyCodeLine{83     \textcolor{comment}{// this is straightforward, even for nonuniform meshes.}}
\DoxyCodeLine{84     \textcolor{keywordflow}{while}(er != RED\_ELTS.end()) \{}
\DoxyCodeLine{85       \textcolor{keywordflow}{if}(er -\/> get\_external\_flag()) \{}
\DoxyCodeLine{86         \textcolor{comment}{// if its an external elt}}
\DoxyCodeLine{87         \textcolor{keywordflow}{if}(er -\/> get\_external\_face\_i() < 0) \{}
\DoxyCodeLine{88           \textcolor{comment}{// and external face is left}}
\DoxyCodeLine{89           er -\/> add\_contribution(\&(*eb), s\_left, 1);}
\DoxyCodeLine{90           ++er;}
\DoxyCodeLine{91         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{92           \textcolor{comment}{// and external face is right}}
\DoxyCodeLine{93           er -\/> add\_contribution(\&(*eb), s\_right, -\/1);}
\DoxyCodeLine{94           ++er;}
\DoxyCodeLine{95         \}}
\DoxyCodeLine{96       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{97         \textcolor{comment}{//internal elt}}
\DoxyCodeLine{98         er -\/> add\_contribution(\&(*eb), s\_right, -\/1);}
\DoxyCodeLine{99         ++eb;}
\DoxyCodeLine{100         er -\/> add\_contribution(\&(*eb), s\_left, 1);}
\DoxyCodeLine{101         ++er;}
\DoxyCodeLine{102       \}}
\DoxyCodeLine{103     \}}
\DoxyCodeLine{104     \textcolor{comment}{// loop over all black elts and define which red elts contribute}}
\DoxyCodeLine{105     \textcolor{comment}{// this is more involved if we allow for non-\/uniform meshes.}}
\DoxyCodeLine{106     eb = BLACK\_ELTS.begin();}
\DoxyCodeLine{107     er = RED\_ELTS.begin();}
\DoxyCodeLine{108     \textcolor{keywordflow}{while}(eb != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{109       \textcolor{keywordflow}{if}(eb -\/> get\_external\_flag()) \{}
\DoxyCodeLine{110         \textcolor{comment}{// if its an external elt}}
\DoxyCodeLine{111         \textcolor{keywordflow}{if}(eb -\/> get\_external\_face\_i() < 0) \{}
\DoxyCodeLine{112           \textcolor{comment}{// and external face is left}}
\DoxyCodeLine{113           eb -\/> add\_contribution(\&(*er), s\_whole, 0);}
\DoxyCodeLine{114           ++er;}
\DoxyCodeLine{115           \textcolor{keywordtype}{double} s = er -\/> get\_s(eb -\/> get\_x(1.0));}
\DoxyCodeLine{116           s\_gen[ 0 ] = -\/1.0;}
\DoxyCodeLine{117           s\_gen[ 1 ] = s;}
\DoxyCodeLine{118           eb -\/> add\_contribution(\&(*er), s\_gen, 1);}
\DoxyCodeLine{119           ++eb;}
\DoxyCodeLine{120         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{121           \textcolor{comment}{// and external face is right}}
\DoxyCodeLine{122           \textcolor{keywordtype}{double} s = er -\/> get\_s(eb -\/> get\_x(-\/1.0));}
\DoxyCodeLine{123           s\_gen[ 0 ] = s;}
\DoxyCodeLine{124           s\_gen[ 1 ] = 1.0;}
\DoxyCodeLine{125           eb -\/> add\_contribution(\&(*er), s\_gen, -\/1);}
\DoxyCodeLine{126           ++er;}
\DoxyCodeLine{127           eb -\/> add\_contribution(\&(*er), s\_whole, 0);}
\DoxyCodeLine{128           ++eb;}
\DoxyCodeLine{129         \}}
\DoxyCodeLine{130       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{131         \textcolor{comment}{// internal elt}}
\DoxyCodeLine{132         \textcolor{keywordtype}{double} s = er -\/> get\_s(eb -\/> get\_x(-\/1.0));}
\DoxyCodeLine{133         s\_gen[ 0 ] = s;}
\DoxyCodeLine{134         s\_gen[ 1 ] = 1.0;}
\DoxyCodeLine{135         eb -\/> add\_contribution(\&(*er), s\_gen, -\/1);}
\DoxyCodeLine{136         ++er;}
\DoxyCodeLine{137         s = er -\/> get\_s(eb -\/> get\_x(1.0));}
\DoxyCodeLine{138         s\_gen[ 0 ] = -\/1.0;}
\DoxyCodeLine{139         s\_gen[ 1 ] = s;}
\DoxyCodeLine{140         eb -\/> add\_contribution(\&(*er), s\_gen, 1);}
\DoxyCodeLine{141         ++eb;}
\DoxyCodeLine{142       \}}
\DoxyCodeLine{143     \}}
\DoxyCodeLine{144 }
\DoxyCodeLine{145 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{146     std::cout << \textcolor{stringliteral}{"DEBUG: Setting the initial state of the meesh. \(\backslash\)n"};}
\DoxyCodeLine{147 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{148     \textcolor{comment}{// set the initial condition for each elt}}
\DoxyCodeLine{149     eb = BLACK\_ELTS.begin();}
\DoxyCodeLine{150     \textcolor{keywordflow}{while}(eb != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{151       DenseVector<double> Q(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{152       p\_Q\_INIT(eb -\/> get\_x(0.0), Q);}
\DoxyCodeLine{153       eb -\/> set\_Q\_mid(Q);}
\DoxyCodeLine{154       ++eb;}
\DoxyCodeLine{155     \}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157     \textcolor{comment}{//eb = BLACK\_ELTS.end();}}
\DoxyCodeLine{158     \textcolor{comment}{//-\/-\/eb;}}
\DoxyCodeLine{159     \textcolor{comment}{//std::cout << "Last elt = " << eb -\/> get\_Q( 0.0 )[ 1 ] << "\(\backslash\)n";}}
\DoxyCodeLine{160     \textcolor{comment}{//std::cout << "size = " << eb -\/> get\_dx() << "\(\backslash\)n";}}
\DoxyCodeLine{161     \textcolor{comment}{//-\/-\/eb;}}
\DoxyCodeLine{162     \textcolor{comment}{//std::cout << "Last elt = " << eb -\/> get\_Q( 0.0 )[ 1 ] << "\(\backslash\)n";}}
\DoxyCodeLine{163     \textcolor{comment}{//std::cout << "size = " << eb -\/> get\_dx() << "\(\backslash\)n";}}
\DoxyCodeLine{164 }
\DoxyCodeLine{165     \textcolor{comment}{//DenseVector<double> x( get\_mid\_node\_vector() );}}
\DoxyCodeLine{166     \textcolor{comment}{//OneD\_Mesh<double> soln( x );}}
\DoxyCodeLine{167     \textcolor{comment}{//soln.set\_nvars( ORDER\_OF\_SYSTEM );}}
\DoxyCodeLine{168     \textcolor{comment}{//for ( std::size\_t i = 0; i < x.size(); ++i )}}
\DoxyCodeLine{169     \textcolor{comment}{//\{}}
\DoxyCodeLine{170     \textcolor{comment}{//soln.set\_nodes\_vars( i, BLACK\_ELTS[i].get\_Q( 0.0 ) );}}
\DoxyCodeLine{171     \textcolor{comment}{//std::cout << "Get\_soln Q = " << soln.get\_nodes\_vars( i )[ 1 ] << " at x = " << x[i] << "\(\backslash\)n";}}
\DoxyCodeLine{172     \textcolor{comment}{//\}}}
\DoxyCodeLine{173 }
\DoxyCodeLine{174     \textcolor{comment}{// default limiter = 0 (minmod)}}
\DoxyCodeLine{175     LIMITER = 0;}
\DoxyCodeLine{176     calc\_slopes(\&BLACK\_ELTS);}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{179     std::cout << \textcolor{stringliteral}{"DEBUG: Finished construction of a OneD\_TVDLF\_Mesh object. \(\backslash\)n"};}
\DoxyCodeLine{180 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{181   \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Example\+::s, and Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::size().

\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_a84dd11420dd436b7ef4d47d0e275ded1}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!````~OneD\_TVDLF\_Mesh@{$\sim$OneD\_TVDLF\_Mesh}}
\index{````~OneD\_TVDLF\_Mesh@{$\sim$OneD\_TVDLF\_Mesh}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{$\sim$OneD\_TVDLF\_Mesh()}
{\footnotesize\ttfamily Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::$\sim$\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Empty desctructor. 



Definition at line 183 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{184   \{\}}

\end{DoxyCode}


\doxysubsubsection{Member Function Documentation}
\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_afc087f286b4260906cae76e924616325}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!get\_face\_pos\_vector@{get\_face\_pos\_vector}}
\index{get\_face\_pos\_vector@{get\_face\_pos\_vector}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{get\_face\_pos\_vector()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+face\+\_\+pos\+\_\+vector (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Get the positions of the element faces. 

\begin{DoxyReturn}{Returns}
An N\+Vector$<$double$>$ of the spatial points 
\end{DoxyReturn}


Definition at line 196 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{196                                                                  \{}
\DoxyCodeLine{197     DenseVector<double> X;}
\DoxyCodeLine{198     celt\_iter e = BLACK\_ELTS.begin();}
\DoxyCodeLine{199     \textcolor{keywordflow}{while}(e != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{200       X.push\_back(e -\/> get\_x(-\/1.0));}
\DoxyCodeLine{201       ++e;}
\DoxyCodeLine{202     \}}
\DoxyCodeLine{203     -\/-\/e;}
\DoxyCodeLine{204     X.push\_back(e -\/> get\_x(1.0));}
\DoxyCodeLine{205     \textcolor{keywordflow}{return} X;}
\DoxyCodeLine{206   \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::push\+\_\+back().



Referenced by get\+\_\+soln().

\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_a8dddd9a76c1c5769b4cee27f44ba66ca}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!get\_mid\_node\_vector@{get\_mid\_node\_vector}}
\index{get\_mid\_node\_vector@{get\_mid\_node\_vector}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{get\_mid\_node\_vector()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+mid\+\_\+node\+\_\+vector (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Get the nodal positions in the middle of each element. 

\begin{DoxyReturn}{Returns}
An N\+Vector$<$double$>$ of the nodal points 
\end{DoxyReturn}


Definition at line 186 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{186                                                                  \{}
\DoxyCodeLine{187     DenseVector<double> X;}
\DoxyCodeLine{188     celt\_iter e = BLACK\_ELTS.begin();}
\DoxyCodeLine{189     \textcolor{keywordflow}{while}(e != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{190       X.push\_back(e -\/> get\_x(0.0));}
\DoxyCodeLine{191       ++e;}
\DoxyCodeLine{192     \}}
\DoxyCodeLine{193     \textcolor{keywordflow}{return} X;}
\DoxyCodeLine{194   \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::push\+\_\+back().



Referenced by get\+\_\+slope(), and get\+\_\+soln().

\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_a419296cb218f03282905193d2fa47080}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!get\_slope@{get\_slope}}
\index{get\_slope@{get\_slope}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{get\_slope()}
{\footnotesize\ttfamily \textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$double$>$ Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+slope (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 216 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{216                                        \{}
\DoxyCodeLine{217       vector\_of\_elts* elts(get\_elts\_from\_colour(\textcolor{stringliteral}{"black"}));}
\DoxyCodeLine{218       DenseVector<double> X(get\_mid\_node\_vector());}
\DoxyCodeLine{219       \textcolor{comment}{// the variables are the slope for each variable}}
\DoxyCodeLine{220       OneD\_Node\_Mesh<double> slope\_mesh(X, ORDER\_OF\_SYSTEM);}
\DoxyCodeLine{221       \textcolor{keywordflow}{for}(std::size\_t i = 0; i < X.size(); ++i) \{}
\DoxyCodeLine{222         slope\_mesh.set\_nodes\_vars(i, (*elts)[i].get\_slope());}
\DoxyCodeLine{223       \}}
\DoxyCodeLine{224       \textcolor{keywordflow}{return} slope\_mesh;}
\DoxyCodeLine{225     \}}

\end{DoxyCode}


References get\+\_\+mid\+\_\+node\+\_\+vector(), Cpp\+Noddy\+::\+One\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::set\+\_\+nodes\+\_\+vars(), and Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::size().



Referenced by update\+\_\+to\+\_\+black(), and update\+\_\+to\+\_\+red().

\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_a4f5df89734144eb86e919709845d3d63}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!get\_soln@{get\_soln}}
\index{get\_soln@{get\_soln}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{get\_soln()}
{\footnotesize\ttfamily \textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ double $>$ Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+soln (\begin{DoxyParamCaption}\item[{std\+::string}]{location = {\ttfamily \char`\"{}centre\char`\"{}},  }\item[{std\+::string}]{colour = {\ttfamily \char`\"{}black\char`\"{}} }\end{DoxyParamCaption})}



Get a One\+D\+\_\+\+Mesh$<$double$>$ object containing the one dimensional data in the usual format. 


\begin{DoxyParams}{Parameters}
{\em location} & Use \char`\"{}centre\char`\"{} for mid-\/elt values and \char`\"{}face\+\_\+average\char`\"{} for the average values at the (discontinuous) element boundaries \\
\hline
{\em colour} & Which mesh to output, unless debugging, this should be \char`\"{}black\char`\"{} otherwise time values will be slightly out \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The required mesh object 
\end{DoxyReturn}


Definition at line 238 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{238                                                                                             \{}
\DoxyCodeLine{239     vector\_of\_elts* elts(get\_elts\_from\_colour(mesh\_colour));}
\DoxyCodeLine{240     OneD\_Node\_Mesh<double> soln;}
\DoxyCodeLine{241     \textcolor{keywordflow}{if}(location == \textcolor{stringliteral}{"centre"}) \{}
\DoxyCodeLine{242       DenseVector<double> X(get\_mid\_node\_vector());}
\DoxyCodeLine{243       soln = OneD\_Node\_Mesh<double>(X, ORDER\_OF\_SYSTEM);}
\DoxyCodeLine{244       \textcolor{keywordflow}{for}(std::size\_t i = 0; i < X.size(); ++i) \{}
\DoxyCodeLine{245         soln.set\_nodes\_vars(i, (*elts)[i].get\_Q(0.0));}
\DoxyCodeLine{246       \}}
\DoxyCodeLine{247     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(location == \textcolor{stringliteral}{"face\_average"}) \{}
\DoxyCodeLine{248       DenseVector<double> X(get\_face\_pos\_vector());}
\DoxyCodeLine{249       soln = OneD\_Node\_Mesh<double>(X, ORDER\_OF\_SYSTEM);}
\DoxyCodeLine{250       std::size\_t N = X.size() -\/ 1;}
\DoxyCodeLine{251       soln.set\_nodes\_vars(0, (*elts)[0].get\_Q(-\/1.0));}
\DoxyCodeLine{252       \textcolor{keywordflow}{for}(std::size\_t i = 1; i < N; ++i) \{}
\DoxyCodeLine{253         soln.set\_nodes\_vars(i, ((*elts)[i-\/1].get\_Q(1.0) + (*elts)[i].get\_Q(-\/1.0)) / 2);}
\DoxyCodeLine{254       \}}
\DoxyCodeLine{255       soln.set\_nodes\_vars(N, (*elts)[N-\/1].get\_Q(1.0));}
\DoxyCodeLine{256     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{257       std::string problem;}
\DoxyCodeLine{258       problem = \textcolor{stringliteral}{" In OneD\_TVDLF\_Mesh::get\_soln you have passed an unrecognised "};}
\DoxyCodeLine{259       problem += \textcolor{stringliteral}{" location for data output. Use 'centre' or 'face\_average'. \(\backslash\)n"};}
\DoxyCodeLine{260       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{261     \}}
\DoxyCodeLine{262 }
\DoxyCodeLine{263     \textcolor{keywordflow}{return} soln;}
\DoxyCodeLine{264   \}}

\end{DoxyCode}


References get\+\_\+face\+\_\+pos\+\_\+vector(), get\+\_\+mid\+\_\+node\+\_\+vector(), Cpp\+Noddy\+::\+One\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::set\+\_\+nodes\+\_\+vars(), and Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::size().



Referenced by main().

\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_a468497d265d300b375f297f7aabec30a}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!get\_time@{get\_time}}
\index{get\_time@{get\_time}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{get\_time()}
{\footnotesize\ttfamily const double \& Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+time (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Get a const reference to the time value for the current mesh. 

\begin{DoxyReturn}{Returns}
time The time level at which the data in the mesh applies. 
\end{DoxyReturn}


Definition at line 224 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{224                                                 \{}
\DoxyCodeLine{225     \textcolor{keywordflow}{return} MESH\_TIME;}
\DoxyCodeLine{226   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_ab36b9f4ee791d627acc95aecf9c35e1f}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!integrate@{integrate}}
\index{integrate@{integrate}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{integrate()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::integrate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Integrate the concentration values across the entire mesh. 

\begin{DoxyReturn}{Returns}
The values of the integral of each component. 
\end{DoxyReturn}


Definition at line 228 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{228                                                        \{}
\DoxyCodeLine{229     celt\_iter e = BLACK\_ELTS.begin();}
\DoxyCodeLine{230     DenseVector<double> sum(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{231     \textcolor{keywordflow}{while}(e != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{232       sum += e -\/> get\_Q(0.0) * e -\/> get\_dx();}
\DoxyCodeLine{233       ++e;}
\DoxyCodeLine{234     \}}
\DoxyCodeLine{235     \textcolor{keywordflow}{return} sum;}
\DoxyCodeLine{236   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_a954a004f86deb45b38a46d282f6fea4c}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!set\_limiter@{set\_limiter}}
\index{set\_limiter@{set\_limiter}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{set\_limiter()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::set\+\_\+limiter (\begin{DoxyParamCaption}\item[{unsigned}]{id }\end{DoxyParamCaption})}



Set the limiter type to be applied in the slope values. 

0 is no limiter, 1 is Lax-\/\+Wendroff, 2 is Beam-\/\+Warming, 3 is MC and 4 is Superbee. 
\begin{DoxyParams}{Parameters}
{\em id} & The identifier of the limiter. \\
\hline
\end{DoxyParams}


Definition at line 208 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{208                                                \{}
\DoxyCodeLine{209     LIMITER = id;}
\DoxyCodeLine{210   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_a8904a6107bad841297d5dcf8c747e37b}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!update@{update}}
\index{update@{update}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{update()}
{\footnotesize\ttfamily double Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::update (\begin{DoxyParamCaption}\item[{const double \&}]{C\+FL,  }\item[{const double \&}]{max\+\_\+dt = {\ttfamily std\+:\+:numeric\+\_\+limits$<$long~double$>$\+:\+:max()} }\end{DoxyParamCaption})}



Update all the elements in this mesh to a new time step. 


\begin{DoxyParams}{Parameters}
{\em C\+FL} & The C\+FL value to be used to determine the time step \\
\hline
{\em max\+\_\+dt} & Do not take a time step larger than this irrespective of the C\+FL value \\
\hline
\end{DoxyParams}


Definition at line 212 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{212                                                                         \{}
\DoxyCodeLine{213     \textcolor{keywordtype}{double} first\_dt = update\_to\_red(CFL, max\_dt / 2.0);}
\DoxyCodeLine{214     \textcolor{keywordtype}{double} second\_dt = update\_to\_black(CFL, max\_dt -\/ first\_dt);}
\DoxyCodeLine{215     \textcolor{keywordflow}{return} first\_dt + second\_dt;}
\DoxyCodeLine{216   \}}

\end{DoxyCode}


References update\+\_\+to\+\_\+black(), and update\+\_\+to\+\_\+red().



Referenced by main(), and update\+\_\+to().

\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_a374d97acf8ffe1a853ac7f602c401c92}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!update\_to@{update\_to}}
\index{update\_to@{update\_to}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{update\_to()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::update\+\_\+to (\begin{DoxyParamCaption}\item[{const double \&}]{C\+FL,  }\item[{const double \&}]{t\+\_\+end }\end{DoxyParamCaption})}



Update all the elements in this mesh to a U\+S\+ER S\+P\+E\+C\+I\+F\+I\+ED time step. 


\begin{DoxyParams}{Parameters}
{\em C\+FL} & The C\+FL value to be used to determine the time step \\
\hline
{\em t\+\_\+end} & The time level to compute to \\
\hline
\end{DoxyParams}


Definition at line 218 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{218                                                                         \{}
\DoxyCodeLine{219     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{220       update(CFL, std::abs(t\_end -\/ MESH\_TIME));}
\DoxyCodeLine{221     \} \textcolor{keywordflow}{while}(MESH\_TIME < t\_end);}
\DoxyCodeLine{222   \}}

\end{DoxyCode}


References update().

\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_a5098325b6377f8157f328e1f2942ed67}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!update\_to\_black@{update\_to\_black}}
\index{update\_to\_black@{update\_to\_black}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{update\_to\_black()}
{\footnotesize\ttfamily double Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::update\+\_\+to\+\_\+black (\begin{DoxyParamCaption}\item[{const double \&}]{C\+FL,  }\item[{const double \&}]{max\+\_\+dt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 133 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{133                                                                     \{}
\DoxyCodeLine{134       \textcolor{comment}{// integrate the red mesh data back onto the black mesh}}
\DoxyCodeLine{135       \{}
\DoxyCodeLine{136         elt\_iter eb = BLACK\_ELTS.begin();}
\DoxyCodeLine{137         \textcolor{keywordflow}{while}(eb != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{138           eb -\/> set\_Q\_mid(eb -\/> contributed\_Q() / eb -\/> get\_dx());}
\DoxyCodeLine{139           ++eb;}
\DoxyCodeLine{140         \}}
\DoxyCodeLine{141       \}}
\DoxyCodeLine{142       \textcolor{comment}{// step thru the red elements to find a max time step}}
\DoxyCodeLine{143       \textcolor{keywordtype}{double} second\_dt;}
\DoxyCodeLine{144       \{}
\DoxyCodeLine{145         elt\_iter er = RED\_ELTS.begin();}
\DoxyCodeLine{146         second\_dt = er -\/> get\_max\_dt();}
\DoxyCodeLine{147         ++er;}
\DoxyCodeLine{148         \textcolor{keywordflow}{while}(er != RED\_ELTS.end()) \{}
\DoxyCodeLine{149           second\_dt = std::min(second\_dt, er -\/> get\_max\_dt());}
\DoxyCodeLine{150           ++er;}
\DoxyCodeLine{151         \}}
\DoxyCodeLine{152         second\_dt *= CFL;}
\DoxyCodeLine{153       \}}
\DoxyCodeLine{154       \textcolor{keywordflow}{if}(second\_dt > max\_dt) \{}
\DoxyCodeLine{155         second\_dt = max\_dt;}
\DoxyCodeLine{156       \}}
\DoxyCodeLine{157 }
\DoxyCodeLine{158       calc\_slopes(\&BLACK\_ELTS);}
\DoxyCodeLine{159       \textcolor{comment}{// compute the fluxes through the element boundaries}}
\DoxyCodeLine{160       \textcolor{comment}{// in the black mesh, using the nodal values of the red mesh}}
\DoxyCodeLine{161       \textcolor{comment}{// then update the concentrations in the black mesh elements}}
\DoxyCodeLine{162       \{}
\DoxyCodeLine{163         elt\_iter eb = BLACK\_ELTS.begin();}
\DoxyCodeLine{164         DenseVector<double> flux\_in\_left(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{165         DenseVector<double> flux\_out\_right(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{166         \textcolor{comment}{// start with the left most elt \& work out the flux in from the left}}
\DoxyCodeLine{167         eb -\/> contributed\_flux\_in\_left(second\_dt, flux\_in\_left, MESH\_TIME);}
\DoxyCodeLine{168         \textcolor{keywordflow}{while}(eb != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{169           \textcolor{comment}{// work out the flux out to the right}}
\DoxyCodeLine{170           eb -\/> contributed\_flux\_out\_right(second\_dt, flux\_out\_right, MESH\_TIME);}
\DoxyCodeLine{171           \textcolor{comment}{// we now have the flux difference}}
\DoxyCodeLine{172           DenseVector<double> deltaQ = (flux\_in\_left -\/ flux\_out\_right) * second\_dt / eb -\/> get\_dx();}
\DoxyCodeLine{173           \textcolor{comment}{// contribution from the source integral}}
\DoxyCodeLine{174           \{}
\DoxyCodeLine{175             \textcolor{keywordtype}{double} x\_mid(eb -\/> get\_x(0.0));}
\DoxyCodeLine{176             DenseVector<double> q\_mid(eb -\/> get\_Q(0.0));}
\DoxyCodeLine{177             DenseVector<double> slope(eb -\/> get\_slope());}
\DoxyCodeLine{178             q\_mid += (eb -\/> get\_source\_fn(0.0)}
\DoxyCodeLine{179                       -\/ eb -\/> get\_Jac\_flux\_fn(0.0).multiply(slope)) * 0.5 * second\_dt;}
\DoxyCodeLine{180             DenseVector<double> r\_mid(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{181             eb -\/> system\_ptr -\/> source\_fn(x\_mid, q\_mid, slope, r\_mid);}
\DoxyCodeLine{182             deltaQ += r\_mid * second\_dt;}
\DoxyCodeLine{183           \}}
\DoxyCodeLine{184           eb -\/> set\_Q\_mid(eb -\/> get\_Q(0.0) + deltaQ);}
\DoxyCodeLine{185           \textcolor{comment}{// the flux out right in this elt is the flux in left of the next one}}
\DoxyCodeLine{186           flux\_in\_left = flux\_out\_right;}
\DoxyCodeLine{187           ++eb;}
\DoxyCodeLine{188         \}}
\DoxyCodeLine{189       \}}
\DoxyCodeLine{190 }
\DoxyCodeLine{191       \textcolor{comment}{// compute the slopes using the specified limiter}}
\DoxyCodeLine{192       \textcolor{comment}{// for the black elements}}
\DoxyCodeLine{193       calc\_slopes(\&BLACK\_ELTS);}
\DoxyCodeLine{194       MESH\_TIME += second\_dt;}
\DoxyCodeLine{195       \textcolor{keywordflow}{return} second\_dt;}
\DoxyCodeLine{196 }
\DoxyCodeLine{197     \}}

\end{DoxyCode}


References get\+\_\+slope(), and Cpp\+Noddy\+::\+Example\+::source\+\_\+fn().



Referenced by update().

\mbox{\label{classCppNoddy_1_1OneD__TVDLF__Mesh_a721b0a00aa16cda4677ea605564a08a7}} 
\index{CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}!update\_to\_red@{update\_to\_red}}
\index{update\_to\_red@{update\_to\_red}!CppNoddy::OneD\_TVDLF\_Mesh@{CppNoddy::OneD\_TVDLF\_Mesh}}
\doxyparagraph{update\_to\_red()}
{\footnotesize\ttfamily double Cpp\+Noddy\+::\+One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::update\+\_\+to\+\_\+red (\begin{DoxyParamCaption}\item[{const double \&}]{C\+FL,  }\item[{const double \&}]{max\+\_\+dt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 65 of file One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{65                                                                   \{}
\DoxyCodeLine{66       \textcolor{comment}{// the black mesh slopes are set in the constructor}}
\DoxyCodeLine{67       \textcolor{comment}{// and at the end of every 'update' call}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69       \textcolor{comment}{// integrate the black mesh data onto the red mesh}}
\DoxyCodeLine{70       \{}
\DoxyCodeLine{71         elt\_iter er = RED\_ELTS.begin();}
\DoxyCodeLine{72         \textcolor{keywordflow}{while}(er != RED\_ELTS.end()) \{}
\DoxyCodeLine{73           er -\/> set\_Q\_mid(er -\/> contributed\_Q() / er -\/> get\_dx());}
\DoxyCodeLine{74           ++er;}
\DoxyCodeLine{75         \}}
\DoxyCodeLine{76       \}}
\DoxyCodeLine{77 }
\DoxyCodeLine{78       \textcolor{comment}{// step thru the black elements to find a max time step}}
\DoxyCodeLine{79       \textcolor{keywordtype}{double} first\_dt;}
\DoxyCodeLine{80       \{}
\DoxyCodeLine{81         elt\_iter eb = BLACK\_ELTS.begin();}
\DoxyCodeLine{82         first\_dt = eb -\/> get\_max\_dt();}
\DoxyCodeLine{83         ++eb;}
\DoxyCodeLine{84         \textcolor{keywordflow}{while}(eb != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{85           first\_dt = std::min(first\_dt, eb -\/> get\_max\_dt());}
\DoxyCodeLine{86           ++eb;}
\DoxyCodeLine{87         \}}
\DoxyCodeLine{88         first\_dt *= CFL;}
\DoxyCodeLine{89       \}}
\DoxyCodeLine{90       \textcolor{keywordflow}{if}(first\_dt > max\_dt) \{}
\DoxyCodeLine{91         first\_dt = max\_dt;}
\DoxyCodeLine{92       \}}
\DoxyCodeLine{93 }
\DoxyCodeLine{94       calc\_slopes(\&RED\_ELTS);}
\DoxyCodeLine{95       \textcolor{comment}{// compute the fluxes through the element boundaries}}
\DoxyCodeLine{96       \textcolor{comment}{// in the red mesh, using the nodal values of the black mesh}}
\DoxyCodeLine{97       \textcolor{comment}{// then update the concentrations in the red mesh elements}}
\DoxyCodeLine{98       \{}
\DoxyCodeLine{99         elt\_iter er = RED\_ELTS.begin();}
\DoxyCodeLine{100         DenseVector<double> flux\_in\_left(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{101         DenseVector<double> flux\_out\_right(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{102         \textcolor{comment}{// start with the left most elt \& work out the flux in from the left}}
\DoxyCodeLine{103         er -\/> contributed\_flux\_in\_left(first\_dt, flux\_in\_left, MESH\_TIME);}
\DoxyCodeLine{104         \textcolor{keywordflow}{while}(er != RED\_ELTS.end()) \{}
\DoxyCodeLine{105           \textcolor{comment}{// work out the flux out to the right}}
\DoxyCodeLine{106           er -\/> contributed\_flux\_out\_right(first\_dt, flux\_out\_right, MESH\_TIME);}
\DoxyCodeLine{107           \textcolor{comment}{// we now have the flux difference}}
\DoxyCodeLine{108           DenseVector<double> deltaQ = (flux\_in\_left -\/ flux\_out\_right) * first\_dt / er -\/> get\_dx();}
\DoxyCodeLine{109           \textcolor{comment}{// contribution from the source integral}}
\DoxyCodeLine{110           \{}
\DoxyCodeLine{111             \textcolor{keywordtype}{double} x\_mid(er -\/> get\_x(0.0));}
\DoxyCodeLine{112             DenseVector<double> slope(er -\/> get\_slope());}
\DoxyCodeLine{113             DenseVector<double> q\_mid(er -\/> get\_Q(0.0));}
\DoxyCodeLine{114             q\_mid += (er -\/> get\_source\_fn(0.0)}
\DoxyCodeLine{115                       -\/ er -\/> get\_Jac\_flux\_fn(0.0).multiply(slope)) * 0.5 * first\_dt;}
\DoxyCodeLine{116             DenseVector<double> r\_mid(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{117             er -\/> system\_ptr -\/> source\_fn(x\_mid, q\_mid, slope, r\_mid);}
\DoxyCodeLine{118             deltaQ += r\_mid * first\_dt;}
\DoxyCodeLine{119           \}}
\DoxyCodeLine{120           er -\/> set\_Q\_mid(er -\/> get\_Q(0.0) + deltaQ);}
\DoxyCodeLine{121           \textcolor{comment}{// the flux out right in this elt is the flux in left of the next one}}
\DoxyCodeLine{122           flux\_in\_left = flux\_out\_right;}
\DoxyCodeLine{123           ++er;}
\DoxyCodeLine{124         \}}
\DoxyCodeLine{125       \}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127       \textcolor{comment}{// compute the slopes using the specified limiter for the red elements}}
\DoxyCodeLine{128       calc\_slopes(\&RED\_ELTS);}
\DoxyCodeLine{129       MESH\_TIME += first\_dt;}
\DoxyCodeLine{130       \textcolor{keywordflow}{return} first\_dt;}
\DoxyCodeLine{131     \}}

\end{DoxyCode}


References get\+\_\+slope(), and Cpp\+Noddy\+::\+Example\+::source\+\_\+fn().



Referenced by update().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/\textbf{ One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h}\item 
src/\textbf{ One\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp}\end{DoxyCompactItemize}
