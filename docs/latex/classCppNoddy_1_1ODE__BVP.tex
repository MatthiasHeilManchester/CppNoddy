\doxysubsection{Cpp\+Noddy\+::O\+D\+E\+\_\+\+B\+VP$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$ Class Template Reference}
\label{classCppNoddy_1_1ODE__BVP}\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}


A templated object for real/complex vector system of first-\/order ordinary differential equations.  




{\ttfamily \#include $<$O\+D\+E\+\_\+\+B\+V\+P.\+h$>$}

Inheritance diagram for Cpp\+Noddy\+::O\+D\+E\+\_\+\+B\+VP$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classCppNoddy_1_1ODE__BVP}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ O\+D\+E\+\_\+\+B\+VP} (\textbf{ Equation\+\_\+1matrix}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$ $\ast$ptr\+\_\+to\+\_\+equation, const \textbf{ Dense\+Vector}$<$ \+\_\+\+Xtype $>$ \&nodes, \textbf{ Residual}$<$ \+\_\+\+Type $>$ $\ast$ptr\+\_\+to\+\_\+left\+\_\+residual, \textbf{ Residual}$<$ \+\_\+\+Type $>$ $\ast$ptr\+\_\+to\+\_\+right\+\_\+residual)
\begin{DoxyCompactList}\small\item\em The class is defined by a vector function for the system. \end{DoxyCompactList}\item 
virtual \textbf{ $\sim$\+O\+D\+E\+\_\+\+B\+VP} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
virtual void \textbf{ actions\+\_\+before\+\_\+linear\+\_\+solve} (\textbf{ Banded\+Matrix}$<$ \+\_\+\+Type $>$ \&a, \textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \&b)
\begin{DoxyCompactList}\small\item\em A virtual method that is called prior to the linear solve stage of the \doxyref{solve2()}{p.}{classCppNoddy_1_1ODE__BVP_ae73d37efde211f342a3b611a49a47b6b} method. \end{DoxyCompactList}\item 
void \textbf{ solve2} ()
\begin{DoxyCompactList}\small\item\em Formulate and solve the O\+DE using \doxyref{Newton}{p.}{classCppNoddy_1_1Newton} iteration and a second-\/order finite difference scheme. \end{DoxyCompactList}\item 
std\+::pair$<$ unsigned, unsigned $>$ \textbf{ adapt} (const double \&adapt\+\_\+tol)
\begin{DoxyCompactList}\small\item\em Adapt the computational mesh O\+N\+CE. \end{DoxyCompactList}\item 
void \textbf{ adapt\+\_\+until} (const double \&adapt\+\_\+tol)
\begin{DoxyCompactList}\small\item\em Adaptively solve the system until no refinements or unrefinements are applied. \end{DoxyCompactList}\item 
void \textbf{ set\+\_\+monitor\+\_\+det} (bool flag)
\begin{DoxyCompactList}\small\item\em Set the flag that determines if the determinant will be monitored The default is to monitor. \end{DoxyCompactList}\item 
void \textbf{ init\+\_\+arc} (\+\_\+\+Type $\ast$\textbf{ p}, const double \&length, const double \&max\+\_\+length)
\begin{DoxyCompactList}\small\item\em Initialise the class ready for arc length continuation. \end{DoxyCompactList}\item 
double \textbf{ arclength\+\_\+solve} (const double \&step)
\begin{DoxyCompactList}\small\item\em Arc-\/length solve the system. \end{DoxyCompactList}\item 
\textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$ \& \textbf{ solution} ()
\item 
double \& \textbf{ tolerance} ()
\begin{DoxyCompactList}\small\item\em Access method to the tolerance. \end{DoxyCompactList}\item 
int \& \textbf{ max\+\_\+itns} ()
\begin{DoxyCompactList}\small\item\em Access method to the maximum number of iterations. \end{DoxyCompactList}\item 
std\+::pair$<$ unsigned, unsigned $>$ \textbf{ adapt} (const double \&adapt\+\_\+tol)
\item 
std\+::pair$<$ unsigned, unsigned $>$ \textbf{ adapt} (const double \&adapt\+\_\+tol)
\item 
void \textbf{ adapt\+\_\+until} (const double \&adapt\+\_\+tol)
\item 
void \textbf{ adapt\+\_\+until} (const double \&adapt\+\_\+tol)
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}


\doxysubsubsection{Detailed Description}
\subsubsection*{template$<$typename \+\_\+\+Type, typename \+\_\+\+Xtype = double$>$\newline
class Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+V\+P$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$}

A templated object for real/complex vector system of first-\/order ordinary differential equations. 

The class is double templated, with the first type associated with real/complex data, and second (real/complex) type associated with a problem on the real line or line in the complex plane. 

Definition at line 37 of file O\+D\+E\+\_\+\+B\+V\+P.\+h.



\doxysubsubsection{Constructor \& Destructor Documentation}
\mbox{\label{classCppNoddy_1_1ODE__BVP_ac0b6f7a075ce464b246b9350f359f598}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!ODE\_BVP@{ODE\_BVP}}
\index{ODE\_BVP@{ODE\_BVP}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{ODE\_BVP()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype $>$ \\
\textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::\textbf{ O\+D\+E\+\_\+\+B\+VP} (\begin{DoxyParamCaption}\item[{\textbf{ Equation\+\_\+1matrix}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$ $\ast$}]{ptr\+\_\+to\+\_\+equation,  }\item[{const \textbf{ Dense\+Vector}$<$ \+\_\+\+Xtype $>$ \&}]{nodes,  }\item[{\textbf{ Residual}$<$ \+\_\+\+Type $>$ $\ast$}]{ptr\+\_\+to\+\_\+left\+\_\+residual,  }\item[{\textbf{ Residual}$<$ \+\_\+\+Type $>$ $\ast$}]{ptr\+\_\+to\+\_\+right\+\_\+residual }\end{DoxyParamCaption})}



The class is defined by a vector function for the system. 


\begin{DoxyParams}{Parameters}
{\em ptr\+\_\+to\+\_\+equation} & A pointer to an \doxyref{Equation\+\_\+1matrix}{p.}{classCppNoddy_1_1Equation__1matrix} object. \\
\hline
{\em nodes} & A vector that defines the nodal positions. \\
\hline
{\em ptr\+\_\+to\+\_\+left\+\_\+residual} & A pointer to a residual object that defines the L\+HS boundary conditions. \\
\hline
{\em ptr\+\_\+to\+\_\+right\+\_\+residual} & A pointer to a residual object that defines the R\+HS boundary conditions. \\
\hline
\end{DoxyParams}


Definition at line 31 of file O\+D\+E\+\_\+\+B\+V\+P.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{34                                                                           :}
\DoxyCodeLine{35     ArcLength\_base<\_Type> (),}
\DoxyCodeLine{36     MAX\_ITERATIONS(12),}
\DoxyCodeLine{37     TOL(1.e-\/8),}
\DoxyCodeLine{38     LAST\_DET\_SIGN(0),}
\DoxyCodeLine{39     p\_EQUATION(ptr\_to\_equation),}
\DoxyCodeLine{40     p\_LEFT\_RESIDUAL(ptr\_to\_left\_residual),}
\DoxyCodeLine{41     p\_RIGHT\_RESIDUAL(ptr\_to\_right\_residual),}
\DoxyCodeLine{42     MONITOR\_DET(\textcolor{keyword}{true}) \{}
\DoxyCodeLine{43     \textcolor{comment}{// set up the solution mesh using these nodes}}
\DoxyCodeLine{44     SOLUTION = OneD\_Node\_Mesh<\_Type, \_Xtype>(nodes, p\_EQUATION -\/> get\_order());}
\DoxyCodeLine{45     \textcolor{keywordflow}{if}((p\_LEFT\_RESIDUAL -\/> get\_number\_of\_vars() != p\_EQUATION -\/> get\_order()) ||}
\DoxyCodeLine{46         (p\_RIGHT\_RESIDUAL -\/> get\_number\_of\_vars() != p\_EQUATION -\/> get\_order()) ||}
\DoxyCodeLine{47         (p\_LEFT\_RESIDUAL -\/> get\_order() + p\_RIGHT\_RESIDUAL -\/> get\_order() != p\_EQUATION -\/> get\_order())) \{}
\DoxyCodeLine{48       std::cout << \textcolor{stringliteral}{"order "} << p\_EQUATION -\/> get\_order() << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{49       std::cout << \textcolor{stringliteral}{"left nvars "} << p\_LEFT\_RESIDUAL -\/> get\_number\_of\_vars() << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{50       std::cout << \textcolor{stringliteral}{"right nvars "} << p\_RIGHT\_RESIDUAL -\/> get\_number\_of\_vars() << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{51       std::cout << \textcolor{stringliteral}{"left order "} << p\_LEFT\_RESIDUAL -\/> get\_order() << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{52       std::cout << \textcolor{stringliteral}{"right order "} << p\_RIGHT\_RESIDUAL -\/> get\_order() << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{53       std::string problem;}
\DoxyCodeLine{54       problem = \textcolor{stringliteral}{"It looks like the ODE\_BVP equation and boundary conditions are\(\backslash\)n"};}
\DoxyCodeLine{55       problem += \textcolor{stringliteral}{"not well posed. The number of variables for each boundary condition\(\backslash\)n"};}
\DoxyCodeLine{56       problem += \textcolor{stringliteral}{"has to be the same as the order of the equation. Also the order of\(\backslash\)n"};}
\DoxyCodeLine{57       problem += \textcolor{stringliteral}{"both boundary conditions has to sum to the order of the equation.\(\backslash\)n"};}
\DoxyCodeLine{58       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{59     \}}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#ifdef TIME}}
\DoxyCodeLine{61     \textcolor{comment}{// timers}}
\DoxyCodeLine{62     T\_ASSEMBLE = Timer(\textcolor{stringliteral}{"ODE\_BVP: Assembling of the matrix (incl. equation updates):"});}
\DoxyCodeLine{63     T\_SOLVE = Timer(\textcolor{stringliteral}{"ODE\_BVP: Solving of the matrix:"});}
\DoxyCodeLine{64     T\_REFINE = Timer(\textcolor{stringliteral}{"ODE\_BVP: Refining the mesh:"});}
\DoxyCodeLine{65 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{66   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1ODE__BVP_aa189ca7f4c5dc1021532c8eef57952b8}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!````~ODE\_BVP@{$\sim$ODE\_BVP}}
\index{````~ODE\_BVP@{$\sim$ODE\_BVP}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{$\sim$ODE\_BVP()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype $>$ \\
\textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::$\sim$\textbf{ O\+D\+E\+\_\+\+B\+VP}\hspace{0.3cm}{\ttfamily [virtual]}}



Destructor. 



Definition at line 69 of file O\+D\+E\+\_\+\+B\+V\+P.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{69                                    \{}
\DoxyCodeLine{70 \textcolor{preprocessor}{\#ifdef TIME}}
\DoxyCodeLine{71     std::cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{72     \textcolor{comment}{//T\_ASSEMBLE.stop();}}
\DoxyCodeLine{73     T\_ASSEMBLE.print();}
\DoxyCodeLine{74     \textcolor{comment}{//T\_SOLVE.stop();}}
\DoxyCodeLine{75     T\_SOLVE.print();}
\DoxyCodeLine{76     \textcolor{comment}{//T\_REFINE.stop();}}
\DoxyCodeLine{77     T\_REFINE.print();}
\DoxyCodeLine{78 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{79   \}}

\end{DoxyCode}


\doxysubsubsection{Member Function Documentation}
\mbox{\label{classCppNoddy_1_1ODE__BVP_a9e64aa28d03056b71b421619405375b6}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!actions\_before\_linear\_solve@{actions\_before\_linear\_solve}}
\index{actions\_before\_linear\_solve@{actions\_before\_linear\_solve}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{actions\_before\_linear\_solve()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype  = double$>$ \\
virtual void \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::actions\+\_\+before\+\_\+linear\+\_\+solve (\begin{DoxyParamCaption}\item[{\textbf{ Banded\+Matrix}$<$ \+\_\+\+Type $>$ \&}]{a,  }\item[{\textbf{ Dense\+Vector}$<$ \+\_\+\+Type $>$ \&}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



A virtual method that is called prior to the linear solve stage of the \doxyref{solve2()}{p.}{classCppNoddy_1_1ODE__BVP_ae73d37efde211f342a3b611a49a47b6b} method. 

This is called prior to any linear solve to allow the user to manually tune the matrix problem directly. 
\begin{DoxyParams}{Parameters}
{\em a} & The Jacbian matrix to be passed to the linear solver \\
\hline
{\em b} & The residual vector to be passed to the linear solver \\
\hline
\end{DoxyParams}


Definition at line 63 of file O\+D\+E\+\_\+\+B\+V\+P.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{64     \{\}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1ODE__BVP_ad5ef5d7dfc131a1b09fe231c11a89803}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!adapt@{adapt}}
\index{adapt@{adapt}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{adapt()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype $>$ \\
std\+::pair$<$ unsigned, unsigned $>$ \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::adapt (\begin{DoxyParamCaption}\item[{const double \&}]{adapt\+\_\+tol }\end{DoxyParamCaption})}



Adapt the computational mesh O\+N\+CE. 

We step through each interior node and evaluate the residual at that node. If the residual is less than the convergence tolerance, the node is removed. If the residual is greater than the adapt\+\_\+tol parameter, then the mesh is adapted with an addition node place either side of the evaluation node. 
\begin{DoxyParams}{Parameters}
{\em adapt\+\_\+tol} & The residual tolerance at a nodal point that will lead to the mesh adaptation. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pair of values indicating the number of refinements and unrefinements. 
\end{DoxyReturn}


Definition at line 481 of file O\+D\+E\+\_\+\+B\+V\+P.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{481                                                                                      \{}
\DoxyCodeLine{482 \textcolor{preprocessor}{\#ifdef TIME}}
\DoxyCodeLine{483     T\_REFINE.start();}
\DoxyCodeLine{484 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{485     \textcolor{comment}{// the order of the problem}}
\DoxyCodeLine{486     \textcolor{keywordtype}{unsigned} order(p\_EQUATION -\/> get\_order());}
\DoxyCodeLine{487     \textcolor{comment}{// get the number of nodes in the mesh}}
\DoxyCodeLine{488     \textcolor{comment}{// -\/-\/ this may have been refined by the user since the}}
\DoxyCodeLine{489     \textcolor{comment}{// last call.}}
\DoxyCodeLine{490     \textcolor{keywordtype}{unsigned} N(SOLUTION.get\_nnodes());}
\DoxyCodeLine{491     \textcolor{comment}{// row counter}}
\DoxyCodeLine{492     \textcolor{comment}{//std::size\_t row( 0 );}}
\DoxyCodeLine{493     \textcolor{comment}{// local state variable and functions}}
\DoxyCodeLine{494     DenseVector<\_Type> F\_node(order, 0.0);}
\DoxyCodeLine{495     DenseVector<\_Type> R\_node(order, 0.0);}
\DoxyCodeLine{496     \textcolor{comment}{// make sure (un)refine flags vector is sized}}
\DoxyCodeLine{497     std::vector< bool > refine(N, \textcolor{keyword}{false});}
\DoxyCodeLine{498     std::vector< bool > unrefine(N, \textcolor{keyword}{false});}
\DoxyCodeLine{499     \textcolor{comment}{// Residual vector at interior nodes}}
\DoxyCodeLine{500     DenseVector<double> Res2(N, 0.0);}
\DoxyCodeLine{501     \textcolor{comment}{// reset row counter}}
\DoxyCodeLine{502     \textcolor{comment}{//row = 0;}}
\DoxyCodeLine{503     \textcolor{comment}{// inner nodes of the mesh, node = 1,2,...,N-\/2}}
\DoxyCodeLine{504     \textcolor{keywordflow}{for}(std::size\_t node = 1; node <= N -\/ 2; node += 2) \{}
\DoxyCodeLine{505       \textcolor{comment}{// set the current solution at this node}}
\DoxyCodeLine{506       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var < order; ++var) \{}
\DoxyCodeLine{507         \textcolor{comment}{//F\_node[ var ] = SOLUTION[ var ][ node ];}}
\DoxyCodeLine{508         F\_node[ var ] = SOLUTION(node, var);}
\DoxyCodeLine{509       \}}
\DoxyCodeLine{510       \textcolor{comment}{// set the y-\/pos in the eqn}}
\DoxyCodeLine{511       p\_EQUATION -\/> coord(0) = SOLUTION.coord(node);}
\DoxyCodeLine{512       \textcolor{comment}{// Update the equation to the nodal position}}
\DoxyCodeLine{513       p\_EQUATION -\/> update(F\_node);\textcolor{comment}{}}
\DoxyCodeLine{514 \textcolor{comment}{      //// evaluate the RHS at the node}}
\DoxyCodeLine{515 \textcolor{comment}{}      \textcolor{comment}{//p\_EQUATION -\/> get\_residual( R\_node );}}
\DoxyCodeLine{516       \textcolor{comment}{// step size centred at the node}}
\DoxyCodeLine{517       \_Xtype invh = 1. / (SOLUTION.coord(node + 1) -\/ SOLUTION.coord(node -\/ 1));}
\DoxyCodeLine{518       \textcolor{comment}{// loop over all the variables}}
\DoxyCodeLine{519       DenseVector<\_Type> temp(order, 0.0);}
\DoxyCodeLine{520       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} var = 0; var < order; ++var) \{}
\DoxyCodeLine{521         \textcolor{comment}{// residual}}
\DoxyCodeLine{522         \textcolor{comment}{//temp[ var ] = p\_EQUATION -\/> residual()[ var ] -\/ ( SOLUTION[ var ][ node + 1 ] -\/ SOLUTION[ var ][ node -\/ 1 ] ) * invh;}}
\DoxyCodeLine{523         temp[ var ] = p\_EQUATION -\/> residual()[ var ] -\/ (SOLUTION(node + 1, var) -\/ SOLUTION(node -\/ 1, var)) * invh;}
\DoxyCodeLine{524       \}}
\DoxyCodeLine{525       Res2[ node ] = temp.inf\_norm();}
\DoxyCodeLine{526       \textcolor{keywordflow}{if}(Res2[ node ] > adapt\_tol) \{}
\DoxyCodeLine{527         refine[ node ] = \textcolor{keyword}{true};}
\DoxyCodeLine{528       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(Res2[ node ] < TOL / 10.) \{}
\DoxyCodeLine{529         unrefine[ node ] = \textcolor{keyword}{true};}
\DoxyCodeLine{530       \}}
\DoxyCodeLine{531     \}}
\DoxyCodeLine{532 }
\DoxyCodeLine{533     std::size\_t no\_refined(0), no\_unrefined(0);}
\DoxyCodeLine{534     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < refine.size(); ++i) \{}
\DoxyCodeLine{535       \textcolor{keywordflow}{if}(refine[ i ] == \textcolor{keyword}{true}) \{}
\DoxyCodeLine{536         no\_refined += 1;}
\DoxyCodeLine{537       \}}
\DoxyCodeLine{538       \textcolor{keywordflow}{if}(unrefine[ i ] == \textcolor{keyword}{true}) \{}
\DoxyCodeLine{539         no\_unrefined += 1;}
\DoxyCodeLine{540       \}}
\DoxyCodeLine{541     \}}
\DoxyCodeLine{542 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{543     std::cout << \textcolor{stringliteral}{"[ DEBUG ] Refinements = "} << no\_refined << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{544     std::cout << \textcolor{stringliteral}{"[ DEBUG ] Unrefinements = "} << no\_unrefined << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{545 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{546 }
\DoxyCodeLine{547     \textcolor{comment}{// make a new refined/unrefined mesh}}
\DoxyCodeLine{548     DenseVector<\_Xtype> X(SOLUTION.nodes());}
\DoxyCodeLine{549     DenseVector<\_Xtype> newX;}
\DoxyCodeLine{550     newX.push\_back(X[ 0 ]);}
\DoxyCodeLine{551     \textcolor{keywordflow}{for}(std::size\_t i = 1; i < N -\/ 1; ++i) \{}
\DoxyCodeLine{552       \textcolor{keywordflow}{if}(refine[ i ]) \{}
\DoxyCodeLine{553         \textcolor{keywordflow}{if}(!refine[ i -\/ 1 ]) \{}
\DoxyCodeLine{554           \textcolor{comment}{// have not already refined to the left}}
\DoxyCodeLine{555           \textcolor{comment}{// so refine left AND right with new nodes}}
\DoxyCodeLine{556           \_Xtype left(X[ i -\/ 1 ]);}
\DoxyCodeLine{557           \_Xtype right(X[ i + 1 ]);}
\DoxyCodeLine{558           \_Xtype here(X[ i ]);}
\DoxyCodeLine{559           newX.push\_back((left + here) / 2.);}
\DoxyCodeLine{560           newX.push\_back(here);}
\DoxyCodeLine{561           newX.push\_back((right + here) / 2.);}
\DoxyCodeLine{562         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{563           \textcolor{comment}{// already left refined, so just refine right}}
\DoxyCodeLine{564           \_Xtype right(X[ i + 1 ]);}
\DoxyCodeLine{565           \_Xtype here(X[ i ]);}
\DoxyCodeLine{566           newX.push\_back(here);}
\DoxyCodeLine{567           newX.push\_back((right + here) / 2.);}
\DoxyCodeLine{568         \}}
\DoxyCodeLine{569       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(!unrefine[ i ]) \{}
\DoxyCodeLine{570         newX.push\_back(X[ i ]);}
\DoxyCodeLine{571       \}}
\DoxyCodeLine{572     \}}
\DoxyCodeLine{573     newX.push\_back(X[ N -\/ 1 ]);}
\DoxyCodeLine{574 }
\DoxyCodeLine{575     \textcolor{comment}{// remesh the current solution to this (un)refined mesh}}
\DoxyCodeLine{576     SOLUTION.remesh1(newX);}
\DoxyCodeLine{577 \textcolor{preprocessor}{\#ifdef TIME}}
\DoxyCodeLine{578     T\_REFINE.stop();}
\DoxyCodeLine{579 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{580     \textcolor{comment}{// adding nodes will screw up the sign of the determinant of the Jacobian}}
\DoxyCodeLine{581     \textcolor{comment}{// so here we'll just make it zero}}
\DoxyCodeLine{582     LAST\_DET\_SIGN = 0;}
\DoxyCodeLine{583 }
\DoxyCodeLine{584     std::pair< unsigned, unsigned > feedback;}
\DoxyCodeLine{585     feedback.first = no\_refined;}
\DoxyCodeLine{586     feedback.second = no\_unrefined;}
\DoxyCodeLine{587     \textcolor{keywordflow}{return} feedback;}
\DoxyCodeLine{588   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1ODE__BVP_a22f7ec75c1314441e722b45527a3c296}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!adapt@{adapt}}
\index{adapt@{adapt}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{adapt()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily std\+::pair$<$ unsigned, unsigned $>$ \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ std\+::complex$<$ double $>$, std\+::complex$<$ double $>$ $>$\+::adapt (\begin{DoxyParamCaption}\item[{const double \&}]{adapt\+\_\+tol }\end{DoxyParamCaption})}



Definition at line 432 of file O\+D\+E\+\_\+\+B\+V\+P.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{432                                                                                                                \{}
\DoxyCodeLine{433     std::string problem;}
\DoxyCodeLine{434     problem = \textcolor{stringliteral}{" The ODE\_BVP.adapt method has been called for a  \(\backslash\)n"};}
\DoxyCodeLine{435     problem += \textcolor{stringliteral}{" problem in the complex plane. This doesn't make sense \(\backslash\)n"};}
\DoxyCodeLine{436     problem += \textcolor{stringliteral}{" as the path is not geometrically defined. \(\backslash\)n"};}
\DoxyCodeLine{437     \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{438   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1ODE__BVP_a0c5090867f757aa3f6220c044d5b345f}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!adapt@{adapt}}
\index{adapt@{adapt}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{adapt()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily std\+::pair$<$ unsigned, unsigned $>$ \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ double, std\+::complex$<$ double $>$ $>$\+::adapt (\begin{DoxyParamCaption}\item[{const double \&}]{adapt\+\_\+tol }\end{DoxyParamCaption})}



Definition at line 442 of file O\+D\+E\+\_\+\+B\+V\+P.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{442                                                                                                    \{}
\DoxyCodeLine{443     std::string problem;}
\DoxyCodeLine{444     problem = \textcolor{stringliteral}{" The ODE\_BVP.adapt method has been called for a  \(\backslash\)n"};}
\DoxyCodeLine{445     problem += \textcolor{stringliteral}{" problem in the complex plane. This doesn't make sense \(\backslash\)n"};}
\DoxyCodeLine{446     problem += \textcolor{stringliteral}{" as the path is not geometrically defined. \(\backslash\)n"};}
\DoxyCodeLine{447     \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{448   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1ODE__BVP_a53a7879084708c7685b17b48e6feee73}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!adapt\_until@{adapt\_until}}
\index{adapt\_until@{adapt\_until}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{adapt\_until()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype $>$ \\
void \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::adapt\+\_\+until (\begin{DoxyParamCaption}\item[{const double \&}]{adapt\+\_\+tol }\end{DoxyParamCaption})}



Adaptively solve the system until no refinements or unrefinements are applied. 


\begin{DoxyParams}{Parameters}
{\em adapt\+\_\+tol} & The residual tolerance at a nodal point that will lead to the mesh adaptation. \\
\hline
\end{DoxyParams}


Definition at line 471 of file O\+D\+E\+\_\+\+B\+V\+P.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{471                                                                   \{}
\DoxyCodeLine{472     std::pair< unsigned, unsigned > changes;}
\DoxyCodeLine{473     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{474       changes = adapt(adapt\_tol);}
\DoxyCodeLine{475       solve2();}
\DoxyCodeLine{476       std::cout << \textcolor{stringliteral}{"[INFO] Adapting: "} << changes.first << \textcolor{stringliteral}{" "} << changes.second << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{477     \} \textcolor{keywordflow}{while}(changes.first + changes.second != 0);}
\DoxyCodeLine{478   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1ODE__BVP_a5bceb2baefcf99e9e6327c90052534d9}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!adapt\_until@{adapt\_until}}
\index{adapt\_until@{adapt\_until}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{adapt\_until()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ std\+::complex$<$ double $>$, std\+::complex$<$ double $>$ $>$\+::adapt\+\_\+until (\begin{DoxyParamCaption}\item[{const double \&}]{adapt\+\_\+tol }\end{DoxyParamCaption})}



Definition at line 452 of file O\+D\+E\+\_\+\+B\+V\+P.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{452                                                                                             \{}
\DoxyCodeLine{453     std::string problem;}
\DoxyCodeLine{454     problem = \textcolor{stringliteral}{" The ODE\_BVP.adapt method has been called for a  \(\backslash\)n"};}
\DoxyCodeLine{455     problem += \textcolor{stringliteral}{" problem in the complex plane. This doesn't make sense \(\backslash\)n"};}
\DoxyCodeLine{456     problem += \textcolor{stringliteral}{" as the path is not geometrically defined. \(\backslash\)n"};}
\DoxyCodeLine{457     \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{458   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1ODE__BVP_a646d61d434c1d7ad1b4b70909e07f241}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!adapt\_until@{adapt\_until}}
\index{adapt\_until@{adapt\_until}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{adapt\_until()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ double, std\+::complex$<$ double $>$ $>$\+::adapt\+\_\+until (\begin{DoxyParamCaption}\item[{const double \&}]{adapt\+\_\+tol }\end{DoxyParamCaption})}



Definition at line 462 of file O\+D\+E\+\_\+\+B\+V\+P.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{462                                                                                 \{}
\DoxyCodeLine{463     std::string problem;}
\DoxyCodeLine{464     problem = \textcolor{stringliteral}{" The ODE\_BVP.adapt method has been called for a  \(\backslash\)n"};}
\DoxyCodeLine{465     problem += \textcolor{stringliteral}{" problem in the complex plane. This doesn't make sense \(\backslash\)n"};}
\DoxyCodeLine{466     problem += \textcolor{stringliteral}{" as the path is not geometrically defined. \(\backslash\)n"};}
\DoxyCodeLine{467     \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{468   \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1ODE__BVP_a5215f2492cd9c10c5ef753e41f5299fd}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!arclength\_solve@{arclength\_solve}}
\index{arclength\_solve@{arclength\_solve}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{arclength\_solve()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype $>$ \\
double \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::arclength\+\_\+solve (\begin{DoxyParamCaption}\item[{const double \&}]{step }\end{DoxyParamCaption})}



Arc-\/length solve the system. 

Before this can be called the arc\+\_\+init method should have been called in order to ensure we know a solution and have derivatives w.\+r.\+t. the arc-\/length parameter. \begin{DoxyRefDesc}{Todo}
\item[\textbf{ Todo}]y \& z should be solved for simultaneously -\/ but to do this we\textquotesingle{}d have to extend the L\+A\+P\+A\+CK interface and/or provide the same feature for the native solver. \end{DoxyRefDesc}


Definition at line 164 of file O\+D\+E\+\_\+\+B\+V\+P.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{164                                                                    \{}
\DoxyCodeLine{165     \textcolor{keyword}{this} -\/> ds() = step;}
\DoxyCodeLine{166     \textcolor{comment}{// order of the equation}}
\DoxyCodeLine{167     \textcolor{keywordtype}{unsigned} order(p\_EQUATION -\/> get\_order());}
\DoxyCodeLine{168     \textcolor{comment}{// the number of nodes in the BVP}}
\DoxyCodeLine{169     \textcolor{keywordtype}{unsigned} n(SOLUTION.get\_nnodes());}
\DoxyCodeLine{170     \textcolor{comment}{// Banded Jacobian}}
\DoxyCodeLine{171     BandedMatrix<\_Type> Jac(n * order, 2 * order -\/ 1, 0.0);}
\DoxyCodeLine{172     \textcolor{comment}{// residuals over all nodes vectors}}
\DoxyCodeLine{173     DenseVector<\_Type> Res1(n * order, 0.0);}
\DoxyCodeLine{174     DenseVector<\_Type> Res2(n * order, 0.0);}
\DoxyCodeLine{175     \textcolor{comment}{// RHS vectors for the linear solver(s)}}
\DoxyCodeLine{176     DenseVector<\_Type> y(n * order, 0.0);}
\DoxyCodeLine{177     DenseVector<\_Type> z(n * order, 0.0);}
\DoxyCodeLine{178 \textcolor{preprocessor}{\#ifdef LAPACK}}
\DoxyCodeLine{179     BandedLinearSystem<\_Type> system1(\&Jac, \&y, \textcolor{stringliteral}{"lapack"});}
\DoxyCodeLine{180     BandedLinearSystem<\_Type> system2(\&Jac, \&z, \textcolor{stringliteral}{"lapack"});}
\DoxyCodeLine{181 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{182     BandedLinearSystem<\_Type> system1(\&Jac, \&y, \textcolor{stringliteral}{"native"});}
\DoxyCodeLine{183     BandedLinearSystem<\_Type> system2(\&Jac, \&z, \textcolor{stringliteral}{"native"});}
\DoxyCodeLine{184 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{185     \textcolor{comment}{// we use the member data 'monitor\_det' to set the linear system determinant monitor}}
\DoxyCodeLine{186     system1.set\_monitor\_det(MONITOR\_DET);}
\DoxyCodeLine{187     \textcolor{comment}{// make backups in case we can't find a converged solution}}
\DoxyCodeLine{188     DenseVector<\_Type> backup\_state(SOLUTION.vars\_as\_vector());}
\DoxyCodeLine{189     \_Type backup\_parameter(*(\textcolor{keyword}{this} -\/> p\_PARAM));}
\DoxyCodeLine{190     \textcolor{comment}{// we can generate a 1st-\/order guess for the next state and parameter}}
\DoxyCodeLine{191     DenseVector<\_Type> x(\textcolor{keyword}{this} -\/> LAST\_X + \textcolor{keyword}{this} -\/> X\_DERIV\_S * \textcolor{keyword}{this} -\/> DS);}
\DoxyCodeLine{192     *(\textcolor{keyword}{this} -\/> p\_PARAM) = \textcolor{keyword}{this} -\/> LAST\_PARAM + \textcolor{keyword}{this} -\/> PARAM\_DERIV\_S * \textcolor{keyword}{this} -\/> DS;}
\DoxyCodeLine{193     \textcolor{comment}{// the class keeps the solution in a OneD\_mesh object, so we update it here}}
\DoxyCodeLine{194     SOLUTION.set\_vars\_from\_vector(x);}
\DoxyCodeLine{195     \textcolor{comment}{// determinant monitor}}
\DoxyCodeLine{196     \textcolor{keywordtype}{int} det\_sign(0);}
\DoxyCodeLine{197     \textcolor{comment}{// a flag to indicate if we have made a successful step}}
\DoxyCodeLine{198     \textcolor{keywordtype}{bool} step\_succeeded(\textcolor{keyword}{false});}
\DoxyCodeLine{199     \textcolor{comment}{// iteration counter}}
\DoxyCodeLine{200     \textcolor{keywordtype}{int} counter = 0;}
\DoxyCodeLine{201     \textcolor{comment}{// loop until converged or too many iterations}}
\DoxyCodeLine{202     \textcolor{keywordflow}{do} \{\textcolor{comment}{}}
\DoxyCodeLine{203 \textcolor{comment}{      /// \(\backslash\)todo y \& z should be solved for simultaneously -\/ but to do this}}
\DoxyCodeLine{204 \textcolor{comment}{      /// we'd have to extend the LAPACK interface and/or provide the}}
\DoxyCodeLine{205 \textcolor{comment}{      /// same feature for the native solver.}}
\DoxyCodeLine{206 \textcolor{comment}{}      ++counter;}
\DoxyCodeLine{207       \textcolor{comment}{// extra constraint corresponding to the new unknow parameter (arclength)}}
\DoxyCodeLine{208       \textcolor{keywordtype}{double} E1 = \textcolor{keyword}{this} -\/> arclength\_residual(x);}
\DoxyCodeLine{209       \textcolor{comment}{// construct the Jacobian/residual matrix problem}}
\DoxyCodeLine{210       assemble\_matrix\_problem(Jac, Res1);}
\DoxyCodeLine{211       actions\_before\_linear\_solve(Jac, Res1);}
\DoxyCodeLine{212       \textcolor{comment}{//BandedMatrix<\_Type> Jac\_copy( Jac );}}
\DoxyCodeLine{213       y = Res1;}
\DoxyCodeLine{214 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{215       \textcolor{comment}{//std::cout << " [ DEBUG ] : max\_residual = " << Res1.inf\_norm() << "\(\backslash\)n";}}
\DoxyCodeLine{216 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{217       \textcolor{keywordflow}{if}(Res1.inf\_norm() < TOL \&\& counter > 1) \{}
\DoxyCodeLine{218         step\_succeeded = \textcolor{keyword}{true};}
\DoxyCodeLine{219         \textcolor{keywordflow}{break};}
\DoxyCodeLine{220       \}}
\DoxyCodeLine{221       \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{222         system1.solve();}
\DoxyCodeLine{223         det\_sign = system1.get\_det\_sign();}
\DoxyCodeLine{224       \} \textcolor{keywordflow}{catch}(\textcolor{keyword}{const} ExceptionExternal \&error) \{}
\DoxyCodeLine{225         step\_succeeded = \textcolor{keyword}{false};}
\DoxyCodeLine{226         \textcolor{keywordflow}{break};}
\DoxyCodeLine{227       \}}
\DoxyCodeLine{228       \textcolor{comment}{// derivs w.r.t parameter}}
\DoxyCodeLine{229       \textcolor{keyword}{const} \textcolor{keywordtype}{double} delta(1.e-\/8);}
\DoxyCodeLine{230       *(\textcolor{keyword}{this} -\/> p\_PARAM) += delta;}
\DoxyCodeLine{231       \textcolor{comment}{// we actually just want the Res2 \& e2 vectors, so we still}}
\DoxyCodeLine{232       \textcolor{comment}{// use the original Jacobian j ... but it was overwritten by the}}
\DoxyCodeLine{233       \textcolor{comment}{// previous solve.}}
\DoxyCodeLine{234       assemble\_matrix\_problem(Jac, Res2);}
\DoxyCodeLine{235       \textcolor{comment}{//Jac = Jac\_copy;}}
\DoxyCodeLine{236       \textcolor{keywordtype}{double} E2 = \textcolor{keyword}{this} -\/> arclength\_residual(x);}
\DoxyCodeLine{237       actions\_before\_linear\_solve(Jac, Res2);}
\DoxyCodeLine{238       *(\textcolor{keyword}{this} -\/> p\_PARAM)  -\/= delta;}
\DoxyCodeLine{239       DenseVector<\_Type> dRes\_dp((Res2 -\/ Res1) / delta);}
\DoxyCodeLine{240       \textcolor{keywordtype}{double} dE\_dp = (E2 -\/ E1) / delta;}
\DoxyCodeLine{241       z = dRes\_dp;}
\DoxyCodeLine{242       \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{243         system2.solve();}
\DoxyCodeLine{244       \} \textcolor{keywordflow}{catch}(\textcolor{keyword}{const} ExceptionExternal\& error) \{}
\DoxyCodeLine{245         step\_succeeded = \textcolor{keyword}{false};}
\DoxyCodeLine{246         \textcolor{keywordflow}{break};}
\DoxyCodeLine{247       \}}
\DoxyCodeLine{248       \textcolor{comment}{// this is the extra (full) row in the augmented matrix problem}}
\DoxyCodeLine{249       \textcolor{comment}{// bottom row formed from dE/dx\_j}}
\DoxyCodeLine{250       DenseVector<\_Type> Jac\_E(\textcolor{keyword}{this} -\/> Jac\_arclength\_residual(x));}
\DoxyCodeLine{251       \textcolor{comment}{// given the solutions y \& z, the bordering algo provides the}}
\DoxyCodeLine{252       \textcolor{comment}{// solution to the full sparse system via}}
\DoxyCodeLine{253       \_Type delta\_p = -\/ (E1 + Utility::dot(Jac\_E, y)) /}
\DoxyCodeLine{254                       (dE\_dp + Utility::dot(Jac\_E, z));}
\DoxyCodeLine{255       DenseVector<\_Type> delta\_x = y + z * delta\_p;}
\DoxyCodeLine{256 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{257       std::cout << \textcolor{stringliteral}{" [ DEBUG ] : Arclength\_solve, dp = "} << delta\_p}
\DoxyCodeLine{258                 << \textcolor{stringliteral}{" dx.inf\_norm() = "} << delta\_x.inf\_norm()}
\DoxyCodeLine{259                 << \textcolor{stringliteral}{" theta = "} << \textcolor{keyword}{this} -\/> THETA << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{260 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{261       \textcolor{comment}{// update the state variables and the parameter with corrections}}
\DoxyCodeLine{262       x += delta\_x;}
\DoxyCodeLine{263       *(\textcolor{keyword}{this} -\/> p\_PARAM) += delta\_p;}
\DoxyCodeLine{264       \textcolor{comment}{// the corrections must be put back into the mesh container}}
\DoxyCodeLine{265       SOLUTION.set\_vars\_from\_vector(x);}
\DoxyCodeLine{266       \textcolor{comment}{// converged?}}
\DoxyCodeLine{267       \textcolor{keywordflow}{if}(delta\_x.inf\_norm() < TOL) \{}
\DoxyCodeLine{268         step\_succeeded = \textcolor{keyword}{true};}
\DoxyCodeLine{269         \textcolor{keywordflow}{break};}
\DoxyCodeLine{270       \}}
\DoxyCodeLine{271       \textcolor{comment}{// too many iterations?}}
\DoxyCodeLine{272       \textcolor{keywordflow}{if} ((counter > MAX\_ITERATIONS) || (delta\_x.inf\_norm() > 100 )) \{}
\DoxyCodeLine{273         step\_succeeded = \textcolor{keyword}{false};}
\DoxyCodeLine{274         \textcolor{keywordflow}{break};}
\DoxyCodeLine{275       \}}
\DoxyCodeLine{276     \} \textcolor{keywordflow}{while}(\textcolor{keyword}{true});}
\DoxyCodeLine{277     \textcolor{comment}{//}}
\DoxyCodeLine{278     \textcolor{keywordflow}{if}(!step\_succeeded) \{}
\DoxyCodeLine{279       \textcolor{comment}{// if not a successful step then restore things}}
\DoxyCodeLine{280       SOLUTION.set\_vars\_from\_vector(backup\_state);}
\DoxyCodeLine{281       *(\textcolor{keyword}{this} -\/> p\_PARAM) = backup\_parameter;}
\DoxyCodeLine{282       \textcolor{comment}{// reduce our step length}}
\DoxyCodeLine{283       \textcolor{keyword}{this} -\/> DS /= \textcolor{keyword}{this} -\/> ARCSTEP\_MULTIPLIER;}
\DoxyCodeLine{284 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{285       std::cout << \textcolor{stringliteral}{"[ DEBUG ] : REJECTING STEP \(\backslash\)n"};}
\DoxyCodeLine{286       std::cout << \textcolor{stringliteral}{"[ DEBUG ] : I decreased DS to "} << \textcolor{keyword}{this} -\/> DS << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{287 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{288     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{289       \textcolor{comment}{// update the variables needed for arc-\/length continuation}}
\DoxyCodeLine{290       \textcolor{keyword}{this} -\/> update(SOLUTION.vars\_as\_vector());}
\DoxyCodeLine{291       \textcolor{keywordflow}{if}(LAST\_DET\_SIGN * det\_sign < 0) \{}
\DoxyCodeLine{292         \textcolor{comment}{// a change in the sign of the determinant of the Jacobian}}
\DoxyCodeLine{293         \textcolor{comment}{// has been found}}
\DoxyCodeLine{294         LAST\_DET\_SIGN = det\_sign;}
\DoxyCodeLine{295         std::string problem;}
\DoxyCodeLine{296         problem = \textcolor{stringliteral}{"[ INFO ] : Determinant monitor has changed signs in the Newton class.\(\backslash\)n"};}
\DoxyCodeLine{297         problem += \textcolor{stringliteral}{"[ INFO ] : Bifurcation detected.\(\backslash\)n"};}
\DoxyCodeLine{298         \textcolor{keywordflow}{throw} ExceptionBifurcation(problem);}
\DoxyCodeLine{299       \}}
\DoxyCodeLine{300 }
\DoxyCodeLine{301 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{302       std::cout << \textcolor{stringliteral}{" [ DEBUG ] : Number of iterations = "} << counter << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{303       std::cout << \textcolor{stringliteral}{" [ DEBUG ] : Parameter p = "} << *(\textcolor{keyword}{this} -\/> p\_PARAM)}
\DoxyCodeLine{304                 << \textcolor{stringliteral}{"; arclength DS = "} << \textcolor{keyword}{this} -\/> DS << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{305       std::cout << \textcolor{stringliteral}{" [ DEBUG ] : Arclength THETA = "} << \textcolor{keyword}{this} -\/> THETA << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{306 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{307       \textcolor{keywordflow}{if}(counter > 8 || std::abs(\textcolor{keyword}{this} -\/> DS) > \textcolor{keyword}{this} -\/> MAX\_DS) \{}
\DoxyCodeLine{308         \textcolor{comment}{// converging too slowly, so decrease DS}}
\DoxyCodeLine{309         \textcolor{keyword}{this} -\/> DS /= \textcolor{keyword}{this} -\/> ARCSTEP\_MULTIPLIER;}
\DoxyCodeLine{310 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{311         std::cout << \textcolor{stringliteral}{" [ DEBUG ] : I decreased DS to "} << \textcolor{keyword}{this} -\/> DS << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{312 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{313       \}}
\DoxyCodeLine{314       \textcolor{keywordflow}{if}(counter < 4) \{}
\DoxyCodeLine{315         \textcolor{keywordflow}{if}(std::abs(\textcolor{keyword}{this} -\/> DS * \textcolor{keyword}{this} -\/> ARCSTEP\_MULTIPLIER) < \textcolor{keyword}{this} -\/> MAX\_DS) \{}
\DoxyCodeLine{316           \textcolor{comment}{// converging too quickly, so increase DS}}
\DoxyCodeLine{317           \textcolor{keyword}{this} -\/> DS *= \textcolor{keyword}{this} -\/> ARCSTEP\_MULTIPLIER;}
\DoxyCodeLine{318 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{319           std::cout << \textcolor{stringliteral}{" [ DEBUG ] : I increased DS to "} << \textcolor{keyword}{this} -\/> DS << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{320 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{321         \}}
\DoxyCodeLine{322       \}}
\DoxyCodeLine{323     \}}
\DoxyCodeLine{324     \textcolor{keywordflow}{return} \textcolor{keyword}{this} -\/> DS;}
\DoxyCodeLine{325   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1ODE__BVP_ae8cd2a68518675ba206575436dc1fbe1}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!init\_arc@{init\_arc}}
\index{init\_arc@{init\_arc}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{init\_arc()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype $>$ \\
void \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::init\+\_\+arc (\begin{DoxyParamCaption}\item[{\+\_\+\+Type $\ast$}]{p,  }\item[{const double \&}]{length,  }\item[{const double \&}]{max\+\_\+length }\end{DoxyParamCaption})}



Initialise the class ready for arc length continuation. 

The base class requires a vector, so we wrap the base class method here so that the vector can be extracted from the mesh member data. 
\begin{DoxyParams}{Parameters}
{\em p} & The pointer to the parameter \\
\hline
{\em length} & The initial arc length step to be taken (all in the parameter. \\
\hline
{\em max\+\_\+length} & The maximum arc length step to be allowed. \\
\hline
\end{DoxyParams}


Definition at line 179 of file O\+D\+E\+\_\+\+B\+V\+P.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{181                                                                   \{}
\DoxyCodeLine{182     DenseVector<\_Type> state(SOLUTION.vars\_as\_vector());}
\DoxyCodeLine{183     \textcolor{keyword}{this} -\/> init\_arc(state, p, length, max\_length);}
\DoxyCodeLine{184   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1ODE__BVP_acebdc0ea3fade2e901ba5219e3d493c8}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!max\_itns@{max\_itns}}
\index{max\_itns@{max\_itns}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{max\_itns()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype  = double$>$ \\
int\& \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::max\+\_\+itns (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access method to the maximum number of iterations. 

\begin{DoxyReturn}{Returns}
A handle to the private member data M\+A\+X\+\_\+\+I\+T\+E\+R\+A\+T\+I\+O\+NS 
\end{DoxyReturn}


Definition at line 120 of file O\+D\+E\+\_\+\+B\+V\+P.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{120                     \{}
\DoxyCodeLine{121       \textcolor{keywordflow}{return} MAX\_ITERATIONS;}
\DoxyCodeLine{122     \}}

\end{DoxyCode}
\mbox{\label{classCppNoddy_1_1ODE__BVP_a6de55a04541b156a3f7bbdbb2eaf5420}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!set\_monitor\_det@{set\_monitor\_det}}
\index{set\_monitor\_det@{set\_monitor\_det}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{set\_monitor\_det()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype $>$ \\
void \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::set\+\_\+monitor\+\_\+det (\begin{DoxyParamCaption}\item[{bool}]{flag }\end{DoxyParamCaption})}



Set the flag that determines if the determinant will be monitored The default is to monitor. 


\begin{DoxyParams}{Parameters}
{\em flag} & The boolean value that the flag will be set to \\
\hline
\end{DoxyParams}


Definition at line 174 of file O\+D\+E\+\_\+\+B\+V\+P.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{174                                                         \{}
\DoxyCodeLine{175     MONITOR\_DET = flag;}
\DoxyCodeLine{176   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1ODE__BVP_aa4a32cb096c7fbf1b70b43de0d6e8807}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!solution@{solution}}
\index{solution@{solution}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{solution()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype $>$ \\
\textbf{ One\+D\+\_\+\+Node\+\_\+\+Mesh}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$ \& \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::solution\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
A handle to the solution mesh 
\end{DoxyReturn}


Definition at line 187 of file O\+D\+E\+\_\+\+B\+V\+P.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{187                                                                          \{}
\DoxyCodeLine{188     \textcolor{keywordflow}{return} SOLUTION;}
\DoxyCodeLine{189   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1ODE__BVP_ae73d37efde211f342a3b611a49a47b6b}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!solve2@{solve2}}
\index{solve2@{solve2}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{solve2()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype $>$ \\
void \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::solve2}



Formulate and solve the O\+DE using \doxyref{Newton}{p.}{classCppNoddy_1_1Newton} iteration and a second-\/order finite difference scheme. 

The solution is stored in the publicly accessible \textquotesingle{}solution\textquotesingle{} member data. 

Definition at line 83 of file O\+D\+E\+\_\+\+B\+V\+P.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{83                                       \{}
\DoxyCodeLine{84     \textcolor{comment}{// the order of the problem}}
\DoxyCodeLine{85     \textcolor{keywordtype}{unsigned} order(p\_EQUATION -\/> get\_order());}
\DoxyCodeLine{86     \textcolor{comment}{// get the number of nodes in the mesh}}
\DoxyCodeLine{87     \textcolor{comment}{// -\/-\/ this may have been refined by the user since the}}
\DoxyCodeLine{88     \textcolor{comment}{// last call.}}
\DoxyCodeLine{89     \textcolor{keywordtype}{unsigned} n(SOLUTION.get\_nnodes());}
\DoxyCodeLine{90     \textcolor{comment}{// measure of maximum residual}}
\DoxyCodeLine{91     \textcolor{keywordtype}{double} max\_residual(1.0);}
\DoxyCodeLine{92     \textcolor{comment}{// iteration counter}}
\DoxyCodeLine{93     \textcolor{keywordtype}{int} counter = 0;}
\DoxyCodeLine{94     \textcolor{comment}{// determinant monitor}}
\DoxyCodeLine{95     \textcolor{keywordtype}{int} det\_sign(LAST\_DET\_SIGN);}
\DoxyCodeLine{96 }
\DoxyCodeLine{97     \textcolor{comment}{// ANY LARGE STORAGE USED IN THE MAIN LOOP IS}}
\DoxyCodeLine{98     \textcolor{comment}{// DEFINED HERE TO AVOID REPEATED CONSTRUCTION.}}
\DoxyCodeLine{99     \textcolor{comment}{// Note we blank the A matrix after every iteration.}}
\DoxyCodeLine{100     \textcolor{comment}{//}}
\DoxyCodeLine{101     \textcolor{comment}{// Banded LHS matrix -\/ max obove diagonal band width is}}
\DoxyCodeLine{102     \textcolor{comment}{// from first variable at node i to last variable at node i+1}}
\DoxyCodeLine{103     BandedMatrix<\_Type> a(n * order, 2 * order -\/ 1, 0.0);}
\DoxyCodeLine{104     \textcolor{comment}{// RHS}}
\DoxyCodeLine{105     DenseVector<\_Type> b(n * order, 0.0);}
\DoxyCodeLine{106     \textcolor{comment}{// linear solver definition}}
\DoxyCodeLine{107 \textcolor{preprocessor}{\#ifdef LAPACK}}
\DoxyCodeLine{108     BandedLinearSystem<\_Type> system(\&a, \&b, \textcolor{stringliteral}{"lapack"});}
\DoxyCodeLine{109 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{110     BandedLinearSystem<\_Type> system(\&a, \&b, \textcolor{stringliteral}{"native"});}
\DoxyCodeLine{111 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{112     \textcolor{comment}{// pass the local monitor\_det flag to the linear system}}
\DoxyCodeLine{113     system.set\_monitor\_det(MONITOR\_DET);}
\DoxyCodeLine{114 }
\DoxyCodeLine{115     \textcolor{comment}{// loop until converged or too many iterations}}
\DoxyCodeLine{116     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{117       \textcolor{comment}{// iteration counter}}
\DoxyCodeLine{118       ++counter;}
\DoxyCodeLine{119 \textcolor{preprocessor}{\#ifdef TIME}}
\DoxyCodeLine{120       T\_ASSEMBLE.start();}
\DoxyCodeLine{121 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{122       assemble\_matrix\_problem(a, b);}
\DoxyCodeLine{123       actions\_before\_linear\_solve(a, b);}
\DoxyCodeLine{124       max\_residual = b.inf\_norm();}
\DoxyCodeLine{125 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{126       std::cout << \textcolor{stringliteral}{" ODE\_BVP.solve : Residual\_max = "} << max\_residual << \textcolor{stringliteral}{" tol = "} << TOL << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{127 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{128 \textcolor{preprocessor}{\#ifdef TIME}}
\DoxyCodeLine{129       T\_ASSEMBLE.stop();}
\DoxyCodeLine{130       T\_SOLVE.start();}
\DoxyCodeLine{131 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{132       \textcolor{comment}{// linear solver}}
\DoxyCodeLine{133       system.solve();}
\DoxyCodeLine{134       \textcolor{comment}{// keep the solution in a OneD\_Node\_Mesh object}}
\DoxyCodeLine{135       \textcolor{keywordflow}{for}(std::size\_t var = 0; var < order; ++var) \{}
\DoxyCodeLine{136         \textcolor{keywordflow}{for}(std::size\_t i = 0; i < n; ++i) \{}
\DoxyCodeLine{137           SOLUTION(i, var) += b[ i * order + var ];}
\DoxyCodeLine{138         \}}
\DoxyCodeLine{139       \}}
\DoxyCodeLine{140 \textcolor{preprocessor}{\#ifdef TIME}}
\DoxyCodeLine{141       T\_SOLVE.stop();}
\DoxyCodeLine{142 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{143     \} \textcolor{keywordflow}{while}((max\_residual > TOL) \&\& (counter < MAX\_ITERATIONS));}
\DoxyCodeLine{144     \textcolor{keywordflow}{if}(counter >= MAX\_ITERATIONS) \{}
\DoxyCodeLine{145       std::string problem(\textcolor{stringliteral}{"\(\backslash\)n The ODE\_BVP.solve2 method took too many iterations. \(\backslash\)n"});}
\DoxyCodeLine{146       \textcolor{keywordflow}{throw} ExceptionItn(problem, counter, max\_residual);}
\DoxyCodeLine{147     \}}
\DoxyCodeLine{148 }
\DoxyCodeLine{149     \textcolor{comment}{// last\_det\_sign is set to be 0 in ctor, it must be +/-\/1 when calculated}}
\DoxyCodeLine{150     \textcolor{keywordflow}{if}(MONITOR\_DET) \{}
\DoxyCodeLine{151       det\_sign = system.get\_det\_sign();}
\DoxyCodeLine{152       \textcolor{keywordflow}{if}(det\_sign * LAST\_DET\_SIGN < 0) \{}
\DoxyCodeLine{153         LAST\_DET\_SIGN = det\_sign;}
\DoxyCodeLine{154         std::string problem;}
\DoxyCodeLine{155         problem = \textcolor{stringliteral}{"[ INFO ] : Determinant monitor has changed signs in ODE\_BVP.\(\backslash\)n"};}
\DoxyCodeLine{156         problem += \textcolor{stringliteral}{"[ INFO ] : Bifurcation detected.\(\backslash\)n"};}
\DoxyCodeLine{157         \textcolor{keywordflow}{throw} ExceptionBifurcation(problem);}
\DoxyCodeLine{158       \}}
\DoxyCodeLine{159       LAST\_DET\_SIGN = det\_sign;}
\DoxyCodeLine{160     \}}
\DoxyCodeLine{161   \}}

\end{DoxyCode}


Referenced by main().

\mbox{\label{classCppNoddy_1_1ODE__BVP_a10abc65b31bdc85a98e275635b5dc27d}} 
\index{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}!tolerance@{tolerance}}
\index{tolerance@{tolerance}!CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$@{CppNoddy::ODE\_BVP$<$ \_Type, \_Xtype $>$}}
\doxyparagraph{tolerance()}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Type , typename \+\_\+\+Xtype  = double$>$ \\
double\& \textbf{ Cpp\+Noddy\+::\+O\+D\+E\+\_\+\+B\+VP}$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::tolerance (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access method to the tolerance. 

\begin{DoxyReturn}{Returns}
A handle to the private member data T\+O\+L\+E\+R\+A\+N\+CE 
\end{DoxyReturn}


Definition at line 114 of file O\+D\+E\+\_\+\+B\+V\+P.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{114                         \{}
\DoxyCodeLine{115       \textcolor{keywordflow}{return} TOL;}
\DoxyCodeLine{116     \}}

\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/\textbf{ O\+D\+E\+\_\+\+B\+V\+P.\+h}\item 
src/\textbf{ O\+D\+E\+\_\+\+B\+V\+P.\+cpp}\end{DoxyCompactItemize}
