\doxysubsection{Tests/\+F\+T/\+FT.cpp File Reference}
\label{Tests_2FT_2FT_8cpp}\index{Tests/FT/FT.cpp@{Tests/FT/FT.cpp}}
{\ttfamily \#include $<$F\+T.\+h$>$}\newline
{\ttfamily \#include $<$One\+D\+\_\+\+Node\+\_\+\+Mesh.\+h$>$}\newline
{\ttfamily \#include $<$Types.\+h$>$}\newline
{\ttfamily \#include $<$Utility.\+h$>$}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \textbf{ main} ()
\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
A simple 1D D\+FT test case. Takes a signal, evaluates the (slow) D\+FT, then inverts the same D\+FT and subtracts the result from the original signal data. 

\doxysubsubsection{Function Documentation}
\mbox{\label{Tests_2FT_2FT_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}} 
\index{FT.cpp@{FT.cpp}!main@{main}}
\index{main@{main}!FT.cpp@{FT.cpp}}
\doxyparagraph{main()}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 16 of file F\+T.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{17 \{}
\DoxyCodeLine{18   }
\DoxyCodeLine{19   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{20   cout << \textcolor{stringliteral}{"=== FT: one-\/dimensional Fourier Transform (slow) ====\(\backslash\)n"};}
\DoxyCodeLine{21   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{22 }
\DoxyCodeLine{23   \textcolor{comment}{// physical domain size}}
\DoxyCodeLine{24   \textcolor{keyword}{const} \textcolor{keywordtype}{double} xMax(20);}
\DoxyCodeLine{25   \textcolor{comment}{// number of points/wavenumbers/frequencies}}
\DoxyCodeLine{26   std::size\_t N(256);}
\DoxyCodeLine{27   \textcolor{comment}{// nodes}}
\DoxyCodeLine{28   \textcolor{keyword}{const} DenseVector<double> xNodes = Utility::uniform\_node\_vector(-\/xMax,xMax,N);}
\DoxyCodeLine{29   \textcolor{comment}{// the physical signal}}
\DoxyCodeLine{30   OneD\_Node\_Mesh<D\_complex> h( xNodes, 2 );}
\DoxyCodeLine{31   \textcolor{comment}{// two *complex* values stored across the mesh}}
\DoxyCodeLine{32   \textcolor{keywordflow}{for} ( std::size\_t i = 0; i < N; ++i ) \{}
\DoxyCodeLine{33     \textcolor{comment}{// sum of 2 "humps" of the form 1/(1+x\string^2)}}
\DoxyCodeLine{34     h(i,0) = 1./(1+(xNodes[i]-\/0)*(xNodes[i]-\/0))}
\DoxyCodeLine{35       + D\_complex(0.,1.)/(1+(xNodes[i]-\/4)*(xNodes[i]-\/4));}
\DoxyCodeLine{36     \textcolor{comment}{// a simple sinusoid}}
\DoxyCodeLine{37     h(i,1) = sin(xNodes[i]);}
\DoxyCodeLine{38   \}}
\DoxyCodeLine{39   \textcolor{comment}{// original (physical) signal}}
\DoxyCodeLine{40   \textcolor{comment}{// h.dump\_gnu("./DATA/h.dat");}}
\DoxyCodeLine{41 }
\DoxyCodeLine{42   OneD\_Node\_Mesh<D\_complex> testft = FT::dft\_with\_shift(h);}
\DoxyCodeLine{43   testft.dump\_gnu(\textcolor{stringliteral}{"./DATA/testft.dat"});}
\DoxyCodeLine{44 }
\DoxyCodeLine{45   OneD\_Node\_Mesh<D\_complex> testf = FT::idft\_with\_ishift(testft);}
\DoxyCodeLine{46   testf.dump\_gnu(\textcolor{stringliteral}{"./DATA/testf.dat"});}
\DoxyCodeLine{47 }
\DoxyCodeLine{48 }
\DoxyCodeLine{49   }
\DoxyCodeLine{50   \textcolor{comment}{// Fourier transformed signal}}
\DoxyCodeLine{51   OneD\_Node\_Mesh<D\_complex> hft = FT::dft(h);}
\DoxyCodeLine{52   \textcolor{comment}{// hft.dump\_gnu("./DATA/hft.dat");}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54   \textcolor{comment}{// shifted Fourier transformed signal}}
\DoxyCodeLine{55   \textcolor{comment}{// this puts the spectrum in a -\/k\_max to +k\_max format}}
\DoxyCodeLine{56   OneD\_Node\_Mesh<D\_complex> hft\_shifted = FT::shift(hft);}
\DoxyCodeLine{57   \textcolor{comment}{// hft\_shifted.dump\_gnu("./DATA/hft\_shifted.dat");}}
\DoxyCodeLine{58   }
\DoxyCodeLine{59   \textcolor{comment}{// invert the DFT (must be done using the UNshifted spectrum)}}
\DoxyCodeLine{60   \textcolor{comment}{// the starting (physcial)\_ x-\/coordinate is included as}}
\DoxyCodeLine{61   \textcolor{comment}{// an optional second argument here, otherwise the reconstruction}}
\DoxyCodeLine{62   \textcolor{comment}{// will start at x=0.}}
\DoxyCodeLine{63   OneD\_Node\_Mesh<D\_complex> hReconstructed = FT::idft(hft,-\/xMax);}
\DoxyCodeLine{64   \textcolor{comment}{// hReconstructed.dump\_gnu("./DATA/h\_reconstruct.dat");}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66   \textcolor{comment}{// subtract the initial and reconstructed data for both data elements}}
\DoxyCodeLine{67   \textcolor{comment}{// which should give zero}}
\DoxyCodeLine{68   \textcolor{keywordflow}{for} ( std::size\_t i = 0; i < N; ++i ) \{}
\DoxyCodeLine{69     h(i,0) -\/= hReconstructed(i,0);}
\DoxyCodeLine{70     h(i,1) -\/= hReconstructed(i,1);}
\DoxyCodeLine{71   \}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73   \textcolor{comment}{// check the biggest error in the reconstruction}}
\DoxyCodeLine{74   \textcolor{keywordflow}{if} ( max(h.max\_abs(0),h.max\_abs(1)) < 1.e-\/12 ) \{}
\DoxyCodeLine{75     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;32;48m  * PASSED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{76     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{77   \}}
\DoxyCodeLine{78   cout << \textcolor{stringliteral}{"\(\backslash\)033[1;31;48m  * FAILED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{79   cout << \textcolor{stringliteral}{"    Final |error| = "} << h.max\_abs(0) << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{80   \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{81 }
\DoxyCodeLine{82 \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+F\+T\+::dft(), Cpp\+Noddy\+::\+F\+T\+::dft\+\_\+with\+\_\+shift(), Cpp\+Noddy\+::\+One\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::dump\+\_\+gnu(), h, Cpp\+Noddy\+::\+F\+T\+::idft(), Cpp\+Noddy\+::\+F\+T\+::idft\+\_\+with\+\_\+ishift(), Cpp\+Noddy\+::\+F\+T\+::shift(), and Cpp\+Noddy\+::\+Utility\+::uniform\+\_\+node\+\_\+vector().

