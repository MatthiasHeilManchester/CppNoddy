\doxysubsection{Cpp\+Noddy\+::Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh Class Reference}
\label{classCppNoddy_1_1TwoD__TVDLF__Mesh}\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}


{\ttfamily \#include $<$Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh} (const \textbf{ Dense\+Vector}$<$ double $>$ \&X, const \textbf{ Dense\+Vector}$<$ double $>$ \&Y, \textbf{ Two\+D\+\_\+\+Hyperbolic\+\_\+\+System} $\ast$ptr, \textbf{ fn\+\_\+ptr} init\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Constructor for the Finite Volume Mesh using linear elements. \end{DoxyCompactList}\item 
virtual \textbf{ $\sim$\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh} ()
\begin{DoxyCompactList}\small\item\em Empty desctructor. \end{DoxyCompactList}\item 
void \textbf{ dump\+\_\+gnu} (std\+::string filename)
\begin{DoxyCompactList}\small\item\em Dump the data to a given filename in a gnuplot format. \end{DoxyCompactList}\item 
void \textbf{ dump\+\_\+nodes\+\_\+x} (std\+::string filename) const
\begin{DoxyCompactList}\small\item\em Dump the x-\/nodal positions to a given filename. \end{DoxyCompactList}\item 
void \textbf{ dump\+\_\+nodes\+\_\+y} (std\+::string filename) const
\begin{DoxyCompactList}\small\item\em Dump the y-\/nodal positions to a given filename. \end{DoxyCompactList}\item 
void \textbf{ dump\+\_\+data} (std\+::string filename)
\begin{DoxyCompactList}\small\item\em Dump the data over the nodal positions to a given filename. \end{DoxyCompactList}\item 
void \textbf{ set\+\_\+limiter} (const unsigned \&id)
\begin{DoxyCompactList}\small\item\em Set the limiter type to be applied in the slope values. \end{DoxyCompactList}\item 
double \textbf{ update} (const double \&C\+FL, const double \&max\+\_\+dt=std\+::numeric\+\_\+limits$<$ long double $>$\+::max())
\begin{DoxyCompactList}\small\item\em Update the mesh object. \end{DoxyCompactList}\item 
void \textbf{ update\+\_\+to} (const double \&C\+FL, const double \&t\+\_\+end)
\begin{DoxyCompactList}\small\item\em Update the mesh object to a set time level. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ integrate} (std\+::string mesh\+\_\+colour=\char`\"{}black\char`\"{})
\begin{DoxyCompactList}\small\item\em Integrate the concentration values across the entire mesh. \end{DoxyCompactList}\item 
\textbf{ elt\+\_\+iter} \textbf{ get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+x} (const \textbf{ Dense\+Vector}$<$ double $>$ \&x, std\+::string mesh\+\_\+colour=\char`\"{}black\char`\"{})
\begin{DoxyCompactList}\small\item\em Given a global coordinate, return a pointer to the elt that contains that point. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ get\+\_\+point\+\_\+values} (const \textbf{ Dense\+Vector}$<$ double $>$ \&x)
\begin{DoxyCompactList}\small\item\em Get the vector of unknowns at a point in the 2D mesh. \end{DoxyCompactList}\item 
const double \& \textbf{ get\+\_\+time} () const
\begin{DoxyCompactList}\small\item\em Get a const reference to the time value for the current mesh. \end{DoxyCompactList}\item 
virtual void \textbf{ actions\+\_\+before\+\_\+time\+\_\+step1} (const double \&time\+\_\+step)
\begin{DoxyCompactList}\small\item\em A virtual method that is run before the first time update. \end{DoxyCompactList}\item 
virtual void \textbf{ actions\+\_\+before\+\_\+time\+\_\+step2} (const double \&time\+\_\+step)
\begin{DoxyCompactList}\small\item\em A virtual method that is run before the second time update. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\textbf{ vector\+\_\+of\+\_\+elts} \textbf{ B\+L\+A\+C\+K\+\_\+\+E\+L\+TS}
\begin{DoxyCompactList}\small\item\em An S\+TL vector of linear elements -- the black mesh. \end{DoxyCompactList}\item 
\textbf{ vector\+\_\+of\+\_\+elts} \textbf{ R\+E\+D\+\_\+\+E\+L\+TS}
\begin{DoxyCompactList}\small\item\em An S\+TL vector of linear elements -- the red mesh. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ \textbf{ Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Elt} $>$ \textbf{ vector\+\_\+of\+\_\+elts}
\begin{DoxyCompactList}\small\item\em iterators for the vector of elements \end{DoxyCompactList}\item 
typedef vector\+\_\+of\+\_\+elts\+::const\+\_\+iterator \textbf{ celt\+\_\+iter}
\item 
typedef vector\+\_\+of\+\_\+elts\+::iterator \textbf{ elt\+\_\+iter}
\item 
typedef std\+::vector$<$ \textbf{ Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Elt} $\ast$ $>$ \textbf{ vector\+\_\+of\+\_\+boundary\+\_\+elts}
\item 
typedef vector\+\_\+of\+\_\+boundary\+\_\+elts\+::iterator \textbf{ bdry\+\_\+elt\+\_\+iter}
\item 
typedef void($\ast$ \textbf{ fn\+\_\+ptr}) (const double \&, const double \&, \textbf{ Dense\+Vector}$<$ double $>$ \&)
\begin{DoxyCompactList}\small\item\em function pointer used in the initial conditions \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ elt\+\_\+iter} \textbf{ get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+elt\+\_\+iter} (\textbf{ elt\+\_\+iter} e, std\+::string target\+\_\+colour, int corner\+\_\+index)
\begin{DoxyCompactList}\small\item\em Given an element in the I\+N\+I\+T\+I\+AL S\+T\+R\+U\+C\+T\+U\+R\+ED M\+E\+SH, this method will return an iterator to an element in the other mesh that overlaps the corner specified by corner\+\_\+index. \end{DoxyCompactList}\item 
\textbf{ vector\+\_\+of\+\_\+elts} $\ast$ \textbf{ get\+\_\+elts\+\_\+from\+\_\+colour} (std\+::string mesh\+\_\+colour)
\begin{DoxyCompactList}\small\item\em Given a choice of black or red mesh, return a pointer to the appropriate vector of elements. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \textbf{ get\+\_\+number\+\_\+elts\+\_\+in\+\_\+x} (std\+::string mesh\+\_\+colour)
\begin{DoxyCompactList}\small\item\em Given a choice of black or red mesh, return the number of elements in the x-\/direction. \end{DoxyCompactList}\item 
void \textbf{ calc\+\_\+slopes} (\textbf{ vector\+\_\+of\+\_\+elts} $\ast$elt\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Use the appropriate limiter to approximate the slope in each element in the mesh. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ east\+\_\+diff} (\textbf{ elt\+\_\+iter} e) const
\begin{DoxyCompactList}\small\item\em Compute a finite difference approximation of the derivative in the compass direction. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ west\+\_\+diff} (\textbf{ elt\+\_\+iter} e) const
\begin{DoxyCompactList}\small\item\em Compute a finite difference approximation of the derivative in the compass direction. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ north\+\_\+diff} (\textbf{ elt\+\_\+iter} e) const
\begin{DoxyCompactList}\small\item\em Compute a finite difference approximation of the derivative in the compass direction. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ south\+\_\+diff} (\textbf{ elt\+\_\+iter} e) const
\begin{DoxyCompactList}\small\item\em Compute a finite difference approximation of the derivative in the compass direction. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ N\+S\+\_\+diff} (\textbf{ elt\+\_\+iter} e)
\begin{DoxyCompactList}\small\item\em Compute a finite difference approximation of the derivative in the compass direction. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ E\+W\+\_\+diff} (\textbf{ elt\+\_\+iter} e)
\begin{DoxyCompactList}\small\item\em Compute a finite difference approximation of the derivative in the compass direction. \end{DoxyCompactList}\item 
int \textbf{ sgn} (double a) const
\begin{DoxyCompactList}\small\item\em Sign of a double. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ minmod} (\textbf{ Dense\+Vector}$<$ double $>$ A, \textbf{ Dense\+Vector}$<$ double $>$ B) const
\begin{DoxyCompactList}\small\item\em A vector version of the minmod operator. \end{DoxyCompactList}\item 
\textbf{ Dense\+Vector}$<$ double $>$ \textbf{ maxmod} (\textbf{ Dense\+Vector}$<$ double $>$ A, \textbf{ Dense\+Vector}$<$ double $>$ B) const
\begin{DoxyCompactList}\small\item\em A vector version of the maxmod operator. \end{DoxyCompactList}\item 
void \textbf{ boundary\+\_\+diff} (\textbf{ elt\+\_\+iter} e, const int \&face\+\_\+index, \textbf{ Dense\+Vector}$<$ double $>$ \&diff) const
\begin{DoxyCompactList}\small\item\em Given an element iterator and the local coordinate this will return zero for any components specified as inflow boundary conditions in line with Levy \& Tadmor (1997) and set the centre nodal value to the edge value. \end{DoxyCompactList}\item 
void \textbf{ set\+\_\+boundary\+\_\+Q} (\textbf{ vector\+\_\+of\+\_\+elts} $\ast$elts)
\begin{DoxyCompactList}\small\item\em Loops over all boundary elements and sets the Q values in each one to be the value specified by the edge\+\_\+values method. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
unsigned \textbf{ L\+I\+M\+I\+T\+ER}
\begin{DoxyCompactList}\small\item\em Slope limiter method. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \textbf{ O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM}
\begin{DoxyCompactList}\small\item\em order of the conservative system \end{DoxyCompactList}\item 
std\+::size\+\_\+t \textbf{ NX}
\begin{DoxyCompactList}\small\item\em number of faces in the x \& y directions \end{DoxyCompactList}\item 
std\+::size\+\_\+t \textbf{ NY}
\item 
double \textbf{ M\+E\+S\+H\+\_\+\+T\+I\+ME}
\begin{DoxyCompactList}\small\item\em the time level of the mesh \end{DoxyCompactList}\item 
\textbf{ fn\+\_\+ptr} \textbf{ p\+\_\+\+Q\+\_\+\+I\+N\+IT}
\begin{DoxyCompactList}\small\item\em function pointer to a funnction that defines the initial distribution \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}


Definition at line 19 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.



\doxysubsubsection{Member Typedef Documentation}
\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a3ac81168fd1293f507467c16c4f83b92}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!bdry\_elt\_iter@{bdry\_elt\_iter}}
\index{bdry\_elt\_iter@{bdry\_elt\_iter}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{bdry\_elt\_iter}
{\footnotesize\ttfamily typedef vector\+\_\+of\+\_\+boundary\+\_\+elts\+::iterator \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::bdry\+\_\+elt\+\_\+iter}\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 27 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_ac133b34bae232a1c790a82805ed6959b}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!celt\_iter@{celt\_iter}}
\index{celt\_iter@{celt\_iter}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{celt\_iter}
{\footnotesize\ttfamily typedef vector\+\_\+of\+\_\+elts\+::const\+\_\+iterator \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::celt\+\_\+iter}\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 23 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_aee9774f42bb8a3c53bc245e291cb5036}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!elt\_iter@{elt\_iter}}
\index{elt\_iter@{elt\_iter}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{elt\_iter}
{\footnotesize\ttfamily typedef vector\+\_\+of\+\_\+elts\+::iterator \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::elt\+\_\+iter}\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 24 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a5dcec6e5bc9705ce03c22a86373bb36e}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!fn\_ptr@{fn\_ptr}}
\index{fn\_ptr@{fn\_ptr}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{fn\_ptr}
{\footnotesize\ttfamily typedef void($\ast$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::fn\+\_\+ptr) (const double \&, const double \&, \textbf{ Dense\+Vector}$<$ double $>$ \&)\hspace{0.3cm}{\ttfamily [protected]}}



function pointer used in the initial conditions 



Definition at line 30 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a9388d5fd2167b87a3296d26f5e1188ef}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!vector\_of\_boundary\_elts@{vector\_of\_boundary\_elts}}
\index{vector\_of\_boundary\_elts@{vector\_of\_boundary\_elts}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{vector\_of\_boundary\_elts}
{\footnotesize\ttfamily typedef std\+::vector$<$\textbf{ Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Elt}$\ast$$>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::vector\+\_\+of\+\_\+boundary\+\_\+elts}\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 26 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_aeefa2f410cdec6269d4692ca5c200cd1}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!vector\_of\_elts@{vector\_of\_elts}}
\index{vector\_of\_elts@{vector\_of\_elts}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{vector\_of\_elts}
{\footnotesize\ttfamily typedef std\+::vector$<$\textbf{ Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Elt}$>$ \textbf{ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::vector\+\_\+of\+\_\+elts}\hspace{0.3cm}{\ttfamily [protected]}}



iterators for the vector of elements 



Definition at line 22 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.



\doxysubsubsection{Constructor \& Destructor Documentation}
\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a6a65261b8d103eda2869ef9d40790404}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!TwoD\_TVDLF\_Mesh@{TwoD\_TVDLF\_Mesh}}
\index{TwoD\_TVDLF\_Mesh@{TwoD\_TVDLF\_Mesh}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{TwoD\_TVDLF\_Mesh()}
{\footnotesize\ttfamily Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{X,  }\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{Y,  }\item[{\textbf{ Two\+D\+\_\+\+Hyperbolic\+\_\+\+System} $\ast$}]{ptr,  }\item[{\textbf{ fn\+\_\+ptr}}]{init\+\_\+ptr }\end{DoxyParamCaption})}



Constructor for the Finite Volume Mesh using linear elements. 


\begin{DoxyParams}{Parameters}
{\em X} & A vector of nodal locations at which the element F\+A\+C\+ES will positioned \\
\hline
{\em Y} & A vector of nodal locations at which the element F\+A\+C\+ES will positioned \\
\hline
{\em ptr} & A pointer to the hyperbolic system applied to this mesh \\
\hline
{\em init\+\_\+ptr} & A pointer to a function that defines the initial conditions \\
\hline
\end{DoxyParams}


Definition at line 16 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{18                                                     \{}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{21     std::cout << \textcolor{stringliteral}{"DEBUG: Starting construction of a TwoD\_TVDLF\_Mesh object. \(\backslash\)n"};}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{23     MESH\_TIME = 0.0;}
\DoxyCodeLine{24     NX = X.size();}
\DoxyCodeLine{25     NY = Y.size();}
\DoxyCodeLine{26     \textcolor{keywordflow}{if}(std::min(NX -\/ 1, NY -\/ 1) <= 1) \{}
\DoxyCodeLine{27       std::string problem;}
\DoxyCodeLine{28       problem = \textcolor{stringliteral}{" The TwoD\_TVDLF\_Mesh object is trying to construct itself \(\backslash\)n"};}
\DoxyCodeLine{29       problem += \textcolor{stringliteral}{" with just one element in one of the directions! \(\backslash\)n"};}
\DoxyCodeLine{30       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{31     \}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{34     std::cout << \textcolor{stringliteral}{"DEBUG: configuration of the black mesh \(\backslash\)n"};}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{36 }
\DoxyCodeLine{37     \textcolor{comment}{// reserve appropriate space to avoid re-\/allocation later}}
\DoxyCodeLine{38     BLACK\_ELTS.reserve((NX -\/ 1) * (NY -\/ 1));}
\DoxyCodeLine{39     RED\_ELTS.reserve(NX * NY);}
\DoxyCodeLine{40 }
\DoxyCodeLine{41     \textcolor{comment}{// set up the fn ptr to the initial conditions fn}}
\DoxyCodeLine{42     p\_Q\_INIT = init\_ptr;}
\DoxyCodeLine{43     \textcolor{comment}{// default limiter}}
\DoxyCodeLine{44     LIMITER = 0;}
\DoxyCodeLine{45     \textcolor{comment}{// store the order of the conservative system here for simplicity}}
\DoxyCodeLine{46     ORDER\_OF\_SYSTEM = ptr -\/> get\_order();}
\DoxyCodeLine{47 }
\DoxyCodeLine{48     \textcolor{comment}{// face index of edges}}
\DoxyCodeLine{49     std::set<int> faces\_s;}
\DoxyCodeLine{50     faces\_s.insert(0);}
\DoxyCodeLine{51     std::set<int> faces\_e;}
\DoxyCodeLine{52     faces\_e.insert(1);}
\DoxyCodeLine{53     std::set<int> faces\_n;}
\DoxyCodeLine{54     faces\_n.insert(2);}
\DoxyCodeLine{55     std::set<int> faces\_w;}
\DoxyCodeLine{56     faces\_w.insert(3);}
\DoxyCodeLine{57     \textcolor{comment}{// face indices of corners}}
\DoxyCodeLine{58     std::set<int> faces\_se(faces\_s);}
\DoxyCodeLine{59     faces\_se.insert(1);}
\DoxyCodeLine{60     std::set<int> faces\_ne(faces\_n);}
\DoxyCodeLine{61     faces\_ne.insert(1);}
\DoxyCodeLine{62     std::set<int> faces\_nw(faces\_n);}
\DoxyCodeLine{63     faces\_nw.insert(3);}
\DoxyCodeLine{64     std::set<int> faces\_sw(faces\_s);}
\DoxyCodeLine{65     faces\_sw.insert(3);}
\DoxyCodeLine{66     \textcolor{comment}{// set up the black elements}}
\DoxyCodeLine{67     \{}
\DoxyCodeLine{68       \textcolor{comment}{// southern row}}
\DoxyCodeLine{69       BLACK\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[0], X[1], Y[0], Y[1], ptr, \textcolor{keyword}{true}, faces\_sw));}
\DoxyCodeLine{70       \textcolor{keywordflow}{for}(std::size\_t i = 1; i <= NX -\/ 3; ++i) \{}
\DoxyCodeLine{71         BLACK\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[i], X[i+1], Y[0], Y[1], ptr, \textcolor{keyword}{true}, faces\_s));}
\DoxyCodeLine{72       \}}
\DoxyCodeLine{73       BLACK\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[NX-\/2], X[NX-\/1], Y[0], Y[1], ptr, \textcolor{keyword}{true}, faces\_se));}
\DoxyCodeLine{74       \textcolor{comment}{// interior elts}}
\DoxyCodeLine{75       \textcolor{keywordflow}{for}(std::size\_t j = 1; j <= NY -\/ 3; ++j) \{}
\DoxyCodeLine{76         BLACK\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[0], X[1], Y[j], Y[j+1], ptr, \textcolor{keyword}{true}, faces\_w));}
\DoxyCodeLine{77         \textcolor{keywordflow}{for}(std::size\_t i = 1; i <= NX -\/ 3; ++i) \{}
\DoxyCodeLine{78           BLACK\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[i], X[i+1], Y[j], Y[j+1], ptr));}
\DoxyCodeLine{79         \}}
\DoxyCodeLine{80         BLACK\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[NX-\/2], X[NX-\/1], Y[j], Y[j+1], ptr, \textcolor{keyword}{true}, faces\_e));}
\DoxyCodeLine{81       \}}
\DoxyCodeLine{82       \textcolor{comment}{// northern row}}
\DoxyCodeLine{83       BLACK\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[0], X[1], Y[NY-\/2], Y[NY-\/1], ptr, \textcolor{keyword}{true}, faces\_nw));}
\DoxyCodeLine{84       \textcolor{keywordflow}{for}(std::size\_t i = 1; i <= NX -\/ 3; ++i) \{}
\DoxyCodeLine{85         BLACK\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[i], X[i+1], Y[NY-\/2], Y[NY-\/1], ptr, \textcolor{keyword}{true}, faces\_n));}
\DoxyCodeLine{86       \}}
\DoxyCodeLine{87       BLACK\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[NX-\/2], X[NX-\/1], Y[NY-\/2], Y[NY-\/1], ptr, \textcolor{keyword}{true}, faces\_ne));}
\DoxyCodeLine{88     \}}
\DoxyCodeLine{89 }
\DoxyCodeLine{90 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{91     std::cout << \textcolor{stringliteral}{"DEBUG: configuration of the red mesh \(\backslash\)n"};}
\DoxyCodeLine{92 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{93 }
\DoxyCodeLine{94     \textcolor{comment}{// set up the red elements}}
\DoxyCodeLine{95     \{}
\DoxyCodeLine{96       \textcolor{comment}{// southern row}}
\DoxyCodeLine{97       RED\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[0], (X[1] + X[0]) / 2, Y[0], (Y[0] + Y[1]) / 2, ptr, \textcolor{keyword}{true}, faces\_sw));}
\DoxyCodeLine{98       \textcolor{keywordflow}{for}(std::size\_t i = 1; i <= NX -\/ 2; ++i) \{}
\DoxyCodeLine{99         RED\_ELTS.push\_back(TwoD\_TVDLF\_Elt((X[i-\/1] + X[i]) / 2, (X[i] + X[i+1]) / 2, Y[0], (Y[0] + Y[1]) / 2, ptr, \textcolor{keyword}{true}, faces\_s));}
\DoxyCodeLine{100       \}}
\DoxyCodeLine{101       RED\_ELTS.push\_back(TwoD\_TVDLF\_Elt((X[NX-\/2] + X[NX-\/1]) / 2, X[NX-\/1], Y[0], (Y[0] + Y[1]) / 2, ptr, \textcolor{keyword}{true}, faces\_se));}
\DoxyCodeLine{102       \textcolor{comment}{// interior elts}}
\DoxyCodeLine{103       \textcolor{keywordflow}{for}(std::size\_t j = 1; j <= NY -\/ 2; ++j) \{}
\DoxyCodeLine{104         RED\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[0], (X[1] + X[0]) / 2, (Y[j-\/1] + Y[j]) / 2, (Y[j] + Y[j+1]) / 2, ptr, \textcolor{keyword}{true}, faces\_w));}
\DoxyCodeLine{105         \textcolor{keywordflow}{for}(std::size\_t i = 1; i <= NX -\/ 2; ++i) \{}
\DoxyCodeLine{106           RED\_ELTS.push\_back(TwoD\_TVDLF\_Elt((X[i-\/1] + X[i]) / 2, (X[i] + X[i+1]) / 2, (Y[j-\/1] + Y[j]) / 2, (Y[j] + Y[j+1]) / 2, ptr));}
\DoxyCodeLine{107         \}}
\DoxyCodeLine{108         RED\_ELTS.push\_back(TwoD\_TVDLF\_Elt((X[NX-\/2] + X[NX-\/1]) / 2, X[NX-\/1], (Y[j-\/1] + Y[j]) / 2, (Y[j] + Y[j+1]) / 2, ptr, \textcolor{keyword}{true}, faces\_e));}
\DoxyCodeLine{109       \}}
\DoxyCodeLine{110       \textcolor{comment}{// northern row}}
\DoxyCodeLine{111       RED\_ELTS.push\_back(TwoD\_TVDLF\_Elt(X[0], (X[1] + X[0]) / 2, (Y[NY-\/2] + Y[NY-\/1]) / 2, Y[NY-\/1], ptr, \textcolor{keyword}{true}, faces\_nw));}
\DoxyCodeLine{112       \textcolor{keywordflow}{for}(std::size\_t i = 1; i <= NX -\/ 2; ++i) \{}
\DoxyCodeLine{113         RED\_ELTS.push\_back(TwoD\_TVDLF\_Elt((X[i-\/1] + X[i]) / 2, (X[i] + X[i+1]) / 2, (Y[NY-\/2] + Y[NY-\/1]) / 2, Y[NY-\/1], ptr, \textcolor{keyword}{true}, faces\_n));}
\DoxyCodeLine{114       \}}
\DoxyCodeLine{115       RED\_ELTS.push\_back(TwoD\_TVDLF\_Elt((X[NX-\/2] + X[NX-\/1]) / 2, X[NX-\/1], (Y[NY-\/2] + Y[NY-\/1]) / 2, Y[NY-\/1], ptr, \textcolor{keyword}{true}, faces\_ne));}
\DoxyCodeLine{116     \}}
\DoxyCodeLine{117 }
\DoxyCodeLine{118 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{119     std::cout << \textcolor{stringliteral}{"DEBUG: computing black to red projection \(\backslash\)n"};}
\DoxyCodeLine{120 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122     \textcolor{comment}{// Now we need to pre-\/compute the mesh projection from black-\/red-\/black.}}
\DoxyCodeLine{123     \textcolor{comment}{// Each element needs to know which element in the other mesh contributes}}
\DoxyCodeLine{124     \textcolor{comment}{// to it in the projection scheme. It also needs to know which of its faces}}
\DoxyCodeLine{125     \textcolor{comment}{// the element contributes to in the flux computation.}}
\DoxyCodeLine{126     \textcolor{comment}{// We assume the constructor is not required to be efficient \& just brute}}
\DoxyCodeLine{127     \textcolor{comment}{// force it here rather than working out all the index mappings by hand.}}
\DoxyCodeLine{128     \textcolor{comment}{//}}
\DoxyCodeLine{129     \textcolor{comment}{// loop through all the black elts}}
\DoxyCodeLine{130     elt\_iter eb = BLACK\_ELTS.begin();}
\DoxyCodeLine{131     \textcolor{keywordflow}{while}(eb != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{132       \textcolor{comment}{// local coordinates of the corners}}
\DoxyCodeLine{133       DenseVector<double> ne(2, 1.0);}
\DoxyCodeLine{134       DenseVector<double> sw(-\/ne);}
\DoxyCodeLine{135       DenseVector<double> se(2, 1.0);}
\DoxyCodeLine{136       se[ 1 ] = -\/1.0;}
\DoxyCodeLine{137       DenseVector<double> nw(-\/se);}
\DoxyCodeLine{138       \textcolor{comment}{// global coordinates of the corners}}
\DoxyCodeLine{139       DenseVector<double> bx\_sw = eb -\/> get\_x(sw);}
\DoxyCodeLine{140       DenseVector<double> bx\_ne = eb -\/> get\_x(ne);}
\DoxyCodeLine{141       DenseVector<double> bx\_nw = eb -\/> get\_x(nw);}
\DoxyCodeLine{142       DenseVector<double> bx\_se = eb -\/> get\_x(se);}
\DoxyCodeLine{143       \textcolor{comment}{// get an iterator to the red elt that contains each corner}}
\DoxyCodeLine{144       \textcolor{comment}{// \& add it as a contribution}}
\DoxyCodeLine{145       \textcolor{comment}{//}}
\DoxyCodeLine{146       \textcolor{comment}{// nw corner}}
\DoxyCodeLine{147       \{}
\DoxyCodeLine{148         \textcolor{comment}{//elt\_iter er = get\_elt\_iter\_from\_x( bx\_nw, "red" );}}
\DoxyCodeLine{149         elt\_iter er = get\_elt\_iter\_from\_elt\_iter(eb, \textcolor{stringliteral}{"red"}, 3);}
\DoxyCodeLine{150         DenseVector<double> s = er -\/> get\_s(bx\_nw);}
\DoxyCodeLine{151         DenseVector<double> s1(2, 0.0);}
\DoxyCodeLine{152         s1[ 0 ] = s[ 0 ];}
\DoxyCodeLine{153         s1[ 1 ] = -\/1.0;}
\DoxyCodeLine{154         DenseVector<double> s2(2, 0.0);}
\DoxyCodeLine{155         s2[ 0 ] = 1.0;}
\DoxyCodeLine{156         s2[ 1 ] = s[ 1 ];}
\DoxyCodeLine{157         eb -\/> add\_contribution(\&(*er), s1, s2, faces\_nw);}
\DoxyCodeLine{158       \}}
\DoxyCodeLine{159       \textcolor{comment}{// sw corner}}
\DoxyCodeLine{160       \{}
\DoxyCodeLine{161         \textcolor{comment}{//elt\_iter er = get\_elt\_iter\_from\_x( bx\_sw, "red" );}}
\DoxyCodeLine{162         elt\_iter er = get\_elt\_iter\_from\_elt\_iter(eb, \textcolor{stringliteral}{"red"}, 0);}
\DoxyCodeLine{163         DenseVector<double> s = er -\/> get\_s(bx\_sw);}
\DoxyCodeLine{164         DenseVector<double> s1(2, 0.0);}
\DoxyCodeLine{165         s1[ 0 ] = s[ 0 ];}
\DoxyCodeLine{166         s1[ 1 ] = s[ 1 ];}
\DoxyCodeLine{167         DenseVector<double> s2(2, 0.0);}
\DoxyCodeLine{168         s2[ 0 ] = 1.0;}
\DoxyCodeLine{169         s2[ 1 ] = 1.0;}
\DoxyCodeLine{170         eb -\/> add\_contribution(\&(*er), s1, s2, faces\_sw);}
\DoxyCodeLine{171       \}}
\DoxyCodeLine{172       \textcolor{comment}{// ne corner}}
\DoxyCodeLine{173       \{}
\DoxyCodeLine{174         \textcolor{comment}{//elt\_iter er = get\_elt\_iter\_from\_x( bx\_ne, "red" );}}
\DoxyCodeLine{175         elt\_iter er = get\_elt\_iter\_from\_elt\_iter(eb, \textcolor{stringliteral}{"red"}, 2);}
\DoxyCodeLine{176         DenseVector<double> s = er -\/> get\_s(bx\_ne);}
\DoxyCodeLine{177         DenseVector<double> s1(2, 0.0);}
\DoxyCodeLine{178         s1[ 0 ] = -\/1.0;}
\DoxyCodeLine{179         s1[ 1 ] = -\/1.0;}
\DoxyCodeLine{180         DenseVector<double> s2(2, 0.0);}
\DoxyCodeLine{181         s2[ 0 ] = s[ 0 ];}
\DoxyCodeLine{182         s2[ 1 ] = s[ 1 ];}
\DoxyCodeLine{183         eb -\/> add\_contribution(\&(*er), s1, s2, faces\_ne);}
\DoxyCodeLine{184       \}}
\DoxyCodeLine{185       \textcolor{comment}{// se corner}}
\DoxyCodeLine{186       \{}
\DoxyCodeLine{187         \textcolor{comment}{//elt\_iter er = get\_elt\_iter\_from\_x( bx\_se, "red" );}}
\DoxyCodeLine{188         elt\_iter er = get\_elt\_iter\_from\_elt\_iter(eb, \textcolor{stringliteral}{"red"}, 1);}
\DoxyCodeLine{189         DenseVector<double> s = er -\/> get\_s(bx\_se);}
\DoxyCodeLine{190         DenseVector<double> s1(2, 0.0);}
\DoxyCodeLine{191         s1[ 0 ] = -\/1.0;}
\DoxyCodeLine{192         s1[ 1 ] = s[ 1 ];}
\DoxyCodeLine{193         DenseVector<double> s2(2, 0.0);}
\DoxyCodeLine{194         s2[ 0 ] = s[ 0 ];}
\DoxyCodeLine{195         s2[ 1 ] = 1.0;}
\DoxyCodeLine{196         eb -\/> add\_contribution(\&(*er), s1, s2, faces\_se);}
\DoxyCodeLine{197       \}}
\DoxyCodeLine{198       ++eb;}
\DoxyCodeLine{199     \}}
\DoxyCodeLine{200 }
\DoxyCodeLine{201 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{202     std::cout << \textcolor{stringliteral}{"DEBUG: computing red to black projection \(\backslash\)n"};}
\DoxyCodeLine{203 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{204 }
\DoxyCodeLine{205     \textcolor{comment}{// now we need to set up the projection from red to black elts.}}
\DoxyCodeLine{206     \textcolor{comment}{// it's a little more tricky here as we have to avoid the external nodes.}}
\DoxyCodeLine{207     elt\_iter er = RED\_ELTS.begin();}
\DoxyCodeLine{208     \textcolor{keywordflow}{while}(er != RED\_ELTS.end()) \{}
\DoxyCodeLine{209       \textcolor{comment}{// local coordinates of the corners}}
\DoxyCodeLine{210       DenseVector<double> ne(2, 1.0);}
\DoxyCodeLine{211       DenseVector<double> sw(-\/ne);}
\DoxyCodeLine{212       DenseVector<double> se(2, 1.0);}
\DoxyCodeLine{213       se[ 1 ] = -\/1.0;}
\DoxyCodeLine{214       DenseVector<double> nw(-\/se);}
\DoxyCodeLine{215       \textcolor{comment}{// global coordinates of the corners}}
\DoxyCodeLine{216       DenseVector<double> bx\_sw = er -\/> get\_x(sw);}
\DoxyCodeLine{217       DenseVector<double> bx\_ne = er -\/> get\_x(ne);}
\DoxyCodeLine{218       DenseVector<double> bx\_nw = er -\/> get\_x(nw);}
\DoxyCodeLine{219       DenseVector<double> bx\_se = er -\/> get\_x(se);}
\DoxyCodeLine{220       \textcolor{comment}{//}}
\DoxyCodeLine{221       std::set<int> external = er -\/> get\_external\_faces();}
\DoxyCodeLine{222       \textcolor{keywordflow}{if}((external.find(2) == external.end()) \&\&}
\DoxyCodeLine{223           (external.find(3) == external.end())) \{}
\DoxyCodeLine{224         \textcolor{comment}{// nw corner is internal}}
\DoxyCodeLine{225         \textcolor{comment}{//elt\_iter eb = get\_elt\_iter\_from\_x( bx\_nw, "black" );}}
\DoxyCodeLine{226         elt\_iter eb = get\_elt\_iter\_from\_elt\_iter(er, \textcolor{stringliteral}{"black"}, 3);}
\DoxyCodeLine{227         DenseVector<double> s = eb -\/> get\_s(bx\_nw);}
\DoxyCodeLine{228         DenseVector<double> s1(2, 0.0);}
\DoxyCodeLine{229         s1[ 0 ] = s[ 0 ];}
\DoxyCodeLine{230         s1[ 1 ] = -\/1.0;}
\DoxyCodeLine{231         DenseVector<double> s2(2, 0.0);}
\DoxyCodeLine{232         s2[ 0 ] = 1.0;}
\DoxyCodeLine{233         s2[ 1 ] = s[ 1 ];}
\DoxyCodeLine{234         er -\/> add\_contribution(\&(*eb), s1, s2, faces\_nw);}
\DoxyCodeLine{235       \}}
\DoxyCodeLine{236       \textcolor{keywordflow}{if}((external.find(0) == external.end()) \&\&}
\DoxyCodeLine{237           (external.find(3) == external.end())) \{}
\DoxyCodeLine{238         \textcolor{comment}{// sw corner is internal}}
\DoxyCodeLine{239         \textcolor{comment}{//elt\_iter eb = get\_elt\_iter\_from\_x( bx\_sw, "black" );}}
\DoxyCodeLine{240         elt\_iter eb = get\_elt\_iter\_from\_elt\_iter(er, \textcolor{stringliteral}{"black"}, 0);}
\DoxyCodeLine{241         DenseVector<double> s = eb -\/> get\_s(bx\_sw);}
\DoxyCodeLine{242         DenseVector<double> s1(2, 0.0);}
\DoxyCodeLine{243         s1[ 0 ] = s[ 0 ];}
\DoxyCodeLine{244         s1[ 1 ] = s[ 1 ];}
\DoxyCodeLine{245         DenseVector<double> s2(2, 0.0);}
\DoxyCodeLine{246         s2[ 0 ] = 1.0;}
\DoxyCodeLine{247         s2[ 1 ] = 1.0;}
\DoxyCodeLine{248         er -\/> add\_contribution(\&(*eb), s1, s2, faces\_sw);}
\DoxyCodeLine{249       \}}
\DoxyCodeLine{250       \textcolor{keywordflow}{if}((external.find(1) == external.end()) \&\&}
\DoxyCodeLine{251           (external.find(2) == external.end())) \{}
\DoxyCodeLine{252         \textcolor{comment}{// ne corner is internal}}
\DoxyCodeLine{253         \textcolor{comment}{//elt\_iter eb = get\_elt\_iter\_from\_x( bx\_ne, "black" );}}
\DoxyCodeLine{254         elt\_iter eb = get\_elt\_iter\_from\_elt\_iter(er, \textcolor{stringliteral}{"black"}, 2);}
\DoxyCodeLine{255         DenseVector<double> s = eb -\/> get\_s(bx\_ne);}
\DoxyCodeLine{256         DenseVector<double> s1(2, 0.0);}
\DoxyCodeLine{257         s1[ 0 ] = -\/1.0;}
\DoxyCodeLine{258         s1[ 1 ] = -\/1.0;}
\DoxyCodeLine{259         DenseVector<double> s2(2, 0.0);}
\DoxyCodeLine{260         s2[ 0 ] = s[ 0 ];}
\DoxyCodeLine{261         s2[ 1 ] = s[ 1 ];}
\DoxyCodeLine{262         er -\/> add\_contribution(\&(*eb), s1, s2, faces\_ne);}
\DoxyCodeLine{263       \}}
\DoxyCodeLine{264       \textcolor{keywordflow}{if}((external.find(0) == external.end()) \&\&}
\DoxyCodeLine{265           (external.find(1) == external.end())) \{}
\DoxyCodeLine{266         \textcolor{comment}{// se corner is internal}}
\DoxyCodeLine{267         \textcolor{comment}{//elt\_iter eb = get\_elt\_iter\_from\_x( bx\_se, "black" );}}
\DoxyCodeLine{268         elt\_iter eb = get\_elt\_iter\_from\_elt\_iter(er, \textcolor{stringliteral}{"black"}, 1);}
\DoxyCodeLine{269         DenseVector<double> s = eb -\/> get\_s(bx\_se);}
\DoxyCodeLine{270         DenseVector<double> s1(2, 0.0);}
\DoxyCodeLine{271         s1[ 0 ] = -\/1.0;}
\DoxyCodeLine{272         s1[ 1 ] = s[ 1 ];}
\DoxyCodeLine{273         DenseVector<double> s2(2, 0.0);}
\DoxyCodeLine{274         s2[ 0 ] = s[ 0 ];}
\DoxyCodeLine{275         s2[ 1 ] = 1.0;}
\DoxyCodeLine{276         er -\/> add\_contribution(\&(*eb), s1, s2, faces\_se);}
\DoxyCodeLine{277       \}}
\DoxyCodeLine{278       ++er;}
\DoxyCodeLine{279     \}}
\DoxyCodeLine{280 }
\DoxyCodeLine{281 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{282     std::cout << \textcolor{stringliteral}{"DEBUG: setting up pointers to NESW elts in black mesh\(\backslash\)n"};}
\DoxyCodeLine{283 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{284 }
\DoxyCodeLine{285     \textcolor{comment}{// we need to set the pointers to neighbouring elts in both meshes}}
\DoxyCodeLine{286     eb = BLACK\_ELTS.begin();}
\DoxyCodeLine{287     \textcolor{keywordflow}{while}(eb != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{288       \textcolor{comment}{// the offset for computing N \& S elts is no. of faces minus one}}
\DoxyCodeLine{289       \textcolor{keyword}{const} std::size\_t offset(NX -\/ 1);}
\DoxyCodeLine{290       \textcolor{comment}{// get a set of external faces}}
\DoxyCodeLine{291       std::set< int > faces(eb -\/> get\_external\_faces());}
\DoxyCodeLine{292       \textcolor{keywordflow}{if}(eb -\/> face\_is\_internal(0)) \{}
\DoxyCodeLine{293         \textcolor{comment}{// southern face is internal}}
\DoxyCodeLine{294         eb -\/> set\_ptrs(0, \&(*eb) -\/ offset);}
\DoxyCodeLine{295       \}}
\DoxyCodeLine{296       \textcolor{keywordflow}{if}(eb -\/> face\_is\_internal(1)) \{}
\DoxyCodeLine{297         \textcolor{comment}{// eastern face is internal}}
\DoxyCodeLine{298         eb -\/> set\_ptrs(1, \&(*eb) + 1);}
\DoxyCodeLine{299       \}}
\DoxyCodeLine{300       \textcolor{keywordflow}{if}(eb -\/> face\_is\_internal(2)) \{}
\DoxyCodeLine{301         \textcolor{comment}{// northern face is internal}}
\DoxyCodeLine{302         eb -\/> set\_ptrs(2, \&(*eb) + offset);}
\DoxyCodeLine{303       \}}
\DoxyCodeLine{304       \textcolor{keywordflow}{if}(eb -\/> face\_is\_internal(3)) \{}
\DoxyCodeLine{305         \textcolor{comment}{// western face is internal}}
\DoxyCodeLine{306         eb -\/> set\_ptrs(3, \&(*eb) -\/ 1);}
\DoxyCodeLine{307       \}}
\DoxyCodeLine{308       ++eb;}
\DoxyCodeLine{309     \}}
\DoxyCodeLine{310 }
\DoxyCodeLine{311 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{312     std::cout << \textcolor{stringliteral}{"DEBUG: setting up pointers to NESW elts in red mesh\(\backslash\)n"};}
\DoxyCodeLine{313 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{314 }
\DoxyCodeLine{315     \textcolor{comment}{// we need to set the pointers to neighbouring elts in both meshes}}
\DoxyCodeLine{316     er = RED\_ELTS.begin();}
\DoxyCodeLine{317     \textcolor{keywordflow}{while}(er != RED\_ELTS.end()) \{}
\DoxyCodeLine{318       \textcolor{comment}{// the offset for computing N \& S elts is no. of faces}}
\DoxyCodeLine{319       \textcolor{comment}{// as the red mesh has an extra elt per row}}
\DoxyCodeLine{320       \textcolor{keyword}{const} std::size\_t offset(NX);}
\DoxyCodeLine{321       \textcolor{comment}{// get a set of external faces}}
\DoxyCodeLine{322       std::set< int > faces(er -\/> get\_external\_faces());}
\DoxyCodeLine{323       \textcolor{keywordflow}{if}(er -\/> face\_is\_internal(0)) \{}
\DoxyCodeLine{324         \textcolor{comment}{// southern face is internal}}
\DoxyCodeLine{325         er -\/> set\_ptrs(0, \&(*er) -\/ offset);}
\DoxyCodeLine{326       \}}
\DoxyCodeLine{327       \textcolor{keywordflow}{if}(er -\/> face\_is\_internal(1)) \{}
\DoxyCodeLine{328         \textcolor{comment}{// eastern face is internal}}
\DoxyCodeLine{329         er -\/> set\_ptrs(1, \&(*er) + 1);}
\DoxyCodeLine{330       \}}
\DoxyCodeLine{331       \textcolor{keywordflow}{if}(er -\/> face\_is\_internal(2)) \{}
\DoxyCodeLine{332         \textcolor{comment}{// northern face is internal}}
\DoxyCodeLine{333         er -\/> set\_ptrs(2, \&(*er) + offset);}
\DoxyCodeLine{334       \}}
\DoxyCodeLine{335       \textcolor{keywordflow}{if}(er -\/> face\_is\_internal(3)) \{}
\DoxyCodeLine{336         \textcolor{comment}{// western face is internal}}
\DoxyCodeLine{337         er -\/> set\_ptrs(3, \&(*er) -\/ 1);}
\DoxyCodeLine{338       \}}
\DoxyCodeLine{339       ++er;}
\DoxyCodeLine{340     \}}
\DoxyCodeLine{341 }
\DoxyCodeLine{342 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{343     std::cout << \textcolor{stringliteral}{"DEBUG: initialising the black mesh \(\backslash\)n"};}
\DoxyCodeLine{344 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{345 }
\DoxyCodeLine{346     \textcolor{comment}{// now all that remains is to initialise the starting (black) mesh}}
\DoxyCodeLine{347     eb = BLACK\_ELTS.begin();}
\DoxyCodeLine{348     \textcolor{keywordflow}{while}(eb != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{349       DenseVector<double> s(2, 0.0);}
\DoxyCodeLine{350       \textcolor{comment}{// compute to the east}}
\DoxyCodeLine{351       s[ 0 ] = 1.0;}
\DoxyCodeLine{352       s[ 1 ] = 0.0;}
\DoxyCodeLine{353       DenseVector<double> xe(eb -\/> get\_x(s));}
\DoxyCodeLine{354       DenseVector<double> Qe(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{355       p\_Q\_INIT(xe[0], xe[1], Qe);}
\DoxyCodeLine{356       \textcolor{comment}{// compute to the west}}
\DoxyCodeLine{357       s[ 0 ] = -\/1.0;}
\DoxyCodeLine{358       s[ 1 ] = 0.0;}
\DoxyCodeLine{359       DenseVector<double> xw(eb -\/> get\_x(s));}
\DoxyCodeLine{360       DenseVector<double> Qw(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{361       p\_Q\_INIT(xw[0], xw[1], Qw);}
\DoxyCodeLine{362       \textcolor{comment}{// compute to the north}}
\DoxyCodeLine{363       s[ 0 ] = 0.0;}
\DoxyCodeLine{364       s[ 1 ] = 1.0;}
\DoxyCodeLine{365       DenseVector<double> xn(eb -\/> get\_x(s));}
\DoxyCodeLine{366       DenseVector<double> Qn(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{367       p\_Q\_INIT(xn[0], xn[1], Qn);}
\DoxyCodeLine{368       \textcolor{comment}{// compute to the north}}
\DoxyCodeLine{369       s[ 0 ] = 0.0;}
\DoxyCodeLine{370       s[ 1 ] = -\/1.0;}
\DoxyCodeLine{371       DenseVector<double> xs(eb -\/> get\_x(s));}
\DoxyCodeLine{372       DenseVector<double> Qs(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{373       p\_Q\_INIT(xs[0], xs[1], Qs);}
\DoxyCodeLine{374       \textcolor{comment}{// difference for the slopes}}
\DoxyCodeLine{375       eb -\/> set\_slope\_x((Qe -\/ Qw) / (xe[0] -\/ xw[0]));}
\DoxyCodeLine{376       eb -\/> set\_slope\_y((Qn -\/ Qs) / (xn[1] -\/ xs[1]));}
\DoxyCodeLine{377       \textcolor{comment}{// set the mid value}}
\DoxyCodeLine{378       eb -\/> set\_Q\_mid((Qe + Qw + Qn + Qs) / 4);}
\DoxyCodeLine{379       ++eb;}
\DoxyCodeLine{380     \}}
\DoxyCodeLine{381 }
\DoxyCodeLine{382 \textcolor{preprocessor}{\#ifdef DEBUG}}
\DoxyCodeLine{383     std::cout << \textcolor{stringliteral}{"DEBUG: mesh constructor complete \(\backslash\)n"};}
\DoxyCodeLine{384 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{385 }
\DoxyCodeLine{386     \textcolor{comment}{// now all that remains is to initialise the starting (black) mesh}}
\DoxyCodeLine{387     eb = BLACK\_ELTS.begin();}
\DoxyCodeLine{388     \textcolor{keywordflow}{while}(eb != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{389       DenseVector<double> x(2, 0.0);}
\DoxyCodeLine{390       DenseVector<double> s(2, 0.0);}
\DoxyCodeLine{391       x = eb -\/> get\_x(s);}
\DoxyCodeLine{392       DenseVector<double> Q(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{393       p\_Q\_INIT(x[0], x[1], Q);}
\DoxyCodeLine{394       eb -\/> set\_Q\_mid(Q);}
\DoxyCodeLine{395       ++eb;}
\DoxyCodeLine{396     \}}
\DoxyCodeLine{397 }
\DoxyCodeLine{398     calc\_slopes(\&BLACK\_ELTS);}
\DoxyCodeLine{399 }
\DoxyCodeLine{400   \}}

\end{DoxyCode}


References B\+L\+A\+C\+K\+\_\+\+E\+L\+TS, calc\+\_\+slopes(), get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+elt\+\_\+iter(), L\+I\+M\+I\+T\+ER, M\+E\+S\+H\+\_\+\+T\+I\+ME, NX, NY, O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM, p\+\_\+\+Q\+\_\+\+I\+N\+IT, R\+E\+D\+\_\+\+E\+L\+TS, Cpp\+Noddy\+::\+Example\+::s, and Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::size().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_ae210235838224194f9545c1dd3849998}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!````~TwoD\_TVDLF\_Mesh@{$\sim$TwoD\_TVDLF\_Mesh}}
\index{````~TwoD\_TVDLF\_Mesh@{$\sim$TwoD\_TVDLF\_Mesh}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{$\sim$TwoD\_TVDLF\_Mesh()}
{\footnotesize\ttfamily Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::$\sim$\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Empty desctructor. 



Definition at line 402 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{403   \{\}}

\end{DoxyCode}


\doxysubsubsection{Member Function Documentation}
\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a203b976c6db22cf0dbcf20796a013939}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!actions\_before\_time\_step1@{actions\_before\_time\_step1}}
\index{actions\_before\_time\_step1@{actions\_before\_time\_step1}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{actions\_before\_time\_step1()}
{\footnotesize\ttfamily virtual void Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::actions\+\_\+before\+\_\+time\+\_\+step1 (\begin{DoxyParamCaption}\item[{const double \&}]{time\+\_\+step }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



A virtual method that is run before the first time update. 

For user-\/custom problems. 
\begin{DoxyParams}{Parameters}
{\em time\+\_\+step} & The time step size that is about to be taken \\
\hline
\end{DoxyParams}


Definition at line 110 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{110                                                                     \{}
\DoxyCodeLine{111       \textcolor{comment}{// Empty by default. If you want to take actions before the time}}
\DoxyCodeLine{112       \textcolor{comment}{// step then you need to inherit from this basic mesh and implement}}
\DoxyCodeLine{113       \textcolor{comment}{// this method.}}
\DoxyCodeLine{114     \}}

\end{DoxyCode}


Referenced by update().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_aed9fd85d2a5226c62f60925656152e65}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!actions\_before\_time\_step2@{actions\_before\_time\_step2}}
\index{actions\_before\_time\_step2@{actions\_before\_time\_step2}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{actions\_before\_time\_step2()}
{\footnotesize\ttfamily virtual void Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::actions\+\_\+before\+\_\+time\+\_\+step2 (\begin{DoxyParamCaption}\item[{const double \&}]{time\+\_\+step }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



A virtual method that is run before the second time update. 

For user-\/custom problems. 
\begin{DoxyParams}{Parameters}
{\em time\+\_\+step} & The time step size that is about to be taken \\
\hline
\end{DoxyParams}


Definition at line 119 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{119                                                                     \{}
\DoxyCodeLine{120       \textcolor{comment}{// Empty by default. If you want to take actions before the time}}
\DoxyCodeLine{121       \textcolor{comment}{// step then you need to inherit from this basic mesh and implement}}
\DoxyCodeLine{122       \textcolor{comment}{// this method.}}
\DoxyCodeLine{123     \}}

\end{DoxyCode}


Referenced by update().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a7a4d8a0d5ed65d2ebd25be43439b73d0}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!boundary\_diff@{boundary\_diff}}
\index{boundary\_diff@{boundary\_diff}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{boundary\_diff()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::boundary\+\_\+diff (\begin{DoxyParamCaption}\item[{\textbf{ elt\+\_\+iter}}]{e,  }\item[{const int \&}]{face\+\_\+index,  }\item[{\textbf{ Dense\+Vector}$<$ double $>$ \&}]{diff }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}



Given an element iterator and the local coordinate this will return zero for any components specified as inflow boundary conditions in line with Levy \& Tadmor (1997) and set the centre nodal value to the edge value. 


\begin{DoxyParams}{Parameters}
{\em e} & Element iterator \\
\hline
{\em face\+\_\+index} & The index of the face that is on a boundary \\
\hline
{\em diff} & A vector of derivatives \\
\hline
\end{DoxyParams}


Definition at line 892 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{892                                                                                                         \{}
\DoxyCodeLine{893     DenseVector<double> se(2, 0.0);}
\DoxyCodeLine{894     \textcolor{comment}{// get the appropriate local coordinate for the mid point on the edge}}
\DoxyCodeLine{895     \textcolor{keywordflow}{switch}(face\_index) \{}
\DoxyCodeLine{896     \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{897       \textcolor{comment}{// south}}
\DoxyCodeLine{898       se[ 0 ] = 0.0;}
\DoxyCodeLine{899       se[ 1 ] = -\/1.0;}
\DoxyCodeLine{900       \textcolor{keywordflow}{break};}
\DoxyCodeLine{901     \textcolor{keywordflow}{case} 1:}
\DoxyCodeLine{902       \textcolor{comment}{// east}}
\DoxyCodeLine{903       se[ 0 ] = 1.0;}
\DoxyCodeLine{904       se[ 1 ] = 0.0;}
\DoxyCodeLine{905       \textcolor{keywordflow}{break};}
\DoxyCodeLine{906     \textcolor{keywordflow}{case} 2:}
\DoxyCodeLine{907       \textcolor{comment}{// north}}
\DoxyCodeLine{908       se[ 0 ] = 0.0;}
\DoxyCodeLine{909       se[ 1 ] = 1.0;}
\DoxyCodeLine{910       \textcolor{keywordflow}{break};}
\DoxyCodeLine{911     \textcolor{keywordflow}{case} 3:}
\DoxyCodeLine{912       \textcolor{comment}{// west}}
\DoxyCodeLine{913       se[ 0 ] = -\/1.0;}
\DoxyCodeLine{914       se[ 1 ] = 0.0;}
\DoxyCodeLine{915       \textcolor{keywordflow}{break};}
\DoxyCodeLine{916     \}}
\DoxyCodeLine{917     \textcolor{comment}{// for the edge value}}
\DoxyCodeLine{918     DenseVector<double> Q(e -\/> get\_Q(se));}
\DoxyCodeLine{919     \textcolor{comment}{// look at the user-\/defined BCs for any defined Dirichlet conditions}}
\DoxyCodeLine{920     std::vector<bool> inflow = e -\/> p\_system -\/> edge\_values(face\_index, e -\/> get\_x(se), Q);}
\DoxyCodeLine{921     \textcolor{comment}{// the default is a zero slope in accordance with Levy \& Tadmor (1997)}}
\DoxyCodeLine{922     DenseVector<double> sigma\_n(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{923     \textcolor{comment}{// allow the user to override the zero slope}}
\DoxyCodeLine{924     e -\/> p\_system -\/> edge\_slopes(face\_index, e -\/> get\_x(se), sigma\_n);}
\DoxyCodeLine{925     \textcolor{comment}{// use edge values for inflow conditions}}
\DoxyCodeLine{926     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < ORDER\_OF\_SYSTEM; ++i) \{}
\DoxyCodeLine{927       \textcolor{keywordflow}{if}(inflow[ i ] == \textcolor{keyword}{true}) \{}
\DoxyCodeLine{928         \textcolor{comment}{// set a zero slope as per Levy \& Tadmor (1997)?}}
\DoxyCodeLine{929         diff[ i ] = sigma\_n[ i ];\textcolor{comment}{// ( Qe[ i ] -\/ Qm[ i ] ) / delta;}}
\DoxyCodeLine{930         \textcolor{comment}{//std::cout << face\_index << " " << diff[ i ] << "\(\backslash\)n";}}
\DoxyCodeLine{931       \}}
\DoxyCodeLine{932     \}}
\DoxyCodeLine{933   \}}

\end{DoxyCode}


References O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM.



Referenced by east\+\_\+diff(), E\+W\+\_\+diff(), north\+\_\+diff(), N\+S\+\_\+diff(), south\+\_\+diff(), and west\+\_\+diff().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a354fcfb39abcc4339df6443af1fea785}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!calc\_slopes@{calc\_slopes}}
\index{calc\_slopes@{calc\_slopes}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{calc\_slopes()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::calc\+\_\+slopes (\begin{DoxyParamCaption}\item[{\textbf{ vector\+\_\+of\+\_\+elts} $\ast$}]{elt\+\_\+vector }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Use the appropriate limiter to approximate the slope in each element in the mesh. 

The slopes will be sent down to the element objects and then onto the face objects. 
\begin{DoxyParams}{Parameters}
{\em elt\+\_\+vector} & The vector of elements to set the slope for \\
\hline
\end{DoxyParams}
superbee

Definition at line 690 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{690                                                               \{}
\DoxyCodeLine{691     set\_boundary\_Q(elt\_vector);}
\DoxyCodeLine{692     elt\_iter e(elt\_vector -\/> begin());}
\DoxyCodeLine{693     DenseVector<double> slope\_east(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{694     DenseVector<double> slope\_west(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{695     DenseVector<double> slope\_north(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{696     DenseVector<double> slope\_south(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{697     \textcolor{keywordflow}{switch}(LIMITER) \{}
\DoxyCodeLine{698     \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{699       \textcolor{comment}{// minmod}}
\DoxyCodeLine{700       \textcolor{keywordflow}{while}(e != elt\_vector -\/> end()) \{}
\DoxyCodeLine{701         slope\_east = east\_diff(e);}
\DoxyCodeLine{702         slope\_west = west\_diff(e);}
\DoxyCodeLine{703         slope\_south = south\_diff(e);}
\DoxyCodeLine{704         slope\_north = north\_diff(e);}
\DoxyCodeLine{705         e -\/> set\_slope\_x(minmod(slope\_east, slope\_west));}
\DoxyCodeLine{706         e -\/> set\_slope\_y(minmod(slope\_north, slope\_south));}
\DoxyCodeLine{707         ++e;}
\DoxyCodeLine{708       \}}
\DoxyCodeLine{709       \textcolor{keywordflow}{break};}
\DoxyCodeLine{710     \textcolor{keywordflow}{case} 1:}
\DoxyCodeLine{711       \textcolor{comment}{// MC}}
\DoxyCodeLine{712       \textcolor{keywordflow}{while}(e != elt\_vector -\/> end()) \{}
\DoxyCodeLine{713         slope\_east = east\_diff(e);}
\DoxyCodeLine{714         slope\_west = west\_diff(e);}
\DoxyCodeLine{715         DenseVector<double> slope\_ew(EW\_diff(e));}
\DoxyCodeLine{716         slope\_south = south\_diff(e);}
\DoxyCodeLine{717         slope\_north = north\_diff(e);}
\DoxyCodeLine{718         DenseVector<double> slope\_ns(NS\_diff(e));}
\DoxyCodeLine{719         \textcolor{keyword}{const} DenseVector<double> temp\_x(minmod(slope\_east * 2, slope\_west * 2));}
\DoxyCodeLine{720         \textcolor{keyword}{const} DenseVector<double> slope\_x(minmod(temp\_x, slope\_ew));}
\DoxyCodeLine{721         \textcolor{keyword}{const} DenseVector<double> temp\_y(minmod(slope\_north * 2, slope\_south * 2));}
\DoxyCodeLine{722         \textcolor{keyword}{const} DenseVector<double> slope\_y(minmod(temp\_y, slope\_ns));}
\DoxyCodeLine{723         e -\/> set\_slope\_x(slope\_x);}
\DoxyCodeLine{724         e -\/> set\_slope\_y(slope\_y);}
\DoxyCodeLine{725         ++e;}
\DoxyCodeLine{726       \}}
\DoxyCodeLine{727     \textcolor{keywordflow}{case} 2:\textcolor{comment}{}}
\DoxyCodeLine{728 \textcolor{comment}{      /// superbee}}
\DoxyCodeLine{729 \textcolor{comment}{}      \textcolor{keywordflow}{while}(e != elt\_vector -\/> end()) \{}
\DoxyCodeLine{730         slope\_east = east\_diff(e);}
\DoxyCodeLine{731         slope\_west = west\_diff(e);}
\DoxyCodeLine{732         slope\_south = south\_diff(e);}
\DoxyCodeLine{733         slope\_north = north\_diff(e);}
\DoxyCodeLine{734         \textcolor{keyword}{const} DenseVector<double> slope\_x = maxmod(}
\DoxyCodeLine{735                                               minmod(slope\_east, slope\_west * 2.),}
\DoxyCodeLine{736                                               minmod(slope\_east * 2., slope\_west)}
\DoxyCodeLine{737                                             );}
\DoxyCodeLine{738         e -\/> set\_slope\_x(slope\_x);}
\DoxyCodeLine{739         \textcolor{keyword}{const} DenseVector<double> slope\_y = maxmod(}
\DoxyCodeLine{740                                               minmod(slope\_north, slope\_south * 2.),}
\DoxyCodeLine{741                                               minmod(slope\_north * 2., slope\_south)}
\DoxyCodeLine{742                                             );}
\DoxyCodeLine{743         e -\/> set\_slope\_y(slope\_y);}
\DoxyCodeLine{744         ++e;}
\DoxyCodeLine{745       \}}
\DoxyCodeLine{746       \textcolor{keywordflow}{break};}
\DoxyCodeLine{747     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{748       std::string problem;}
\DoxyCodeLine{749       problem = \textcolor{stringliteral}{" The TwoD\_TVDLF\_Mesh object has an unrecognised 'LIMITER' identifier. \(\backslash\)n"};}
\DoxyCodeLine{750       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{751     \}}
\DoxyCodeLine{752   \}}

\end{DoxyCode}


References east\+\_\+diff(), E\+W\+\_\+diff(), L\+I\+M\+I\+T\+ER, maxmod(), minmod(), north\+\_\+diff(), N\+S\+\_\+diff(), O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM, set\+\_\+boundary\+\_\+\+Q(), south\+\_\+diff(), and west\+\_\+diff().



Referenced by Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh(), and update().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a6c1396780150f6e4aadf04c22a4bf9ba}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!dump\_data@{dump\_data}}
\index{dump\_data@{dump\_data}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{dump\_data()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::dump\+\_\+data (\begin{DoxyParamCaption}\item[{std\+::string}]{filename }\end{DoxyParamCaption})}



Dump the data over the nodal positions to a given filename. 


\begin{DoxyParams}{Parameters}
{\em filename} & The filename to be generated \\
\hline
\end{DoxyParams}


Definition at line 465 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{465                                                     \{}
\DoxyCodeLine{466     std::ofstream dump;}
\DoxyCodeLine{467     dump.open(filename.c\_str());}
\DoxyCodeLine{468     dump.precision(6);}
\DoxyCodeLine{469     elt\_iter e;}
\DoxyCodeLine{470     DenseVector<double> s(2, 0.0);}
\DoxyCodeLine{471     \{}
\DoxyCodeLine{472       e = BLACK\_ELTS.begin();}
\DoxyCodeLine{473       \textcolor{keywordflow}{while}(e != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{474         \textcolor{keywordflow}{for}(std::size\_t i = 0; i < ORDER\_OF\_SYSTEM; ++i) \{}
\DoxyCodeLine{475           dump << e -\/> get\_Q(s)[i] << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{476         \}}
\DoxyCodeLine{477         dump << e -\/> get\_max\_dt() << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{478         \textcolor{comment}{// for(std::size\_t i = 0; i < ORDER\_OF\_SYSTEM; ++i) \{}}
\DoxyCodeLine{479         \textcolor{comment}{//   dump << e -\/> get\_slope\_x()[i] << " ";}}
\DoxyCodeLine{480         \textcolor{comment}{// \}}}
\DoxyCodeLine{481         \textcolor{comment}{// for(std::size\_t i = 0; i < ORDER\_OF\_SYSTEM; ++i) \{}}
\DoxyCodeLine{482         \textcolor{comment}{//   dump << e -\/> get\_slope\_y()[i] << " ";}}
\DoxyCodeLine{483         \textcolor{comment}{// \}}}
\DoxyCodeLine{484         dump << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{485         ++e;}
\DoxyCodeLine{486       \}}
\DoxyCodeLine{487     \}}
\DoxyCodeLine{488     dump.close();}
\DoxyCodeLine{489   \}}

\end{DoxyCode}


References B\+L\+A\+C\+K\+\_\+\+E\+L\+TS, O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM, and Cpp\+Noddy\+::\+Example\+::s.

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a3450e76ae84e6d434893141ea4033fc5}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!dump\_gnu@{dump\_gnu}}
\index{dump\_gnu@{dump\_gnu}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{dump\_gnu()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::dump\+\_\+gnu (\begin{DoxyParamCaption}\item[{std\+::string}]{filename }\end{DoxyParamCaption})}



Dump the data to a given filename in a gnuplot format. 


\begin{DoxyParams}{Parameters}
{\em filename} & The filename to be generated \\
\hline
\end{DoxyParams}


Definition at line 405 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{405                                                    \{}
\DoxyCodeLine{406     std::ofstream dump;}
\DoxyCodeLine{407     dump.open(filename.c\_str());}
\DoxyCodeLine{408     dump.precision(6);}
\DoxyCodeLine{409     DenseVector<double> s(2, 0.0);}
\DoxyCodeLine{410     \{}
\DoxyCodeLine{411       elt\_iter e(BLACK\_ELTS.begin());}
\DoxyCodeLine{412       \textcolor{keywordflow}{while}(e != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{413         dump << e -\/> get\_x(s)[0] << \textcolor{stringliteral}{" "} << e -\/> get\_x(s)[1] << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{414         \textcolor{keywordflow}{for}(std::size\_t i = 0; i < ORDER\_OF\_SYSTEM; ++i) \{}
\DoxyCodeLine{415           dump << e -\/> get\_Q(s)[i] << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{416         \}}
\DoxyCodeLine{417         dump << e -\/> get\_max\_dt();}
\DoxyCodeLine{418         \textcolor{comment}{// for(std::size\_t i = 0; i < ORDER\_OF\_SYSTEM; ++i) \{}}
\DoxyCodeLine{419         \textcolor{comment}{//   dump << e -\/> get\_slope\_x()[i] << " ";}}
\DoxyCodeLine{420         \textcolor{comment}{// \}}}
\DoxyCodeLine{421         \textcolor{comment}{// for(std::size\_t i = 0; i < ORDER\_OF\_SYSTEM; ++i) \{}}
\DoxyCodeLine{422         \textcolor{comment}{//   dump << e -\/> get\_slope\_y()[i] << " ";}}
\DoxyCodeLine{423         \textcolor{comment}{// \}}}
\DoxyCodeLine{424         dump << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{425         \textcolor{keywordflow}{if}(e -\/> face\_is\_external(1))}
\DoxyCodeLine{426           dump << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{427         ++e;}
\DoxyCodeLine{428       \}}
\DoxyCodeLine{429     \}}
\DoxyCodeLine{430     dump.close();}
\DoxyCodeLine{431   \}}

\end{DoxyCode}


References B\+L\+A\+C\+K\+\_\+\+E\+L\+TS, O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM, and Cpp\+Noddy\+::\+Example\+::s.



Referenced by main().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_ad5d7083ea9111d0b5df6ee699d6cbfe5}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!dump\_nodes\_x@{dump\_nodes\_x}}
\index{dump\_nodes\_x@{dump\_nodes\_x}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{dump\_nodes\_x()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::dump\+\_\+nodes\+\_\+x (\begin{DoxyParamCaption}\item[{std\+::string}]{filename }\end{DoxyParamCaption}) const}



Dump the x-\/nodal positions to a given filename. 

This method only applies to regular structured meshes. 
\begin{DoxyParams}{Parameters}
{\em filename} & The filename to be generated \\
\hline
\end{DoxyParams}


Definition at line 433 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{433                                                              \{}
\DoxyCodeLine{434     std::ofstream dump;}
\DoxyCodeLine{435     dump.open(filename.c\_str());}
\DoxyCodeLine{436     dump.precision(6);}
\DoxyCodeLine{437     DenseVector<double> s(2, 0.0);}
\DoxyCodeLine{438     celt\_iter e;}
\DoxyCodeLine{439     \{}
\DoxyCodeLine{440       e = BLACK\_ELTS.begin();}
\DoxyCodeLine{441       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i = 0; i < NX -\/ 1; ++i) \{}
\DoxyCodeLine{442         dump << e -\/> get\_x(s)[0] << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{443         ++e;}
\DoxyCodeLine{444       \}}
\DoxyCodeLine{445     \}}
\DoxyCodeLine{446     dump.close();}
\DoxyCodeLine{447   \}}

\end{DoxyCode}


References B\+L\+A\+C\+K\+\_\+\+E\+L\+TS, NX, and Cpp\+Noddy\+::\+Example\+::s.

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_ac1b46c3c206b958e939d64e170ede389}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!dump\_nodes\_y@{dump\_nodes\_y}}
\index{dump\_nodes\_y@{dump\_nodes\_y}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{dump\_nodes\_y()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::dump\+\_\+nodes\+\_\+y (\begin{DoxyParamCaption}\item[{std\+::string}]{filename }\end{DoxyParamCaption}) const}



Dump the y-\/nodal positions to a given filename. 

This method only applies to regular structured meshes. 
\begin{DoxyParams}{Parameters}
{\em filename} & The filename to be generated \\
\hline
\end{DoxyParams}


Definition at line 449 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{449                                                              \{}
\DoxyCodeLine{450     std::ofstream dump;}
\DoxyCodeLine{451     dump.open(filename.c\_str());}
\DoxyCodeLine{452     dump.precision(6);}
\DoxyCodeLine{453     DenseVector<double> s(2, 0.0);}
\DoxyCodeLine{454     celt\_iter e;}
\DoxyCodeLine{455     \{}
\DoxyCodeLine{456       e = BLACK\_ELTS.begin();}
\DoxyCodeLine{457       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i = 0; i < NY -\/ 1; ++i) \{}
\DoxyCodeLine{458         dump << e -\/> get\_x(s)[1] << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{459         e += NX -\/ 1;}
\DoxyCodeLine{460       \}}
\DoxyCodeLine{461     \}}
\DoxyCodeLine{462     dump.close();}
\DoxyCodeLine{463   \}}

\end{DoxyCode}


References B\+L\+A\+C\+K\+\_\+\+E\+L\+TS, NX, NY, and Cpp\+Noddy\+::\+Example\+::s.

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a4ae13c130c1bd373509d98a2759507c0}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!east\_diff@{east\_diff}}
\index{east\_diff@{east\_diff}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{east\_diff()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::east\+\_\+diff (\begin{DoxyParamCaption}\item[{\textbf{ elt\+\_\+iter}}]{e }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}



Compute a finite difference approximation of the derivative in the compass direction. 


\begin{DoxyParams}{Parameters}
{\em e} & The iterator to the element that we want the derivative for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The spatial derivative of the vector system 
\end{DoxyReturn}


Definition at line 754 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{754                                                                  \{}
\DoxyCodeLine{755     DenseVector<double> diff(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{756     std::set< int > faces(e -\/> get\_external\_faces());}
\DoxyCodeLine{757     \textcolor{keyword}{const} \textcolor{keywordtype}{int} face\_index(1);}
\DoxyCodeLine{758     \textcolor{keywordflow}{if}(e -\/> face\_is\_external(face\_index)) \{}
\DoxyCodeLine{759       \textcolor{comment}{// interior difference}}
\DoxyCodeLine{760       diff = west\_diff(e);}
\DoxyCodeLine{761       boundary\_diff(e, face\_index, diff);}
\DoxyCodeLine{762     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{763       \textcolor{comment}{// We're not on an edge, so we can difference}}
\DoxyCodeLine{764       elt\_iter j(e -\/> get\_ptrs(face\_index));}
\DoxyCodeLine{765       diff = (j -\/> get\_Q\_mid() -\/ e -\/> get\_Q\_mid())}
\DoxyCodeLine{766              / (j -\/> get\_x\_mid()[0] -\/ e -\/> get\_x\_mid()[0]);}
\DoxyCodeLine{767     \}}
\DoxyCodeLine{768     \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{769   \}}

\end{DoxyCode}


References boundary\+\_\+diff(), O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM, and west\+\_\+diff().



Referenced by calc\+\_\+slopes(), E\+W\+\_\+diff(), and west\+\_\+diff().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a44a8b95212d1c9f44c71dd2adc976d94}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!EW\_diff@{EW\_diff}}
\index{EW\_diff@{EW\_diff}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{EW\_diff()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::\+E\+W\+\_\+diff (\begin{DoxyParamCaption}\item[{\textbf{ elt\+\_\+iter}}]{e }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Compute a finite difference approximation of the derivative in the compass direction. 


\begin{DoxyParams}{Parameters}
{\em e} & The iterator to the element that we want the derivative for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The spatial derivative of the vector system 
\end{DoxyReturn}


Definition at line 843 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{843                                                          \{}
\DoxyCodeLine{844     DenseVector<double> diff(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{845     std::set< int > faces(e -\/> get\_external\_faces());}
\DoxyCodeLine{846     \textcolor{keywordflow}{if}(e -\/> face\_is\_external(1)) \{}
\DoxyCodeLine{847       \textcolor{comment}{// interior difference}}
\DoxyCodeLine{848       diff = west\_diff(e);}
\DoxyCodeLine{849       boundary\_diff(e, 1, diff);}
\DoxyCodeLine{850     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(e -\/> face\_is\_external(3)) \{}
\DoxyCodeLine{851       \textcolor{comment}{// interior difference}}
\DoxyCodeLine{852       diff = east\_diff(e);}
\DoxyCodeLine{853       boundary\_diff(e, 3, diff);}
\DoxyCodeLine{854     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{855       \textcolor{comment}{// We're not on an edge, so we can difference}}
\DoxyCodeLine{856       elt\_iter jE(e -\/> get\_ptrs(1));}
\DoxyCodeLine{857       elt\_iter jW(e -\/> get\_ptrs(3));}
\DoxyCodeLine{858       diff = (jE -\/> get\_Q\_mid() -\/ jW -\/> get\_Q\_mid())}
\DoxyCodeLine{859              / (jE -\/> get\_x\_mid()[0] -\/ jW -\/> get\_x\_mid()[0]);}
\DoxyCodeLine{860     \}}
\DoxyCodeLine{861     \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{862   \}}

\end{DoxyCode}


References boundary\+\_\+diff(), east\+\_\+diff(), O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM, and west\+\_\+diff().



Referenced by calc\+\_\+slopes().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a8fc30fe7542106e3d4fb8710772af594}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!get\_elt\_iter\_from\_elt\_iter@{get\_elt\_iter\_from\_elt\_iter}}
\index{get\_elt\_iter\_from\_elt\_iter@{get\_elt\_iter\_from\_elt\_iter}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{get\_elt\_iter\_from\_elt\_iter()}
{\footnotesize\ttfamily \textbf{ elt\+\_\+iter} Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+elt\+\_\+iter (\begin{DoxyParamCaption}\item[{\textbf{ elt\+\_\+iter}}]{e,  }\item[{std\+::string}]{target\+\_\+colour,  }\item[{int}]{corner\+\_\+index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



Given an element in the I\+N\+I\+T\+I\+AL S\+T\+R\+U\+C\+T\+U\+R\+ED M\+E\+SH, this method will return an iterator to an element in the other mesh that overlaps the corner specified by corner\+\_\+index. 


\begin{DoxyParams}{Parameters}
{\em e} & An element iterator to the source element \\
\hline
{\em target\+\_\+colour} & The colour of the target mesh, ie. N\+OT the one that iterator \textquotesingle{}e\textquotesingle{} is in \\
\hline
{\em corner\+\_\+index} & The index of the corner to be considered 0,1,2,3 for SW, SE, NE, NW. \\
\hline
\end{DoxyParams}


Definition at line 139 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{141                                                           \{}
\DoxyCodeLine{142       \textcolor{comment}{// for corners SW,SE,NE,NW:}}
\DoxyCodeLine{143       \textcolor{comment}{// black (i,j) -\/> red   (i,j),(i+1,j),(i+1,j+1),(i,j+1)}}
\DoxyCodeLine{144       \textcolor{comment}{//  =>  j*Bx+i -\/> j*Rx+i etc}}
\DoxyCodeLine{145       \textcolor{comment}{// red   (i,j) -\/> black (i-\/1,j-\/1),(i,j-\/1),(i,j),(i-\/1,j)}}
\DoxyCodeLine{146       \textcolor{comment}{//  =>  j*Rx+i -\/> (j-\/1)*Bx+i-\/1 etc}}
\DoxyCodeLine{147       \textcolor{comment}{//dimensions of the Black (Bx times By) \& Red (Rx times Ry) meshes}}
\DoxyCodeLine{148       \textcolor{comment}{//}}
\DoxyCodeLine{149       vector\_of\_elts* target\_elts(NULL);}
\DoxyCodeLine{150       \textcolor{keywordtype}{int} k(0);}
\DoxyCodeLine{151       \textcolor{keywordtype}{int} Bx(NX -\/ 1);}
\DoxyCodeLine{152       \textcolor{keywordtype}{int} By(NY -\/ 1);}
\DoxyCodeLine{153       \textcolor{keywordtype}{int} Rx(NX);}
\DoxyCodeLine{154       \textcolor{keywordtype}{int} Ry(NY);}
\DoxyCodeLine{155       \textcolor{comment}{//}}
\DoxyCodeLine{156       \textcolor{keywordflow}{if}(target\_colour == \textcolor{stringliteral}{"red"}) \{}
\DoxyCodeLine{157         \textcolor{keywordtype}{int} offset(e -\/ BLACK\_ELTS.begin());}
\DoxyCodeLine{158         target\_elts = \&RED\_ELTS;}
\DoxyCodeLine{159         \textcolor{keywordtype}{int} i, j, l, m;}
\DoxyCodeLine{160         \textcolor{comment}{//std::cout << " offset =  " << offset << "\(\backslash\)n";}}
\DoxyCodeLine{161         i = offset \% Bx;}
\DoxyCodeLine{162         j = (offset -\/ i) / Bx;}
\DoxyCodeLine{163         \textcolor{keywordflow}{switch}(corner\_index) \{}
\DoxyCodeLine{164         \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{165           l = i;}
\DoxyCodeLine{166           m = j;}
\DoxyCodeLine{167           \textcolor{keywordflow}{break};}
\DoxyCodeLine{168         \textcolor{keywordflow}{case} 1:}
\DoxyCodeLine{169           l = i + 1;}
\DoxyCodeLine{170           m = j;}
\DoxyCodeLine{171           \textcolor{keywordflow}{break};}
\DoxyCodeLine{172         \textcolor{keywordflow}{case} 2:}
\DoxyCodeLine{173           l = i + 1;}
\DoxyCodeLine{174           m = j + 1;}
\DoxyCodeLine{175           \textcolor{keywordflow}{break};}
\DoxyCodeLine{176         \textcolor{keywordflow}{case} 3:}
\DoxyCodeLine{177           l = i;}
\DoxyCodeLine{178           m = j + 1;}
\DoxyCodeLine{179           \textcolor{keywordflow}{break};}
\DoxyCodeLine{180         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{181           l = 0;}
\DoxyCodeLine{182           m = 0;}
\DoxyCodeLine{183           assert(\textcolor{keyword}{false});}
\DoxyCodeLine{184         \}}
\DoxyCodeLine{185         \textcolor{comment}{// dont return outside the mesh}}
\DoxyCodeLine{186         \textcolor{comment}{//std::cout << source\_colour << " " << i << "," << j << " -\/> " << l << "," << m <<"\(\backslash\)n";}}
\DoxyCodeLine{187         l = std::min(l, Rx);}
\DoxyCodeLine{188         l = std::max(l, 0);}
\DoxyCodeLine{189         m = std::min(m, Ry);}
\DoxyCodeLine{190         m = std::max(m, 0);}
\DoxyCodeLine{191         k = m * Rx + l;}
\DoxyCodeLine{192         \textcolor{comment}{//std::cout << source\_colour << " " << i << "," << j << " -\/> " << l << "," << m <<"\(\backslash\)n";}}
\DoxyCodeLine{193         \textcolor{comment}{//std::cout << "-\/-\/\(\backslash\)n";}}
\DoxyCodeLine{194       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(target\_colour == \textcolor{stringliteral}{"black"}) \{}
\DoxyCodeLine{195         \textcolor{keywordtype}{int} offset(e -\/ RED\_ELTS.begin());}
\DoxyCodeLine{196         target\_elts = \&BLACK\_ELTS;}
\DoxyCodeLine{197         \textcolor{keywordtype}{int} i, j, l, m;}
\DoxyCodeLine{198         i = offset \% Rx;}
\DoxyCodeLine{199         j = (offset -\/ i) / Rx;}
\DoxyCodeLine{200         \textcolor{keywordflow}{switch}(corner\_index) \{}
\DoxyCodeLine{201         \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{202           l = i -\/ 1;}
\DoxyCodeLine{203           m = j -\/ 1;}
\DoxyCodeLine{204           \textcolor{keywordflow}{break};}
\DoxyCodeLine{205         \textcolor{keywordflow}{case} 1:}
\DoxyCodeLine{206           l = i;}
\DoxyCodeLine{207           m = j -\/ 1;}
\DoxyCodeLine{208           \textcolor{keywordflow}{break};}
\DoxyCodeLine{209         \textcolor{keywordflow}{case} 2:}
\DoxyCodeLine{210           l = i;}
\DoxyCodeLine{211           m = j;}
\DoxyCodeLine{212           \textcolor{keywordflow}{break};}
\DoxyCodeLine{213         \textcolor{keywordflow}{case} 3:}
\DoxyCodeLine{214           l = i -\/ 1;}
\DoxyCodeLine{215           m = j;}
\DoxyCodeLine{216           \textcolor{keywordflow}{break};}
\DoxyCodeLine{217         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{218           l = 0;}
\DoxyCodeLine{219           m = 0;}
\DoxyCodeLine{220           assert(\textcolor{keyword}{false});}
\DoxyCodeLine{221         \}}
\DoxyCodeLine{222         \textcolor{comment}{// dont return outside the mesh}}
\DoxyCodeLine{223         l = std::min(l, Bx);}
\DoxyCodeLine{224         l = std::max(l, 0);}
\DoxyCodeLine{225         m = std::min(m, By);}
\DoxyCodeLine{226         m = std::max(m, 0);}
\DoxyCodeLine{227         k = m * Bx + l;}
\DoxyCodeLine{228       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{229         \textcolor{comment}{// throw}}
\DoxyCodeLine{230       \}}
\DoxyCodeLine{231       \textcolor{keywordflow}{return} target\_elts -\/> begin() + k;}
\DoxyCodeLine{232     \}}

\end{DoxyCode}


References B\+L\+A\+C\+K\+\_\+\+E\+L\+TS, m, NX, NY, and R\+E\+D\+\_\+\+E\+L\+TS.



Referenced by Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_aef6c78faf5d008421c13e71c024dbe1e}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!get\_elt\_iter\_from\_x@{get\_elt\_iter\_from\_x}}
\index{get\_elt\_iter\_from\_x@{get\_elt\_iter\_from\_x}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{get\_elt\_iter\_from\_x()}
{\footnotesize\ttfamily std\+::vector$<$ \textbf{ Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Elt} $>$\+::iterator Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+x (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{x,  }\item[{std\+::string}]{mesh\+\_\+colour = {\ttfamily \char`\"{}black\char`\"{}} }\end{DoxyParamCaption})}



Given a global coordinate, return a pointer to the elt that contains that point. 

Because the elts are stored in a vector, and are logically in a rectangular grid, we first hunt for the column, then the appropriate row. 
\begin{DoxyParams}{Parameters}
{\em x} & A vector global coordinate \\
\hline
{\em mesh\+\_\+colour} & A string identifier of the mesh to be searched \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the element containing the global coordinate 
\end{DoxyReturn}


Definition at line 618 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{618                                                                                                                             \{}
\DoxyCodeLine{619     elt\_iter found\_elt;}
\DoxyCodeLine{620     vector\_of\_elts* elts(get\_elts\_from\_colour(mesh\_colour));}
\DoxyCodeLine{621     std::size\_t Mx(get\_number\_elts\_in\_x(mesh\_colour));}
\DoxyCodeLine{622 }
\DoxyCodeLine{623     elt\_iter e = elts -\/> begin();}
\DoxyCodeLine{624     \textcolor{keywordflow}{while}(e != elts -\/> end()) \{}
\DoxyCodeLine{625       \textcolor{comment}{// local coordinates of the NE and SW corners}}
\DoxyCodeLine{626       DenseVector<double> ne(2, 1.0);}
\DoxyCodeLine{627       DenseVector<double> sw(-\/ne);}
\DoxyCodeLine{628       \textcolor{keywordtype}{double} west = e -\/> get\_x(sw)[ 0 ];}
\DoxyCodeLine{629       \textcolor{keywordtype}{double} east = e -\/> get\_x(ne)[ 0 ];}
\DoxyCodeLine{630       \textcolor{keywordflow}{if}((x[ 0 ] >= west) \&\& (x[ 0 ] <= east)) \{}
\DoxyCodeLine{631         \textcolor{keywordflow}{break};}
\DoxyCodeLine{632       \}}
\DoxyCodeLine{633       ++e;}
\DoxyCodeLine{634     \}}
\DoxyCodeLine{635 }
\DoxyCodeLine{636     \textcolor{keywordflow}{while}(\textcolor{keyword}{true}) \{}
\DoxyCodeLine{637       \textcolor{comment}{// local coordinates of the NE and SW corners}}
\DoxyCodeLine{638       DenseVector<double> ne(2, 1.0);}
\DoxyCodeLine{639       DenseVector<double> sw(-\/ne);}
\DoxyCodeLine{640       \textcolor{keywordtype}{double} south = e -\/> get\_x(sw)[ 1 ];}
\DoxyCodeLine{641       \textcolor{keywordtype}{double} north = e -\/> get\_x(ne)[ 1 ];}
\DoxyCodeLine{642       \textcolor{keywordflow}{if}((x[ 1 ] >= south) \&\& (x[ 1 ] <= north)) \{}
\DoxyCodeLine{643         \textcolor{keywordflow}{break};}
\DoxyCodeLine{644       \}}
\DoxyCodeLine{645       \textcolor{keywordflow}{if}(e + Mx < elts -\/> end()) \{}
\DoxyCodeLine{646         e += Mx;}
\DoxyCodeLine{647       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{648         \textcolor{comment}{// if we are here, then we're looking for a point outside the mesh}}
\DoxyCodeLine{649         std::string problem;}
\DoxyCodeLine{650         problem = \textcolor{stringliteral}{"The TwoD\_TVDLF\_Mesh::get\_elt\_iter\_from\_x method has been called\(\backslash\)n"};}
\DoxyCodeLine{651         problem += \textcolor{stringliteral}{"for a position that is outside the boundaries of the mesh.\(\backslash\)n"};}
\DoxyCodeLine{652         \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{653       \}}
\DoxyCodeLine{654     \}}
\DoxyCodeLine{655     \textcolor{comment}{// if we get to here, then we've found the elt.}}
\DoxyCodeLine{656     \textcolor{keywordflow}{return} e;}
\DoxyCodeLine{657   \}}

\end{DoxyCode}


References get\+\_\+elts\+\_\+from\+\_\+colour(), and get\+\_\+number\+\_\+elts\+\_\+in\+\_\+x().



Referenced by get\+\_\+point\+\_\+values().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a0d5861902c5f0e81c98194ef93a281f2}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!get\_elts\_from\_colour@{get\_elts\_from\_colour}}
\index{get\_elts\_from\_colour@{get\_elts\_from\_colour}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{get\_elts\_from\_colour()}
{\footnotesize\ttfamily std\+::vector$<$ \textbf{ Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Elt} $>$ $\ast$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+elts\+\_\+from\+\_\+colour (\begin{DoxyParamCaption}\item[{std\+::string}]{mesh\+\_\+colour }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Given a choice of black or red mesh, return a pointer to the appropriate vector of elements. 


\begin{DoxyParams}{Parameters}
{\em mesh\+\_\+colour} & A mesh identifier (black or red) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to a std\+::vector of elements 
\end{DoxyReturn}


Definition at line 660 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{660                                                                                         \{}
\DoxyCodeLine{661     vector\_of\_elts* elts;}
\DoxyCodeLine{662     \textcolor{keywordflow}{if}(mesh\_colour == \textcolor{stringliteral}{"black"}) \{}
\DoxyCodeLine{663       elts = \&BLACK\_ELTS;}
\DoxyCodeLine{664     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(mesh\_colour == \textcolor{stringliteral}{"red"}) \{}
\DoxyCodeLine{665       elts = \&RED\_ELTS;}
\DoxyCodeLine{666     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{667       std::string problem;}
\DoxyCodeLine{668       problem = \textcolor{stringliteral}{" The TwoD\_TVDLF\_Mesh object has been passed an unrecognised mesh identifier. \(\backslash\)n"};}
\DoxyCodeLine{669       problem += \textcolor{stringliteral}{" valid options are 'black' or 'red'.\(\backslash\)n"};}
\DoxyCodeLine{670       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{671     \}}
\DoxyCodeLine{672     \textcolor{keywordflow}{return} elts;}
\DoxyCodeLine{673   \}}

\end{DoxyCode}


References B\+L\+A\+C\+K\+\_\+\+E\+L\+TS, and R\+E\+D\+\_\+\+E\+L\+TS.



Referenced by get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+x(), and integrate().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a2d24e752d4f794d6daf1a88739310066}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!get\_number\_elts\_in\_x@{get\_number\_elts\_in\_x}}
\index{get\_number\_elts\_in\_x@{get\_number\_elts\_in\_x}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{get\_number\_elts\_in\_x()}
{\footnotesize\ttfamily std\+::size\+\_\+t Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+number\+\_\+elts\+\_\+in\+\_\+x (\begin{DoxyParamCaption}\item[{std\+::string}]{mesh\+\_\+colour }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Given a choice of black or red mesh, return the number of elements in the x-\/direction. 


\begin{DoxyParams}{Parameters}
{\em mesh\+\_\+colour} & A mesh identifier (black or red) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of elts in the x-\/direction 
\end{DoxyReturn}


Definition at line 675 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{675                                                                        \{}
\DoxyCodeLine{676     std::size\_t N;}
\DoxyCodeLine{677     \textcolor{keywordflow}{if}(mesh\_colour == \textcolor{stringliteral}{"black"}) \{}
\DoxyCodeLine{678       N = NX -\/ 1;}
\DoxyCodeLine{679     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(mesh\_colour == \textcolor{stringliteral}{"red"}) \{}
\DoxyCodeLine{680       N = NX;}
\DoxyCodeLine{681     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{682       std::string problem;}
\DoxyCodeLine{683       problem = \textcolor{stringliteral}{" The TwoD\_TVDLF\_Mesh object has been passed an unrecognised mesh identifier. \(\backslash\)n"};}
\DoxyCodeLine{684       problem += \textcolor{stringliteral}{" valid options are 'black' or 'red'.\(\backslash\)n"};}
\DoxyCodeLine{685       \textcolor{keywordflow}{throw} ExceptionRuntime(problem);}
\DoxyCodeLine{686     \}}
\DoxyCodeLine{687     \textcolor{keywordflow}{return} N;}
\DoxyCodeLine{688   \}}

\end{DoxyCode}


References NX.



Referenced by get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+x().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a20c5822ba65f98f5d2de121964c11c17}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!get\_point\_values@{get\_point\_values}}
\index{get\_point\_values@{get\_point\_values}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{get\_point\_values()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+point\+\_\+values (\begin{DoxyParamCaption}\item[{const \textbf{ Dense\+Vector}$<$ double $>$ \&}]{x }\end{DoxyParamCaption})}



Get the vector of unknowns at a point in the 2D mesh. 


\begin{DoxyParams}{Parameters}
{\em x} & The global coordinate at which to return the values \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The vector of unknowns 
\end{DoxyReturn}


Definition at line 491 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{491                                                                                     \{}
\DoxyCodeLine{492     elt\_iter e(get\_elt\_iter\_from\_x(x));}
\DoxyCodeLine{493     DenseVector<double> s(e-\/> get\_s(x));}
\DoxyCodeLine{494     \textcolor{keywordflow}{return} e -\/> get\_Q(s);}
\DoxyCodeLine{495   \}}

\end{DoxyCode}


References get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+x(), and Cpp\+Noddy\+::\+Example\+::s.



Referenced by main().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_ab66113b40fb42c09e923f06d036a558c}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!get\_time@{get\_time}}
\index{get\_time@{get\_time}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{get\_time()}
{\footnotesize\ttfamily const double \& Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::get\+\_\+time (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Get a const reference to the time value for the current mesh. 

\begin{DoxyReturn}{Returns}
time The time level at which the data in the mesh applies. 
\end{DoxyReturn}


Definition at line 601 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{601                                                 \{}
\DoxyCodeLine{602     \textcolor{keywordflow}{return} MESH\_TIME;}
\DoxyCodeLine{603   \}}

\end{DoxyCode}


References M\+E\+S\+H\+\_\+\+T\+I\+ME.



Referenced by main().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a3b5138e86d8ab374df7b2a33d6c0d2c4}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!integrate@{integrate}}
\index{integrate@{integrate}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{integrate()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::integrate (\begin{DoxyParamCaption}\item[{std\+::string}]{mesh\+\_\+colour = {\ttfamily \char`\"{}black\char`\"{}} }\end{DoxyParamCaption})}



Integrate the concentration values across the entire mesh. 


\begin{DoxyParams}{Parameters}
{\em mesh\+\_\+colour} & The identifier of which mesh to integrate over \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The vector value of the integral 
\end{DoxyReturn}


Definition at line 605 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{605                                                                       \{}
\DoxyCodeLine{606     vector\_of\_elts* elts(get\_elts\_from\_colour(mesh\_colour));}
\DoxyCodeLine{607     elt\_iter e = elts -\/> begin();}
\DoxyCodeLine{608     DenseVector<double> I(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{609     \textcolor{keywordflow}{while}(e != elts -\/> end()) \{}
\DoxyCodeLine{610       \textcolor{keyword}{const} DenseVector<double> sw(2, -\/1.0);}
\DoxyCodeLine{611       \textcolor{keyword}{const} DenseVector<double> ne(2, 1.0);}
\DoxyCodeLine{612       I += e -\/> get\_int\_Q(sw, ne);}
\DoxyCodeLine{613       ++e;}
\DoxyCodeLine{614     \}}
\DoxyCodeLine{615     \textcolor{keywordflow}{return} I;}
\DoxyCodeLine{616   \}}

\end{DoxyCode}


References get\+\_\+elts\+\_\+from\+\_\+colour(), and O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM.

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_acce5259b2592d40ce412da2b8c815eb8}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!maxmod@{maxmod}}
\index{maxmod@{maxmod}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{maxmod()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::maxmod (\begin{DoxyParamCaption}\item[{\textbf{ Dense\+Vector}$<$ double $>$}]{A,  }\item[{\textbf{ Dense\+Vector}$<$ double $>$}]{B }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}



A vector version of the maxmod operator. 


\begin{DoxyParams}{Parameters}
{\em A} & A vector to compare \\
\hline
{\em B} & A vector to compare \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A component-\/wise maxmod vector, i.\+e., each component of the returned vector is the maxmod of the components of A \& B. 
\end{DoxyReturn}


Definition at line 883 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{883                                                                                                 \{}
\DoxyCodeLine{884     DenseVector<double> MM;}
\DoxyCodeLine{885     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < A.size(); ++i) \{}
\DoxyCodeLine{886       MM.push\_back(0.5 * (sgn(A[i]) + sgn(B[i]))}
\DoxyCodeLine{887                    * std::max(std::abs(A[i]), std::abs(B[i])));}
\DoxyCodeLine{888     \}}
\DoxyCodeLine{889     \textcolor{keywordflow}{return} MM;}
\DoxyCodeLine{890   \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Example\+::\+A(), Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::push\+\_\+back(), and sgn().



Referenced by calc\+\_\+slopes().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a34f1c4f3fcf34d33e5892f01318bcee2}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!minmod@{minmod}}
\index{minmod@{minmod}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{minmod()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::minmod (\begin{DoxyParamCaption}\item[{\textbf{ Dense\+Vector}$<$ double $>$}]{A,  }\item[{\textbf{ Dense\+Vector}$<$ double $>$}]{B }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}



A vector version of the minmod operator. 


\begin{DoxyParams}{Parameters}
{\em A} & A vector to compare \\
\hline
{\em B} & A vector to compare \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A component-\/wise minmod vector, i.\+e., each component of the returned vector is the minmod of the components of A \& B. 
\end{DoxyReturn}


Definition at line 874 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{874                                                                                                 \{}
\DoxyCodeLine{875     DenseVector<double> MM;}
\DoxyCodeLine{876     \textcolor{keywordflow}{for}(std::size\_t i = 0; i < A.size(); ++i) \{}
\DoxyCodeLine{877       MM.push\_back(0.5 * (sgn(A[i]) + sgn(B[i]))}
\DoxyCodeLine{878                    * std::min(std::abs(A[i]), std::abs(B[i])));}
\DoxyCodeLine{879     \}}
\DoxyCodeLine{880     \textcolor{keywordflow}{return} MM;}
\DoxyCodeLine{881   \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+Example\+::\+A(), Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::push\+\_\+back(), and sgn().



Referenced by calc\+\_\+slopes().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_ad83fa9116e43f6f5e99d390ad64a3cb5}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!north\_diff@{north\_diff}}
\index{north\_diff@{north\_diff}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{north\_diff()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::north\+\_\+diff (\begin{DoxyParamCaption}\item[{\textbf{ elt\+\_\+iter}}]{e }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}



Compute a finite difference approximation of the derivative in the compass direction. 


\begin{DoxyParams}{Parameters}
{\em e} & The iterator to the element that we want the derivative for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The spatial derivative of the vector system 
\end{DoxyReturn}


Definition at line 788 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{788                                                                   \{}
\DoxyCodeLine{789     DenseVector<double> diff(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{790     std::set< int > faces(e -\/> get\_external\_faces());}
\DoxyCodeLine{791     \textcolor{keyword}{const} \textcolor{keywordtype}{int} face\_index(2);}
\DoxyCodeLine{792     \textcolor{keywordflow}{if}(e -\/> face\_is\_external(face\_index)) \{}
\DoxyCodeLine{793       \textcolor{comment}{// interior difference}}
\DoxyCodeLine{794       diff = south\_diff(e);}
\DoxyCodeLine{795       boundary\_diff(e, face\_index, diff);}
\DoxyCodeLine{796     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{797       \textcolor{comment}{// We're not on an edge, so we can difference}}
\DoxyCodeLine{798       elt\_iter j(e -\/> get\_ptrs(face\_index));}
\DoxyCodeLine{799       diff = (j -\/> get\_Q\_mid() -\/ e -\/> get\_Q\_mid())}
\DoxyCodeLine{800              / (j -\/> get\_x\_mid()[1] -\/ e -\/> get\_x\_mid()[1]);}
\DoxyCodeLine{801     \}}
\DoxyCodeLine{802     \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{803   \}}

\end{DoxyCode}


References boundary\+\_\+diff(), O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM, and south\+\_\+diff().



Referenced by calc\+\_\+slopes(), N\+S\+\_\+diff(), and south\+\_\+diff().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_acb23e6b0de50220e3fd66dafd295652d}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!NS\_diff@{NS\_diff}}
\index{NS\_diff@{NS\_diff}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{NS\_diff()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::\+N\+S\+\_\+diff (\begin{DoxyParamCaption}\item[{\textbf{ elt\+\_\+iter}}]{e }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Compute a finite difference approximation of the derivative in the compass direction. 


\begin{DoxyParams}{Parameters}
{\em e} & The iterator to the element that we want the derivative for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The spatial derivative of the vector system 
\end{DoxyReturn}


Definition at line 822 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{822                                                          \{}
\DoxyCodeLine{823     DenseVector<double> diff(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{824     std::set< int > faces(e -\/> get\_external\_faces());}
\DoxyCodeLine{825     \textcolor{keywordflow}{if}(e -\/> face\_is\_external(0)) \{}
\DoxyCodeLine{826       \textcolor{comment}{// interior difference}}
\DoxyCodeLine{827       diff = north\_diff(e);}
\DoxyCodeLine{828       boundary\_diff(e, 0, diff);}
\DoxyCodeLine{829     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(e -\/> face\_is\_external(2)) \{}
\DoxyCodeLine{830       \textcolor{comment}{// interior difference}}
\DoxyCodeLine{831       diff = south\_diff(e);}
\DoxyCodeLine{832       boundary\_diff(e, 2, diff);}
\DoxyCodeLine{833     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{834       \textcolor{comment}{// We're not on an edge, so we can difference}}
\DoxyCodeLine{835       elt\_iter jS(e -\/> get\_ptrs(0));}
\DoxyCodeLine{836       elt\_iter jN(e -\/> get\_ptrs(2));}
\DoxyCodeLine{837       diff = (jN -\/> get\_Q\_mid() -\/ jS -\/> get\_Q\_mid())}
\DoxyCodeLine{838              / (jN -\/> get\_x\_mid()[1] -\/ jS -\/> get\_x\_mid()[1]);}
\DoxyCodeLine{839     \}}
\DoxyCodeLine{840     \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{841   \}}

\end{DoxyCode}


References boundary\+\_\+diff(), north\+\_\+diff(), O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM, and south\+\_\+diff().



Referenced by calc\+\_\+slopes().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_aae83a8f223ddd1cbb65b1a596fe53ac8}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!set\_boundary\_Q@{set\_boundary\_Q}}
\index{set\_boundary\_Q@{set\_boundary\_Q}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{set\_boundary\_Q()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::set\+\_\+boundary\+\_\+Q (\begin{DoxyParamCaption}\item[{\textbf{ vector\+\_\+of\+\_\+elts} $\ast$}]{elts }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



Loops over all boundary elements and sets the Q values in each one to be the value specified by the edge\+\_\+values method. 


\begin{DoxyParams}{Parameters}
{\em elts} & A vector of elements in the mesh \\
\hline
\end{DoxyParams}


Definition at line 319 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{319                                               \{}
\DoxyCodeLine{320       \textcolor{comment}{// loop over all elts}}
\DoxyCodeLine{321       elt\_iter e(elts -\/> begin());}
\DoxyCodeLine{322       \textcolor{keywordflow}{while}(e != elts -\/> end()) \{}
\DoxyCodeLine{323         \textcolor{comment}{// find the external elts that are on the boundary}}
\DoxyCodeLine{324         \textcolor{keywordflow}{if}(e -\/> get\_external\_flag()) \{}
\DoxyCodeLine{325           std::set<int> faces(e -\/> get\_external\_faces());}
\DoxyCodeLine{326           std::set<int>::iterator i(faces.begin());}
\DoxyCodeLine{327           \textcolor{comment}{// loop through all external faces (there are 2 on corner elts)}}
\DoxyCodeLine{328           \textcolor{keywordflow}{while}(i != faces.end()) \{}
\DoxyCodeLine{329             \textcolor{keywordtype}{int} face(*i);}
\DoxyCodeLine{330             \textcolor{comment}{// local coordinate at which to impose the BC}}
\DoxyCodeLine{331             DenseVector<double> s(2, 0.0);}
\DoxyCodeLine{332             \textcolor{keywordflow}{switch}(face) \{}
\DoxyCodeLine{333             \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{334               s[ 0 ] = 0.0;}
\DoxyCodeLine{335               s[ 1 ] = -\/1.0;}
\DoxyCodeLine{336               \textcolor{keywordflow}{break};}
\DoxyCodeLine{337             \textcolor{keywordflow}{case} 1:}
\DoxyCodeLine{338               s[ 0 ] = 1.0;}
\DoxyCodeLine{339               s[ 1 ] = 0.0;}
\DoxyCodeLine{340               \textcolor{keywordflow}{break};}
\DoxyCodeLine{341             \textcolor{keywordflow}{case} 2:}
\DoxyCodeLine{342               s[ 0 ] = 0.0;}
\DoxyCodeLine{343               s[ 1 ] = 1.0;}
\DoxyCodeLine{344               \textcolor{keywordflow}{break};}
\DoxyCodeLine{345             \textcolor{keywordflow}{case} 3:}
\DoxyCodeLine{346               s[ 0 ] = -\/1.0;}
\DoxyCodeLine{347               s[ 1 ] = 0.0;}
\DoxyCodeLine{348               \textcolor{keywordflow}{break};}
\DoxyCodeLine{349             \}}
\DoxyCodeLine{350             \textcolor{comment}{// get the current edge data}}
\DoxyCodeLine{351             DenseVector<double> Qe(e -\/> get\_Q(s));\textcolor{comment}{}}
\DoxyCodeLine{352 \textcolor{comment}{            //// initialise the normal slope vector}}
\DoxyCodeLine{353 \textcolor{comment}{}            \textcolor{comment}{// DenseVector<double> sigma\_n( ORDER\_OF\_SYSTEM, 0.0 );}}
\DoxyCodeLine{354             \textcolor{comment}{// get the user specified edge values}}
\DoxyCodeLine{355             std::vector<bool> inflow = e -\/> p\_system -\/> edge\_values(face, e -\/> get\_x(s), Qe);     \textcolor{comment}{//, sigma\_n );}}
\DoxyCodeLine{356             \textcolor{comment}{// get the mid-\/element nodal data}}
\DoxyCodeLine{357             DenseVector<double> Qm(e -\/> get\_Q\_mid());}
\DoxyCodeLine{358             \textcolor{keywordflow}{for}(std::size\_t j = 0; j < ORDER\_OF\_SYSTEM; ++j) \{}
\DoxyCodeLine{359               \textcolor{keywordflow}{if}(inflow[ j ] == \textcolor{keyword}{true}) \{}
\DoxyCodeLine{360                 \textcolor{comment}{// only change components that are inflow}}
\DoxyCodeLine{361                 Qm[ j ] = Qe[ j ];}
\DoxyCodeLine{362               \}}
\DoxyCodeLine{363             \}}
\DoxyCodeLine{364             e -\/> set\_Q\_mid(Qm);}
\DoxyCodeLine{365             ++i;}
\DoxyCodeLine{366           \}}
\DoxyCodeLine{367         \}}
\DoxyCodeLine{368         ++e;}
\DoxyCodeLine{369       \}}
\DoxyCodeLine{370     \}}

\end{DoxyCode}


References O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM, and Cpp\+Noddy\+::\+Example\+::s.



Referenced by calc\+\_\+slopes().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_ae747dbc5e1f57c8d50f607c3a7460882}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!set\_limiter@{set\_limiter}}
\index{set\_limiter@{set\_limiter}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{set\_limiter()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::set\+\_\+limiter (\begin{DoxyParamCaption}\item[{const unsigned \&}]{id }\end{DoxyParamCaption})}



Set the limiter type to be applied in the slope values. 


\begin{DoxyParams}{Parameters}
{\em id} & The identifier of the limiter. \\
\hline
\end{DoxyParams}


Definition at line 497 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{497                                                       \{}
\DoxyCodeLine{498     LIMITER = id;}
\DoxyCodeLine{499   \}}

\end{DoxyCode}


References L\+I\+M\+I\+T\+ER.



Referenced by main().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_aa84361bbe7825bee9656f5239d14f014}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!sgn@{sgn}}
\index{sgn@{sgn}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{sgn()}
{\footnotesize\ttfamily int Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::sgn (\begin{DoxyParamCaption}\item[{double}]{a }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}



Sign of a double. 


\begin{DoxyParams}{Parameters}
{\em a} & The value to return the sign of \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The sign of the value 
\end{DoxyReturn}


Definition at line 864 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{864                                          \{}
\DoxyCodeLine{865     \textcolor{keywordflow}{if}(a > 0.0) \{}
\DoxyCodeLine{866       \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{867     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(a < 0.0) \{}
\DoxyCodeLine{868       \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{869     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{870       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{871     \}}
\DoxyCodeLine{872   \}}

\end{DoxyCode}


Referenced by maxmod(), and minmod().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a4decfe39425c306e20082fb6d46bd311}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!south\_diff@{south\_diff}}
\index{south\_diff@{south\_diff}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{south\_diff()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::south\+\_\+diff (\begin{DoxyParamCaption}\item[{\textbf{ elt\+\_\+iter}}]{e }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}



Compute a finite difference approximation of the derivative in the compass direction. 


\begin{DoxyParams}{Parameters}
{\em e} & The iterator to the element that we want the derivative for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The spatial derivative of the vector system 
\end{DoxyReturn}


Definition at line 805 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{805                                                                   \{}
\DoxyCodeLine{806     DenseVector<double> diff(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{807     std::set< int > faces(e -\/> get\_external\_faces());}
\DoxyCodeLine{808     \textcolor{keyword}{const} \textcolor{keywordtype}{int} face\_index(0);}
\DoxyCodeLine{809     \textcolor{keywordflow}{if}(e -\/> face\_is\_external(face\_index)) \{}
\DoxyCodeLine{810       \textcolor{comment}{// interior difference}}
\DoxyCodeLine{811       diff = north\_diff(e);}
\DoxyCodeLine{812       boundary\_diff(e, face\_index, diff);}
\DoxyCodeLine{813     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{814       \textcolor{comment}{// We're not on an edge, so we can difference}}
\DoxyCodeLine{815       elt\_iter j(e -\/> get\_ptrs(face\_index));}
\DoxyCodeLine{816       diff = (e -\/> get\_Q\_mid() -\/ j -\/> get\_Q\_mid())}
\DoxyCodeLine{817              / (e -\/> get\_x\_mid()[1] -\/ j -\/> get\_x\_mid()[1]);}
\DoxyCodeLine{818     \}}
\DoxyCodeLine{819     \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{820   \}}

\end{DoxyCode}


References boundary\+\_\+diff(), north\+\_\+diff(), and O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM.



Referenced by calc\+\_\+slopes(), north\+\_\+diff(), and N\+S\+\_\+diff().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_aca436e886eeca256b4dcc2ad254b307c}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!update@{update}}
\index{update@{update}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{update()}
{\footnotesize\ttfamily double Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::update (\begin{DoxyParamCaption}\item[{const double \&}]{C\+FL,  }\item[{const double \&}]{max\+\_\+dt = {\ttfamily std\+:\+:numeric\+\_\+limits$<$long~double$>$\+:\+:max()} }\end{DoxyParamCaption})}



Update the mesh object. 

A time step is chosen based upon the C\+FL constraint. 
\begin{DoxyParams}{Parameters}
{\em C\+FL} & The C\+FL constraint for the timestep (e.\+g. 0.\+49) \\
\hline
{\em max\+\_\+dt} & A maximum timestep to be taken irrespective of the C\+FL value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The total timestep that was taken 
\end{DoxyReturn}


Definition at line 501 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{501                                                                         \{}
\DoxyCodeLine{502     \textcolor{comment}{// integrate the black mesh data onto the red mesh}}
\DoxyCodeLine{503     std::cout << \textcolor{stringliteral}{"[DEBUG] in update with MESH\_TIME = "} << MESH\_TIME << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{504     std::cout << \textcolor{stringliteral}{"[DEBUG] in update with max\_dt = "} << max\_dt << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{505     }
\DoxyCodeLine{506     \{}
\DoxyCodeLine{507       elt\_iter e = RED\_ELTS.begin();}
\DoxyCodeLine{508       \textcolor{keywordflow}{while}(e != RED\_ELTS.end()) \{}
\DoxyCodeLine{509         e -\/> set\_Q\_mid(e -\/> contributed\_Q() / e -\/> get\_dA());}
\DoxyCodeLine{510         ++e;}
\DoxyCodeLine{511       \}}
\DoxyCodeLine{512     \}}
\DoxyCodeLine{513     calc\_slopes(\&RED\_ELTS);}
\DoxyCodeLine{514 }
\DoxyCodeLine{515     \textcolor{comment}{// determine the first time step from the CFL constraint}}
\DoxyCodeLine{516     \textcolor{keywordtype}{double} first\_dt;}
\DoxyCodeLine{517     \{}
\DoxyCodeLine{518       elt\_iter e = BLACK\_ELTS.begin();}
\DoxyCodeLine{519       first\_dt = e -\/> get\_max\_dt();}
\DoxyCodeLine{520       ++e;}
\DoxyCodeLine{521       \textcolor{keywordflow}{while}(e != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{522         first\_dt = std::min(first\_dt, e -\/> get\_max\_dt());}
\DoxyCodeLine{523         ++e;}
\DoxyCodeLine{524       \}}
\DoxyCodeLine{525       std::cout << \textcolor{stringliteral}{"[DEBUG] in update with first\_dt = "} << first\_dt << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{526       first\_dt *= CFL;}
\DoxyCodeLine{527       std::cout << \textcolor{stringliteral}{"[DEBUG] in update with first\_dt*CFL = "} << first\_dt << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{528     \}}
\DoxyCodeLine{529     \textcolor{keywordflow}{if}(first\_dt > max\_dt / 2) \{}
\DoxyCodeLine{530       first\_dt = max\_dt / 2;}
\DoxyCodeLine{531     \}}
\DoxyCodeLine{532     std::cout << \textcolor{stringliteral}{"[DEBUG] in update with final first\_dt = "} << first\_dt << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{533 }
\DoxyCodeLine{534     actions\_before\_time\_step1(first\_dt);}
\DoxyCodeLine{535     \textcolor{comment}{// do the time step}}
\DoxyCodeLine{536     \{}
\DoxyCodeLine{537       elt\_iter e = RED\_ELTS.begin();}
\DoxyCodeLine{538       \textcolor{keywordflow}{while}(e != RED\_ELTS.end()) \{}
\DoxyCodeLine{539         \textcolor{comment}{// add to the corrections}}
\DoxyCodeLine{540         e -\/> add\_flux\_contributions(first\_dt);}
\DoxyCodeLine{541         ++e;}
\DoxyCodeLine{542       \}}
\DoxyCodeLine{543     \}}
\DoxyCodeLine{544     calc\_slopes(\&RED\_ELTS);}
\DoxyCodeLine{545     MESH\_TIME += first\_dt;}
\DoxyCodeLine{546     std::cout << \textcolor{stringliteral}{"[DEBUG] in update with MESH\_TIME = "} << MESH\_TIME << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{547 }
\DoxyCodeLine{548     \textcolor{comment}{// integrate the red mesh data onto the black mesh}}
\DoxyCodeLine{549     \{}
\DoxyCodeLine{550       elt\_iter e = BLACK\_ELTS.begin();}
\DoxyCodeLine{551       \textcolor{keywordflow}{while}(e != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{552         e -\/> set\_Q\_mid(e -\/> contributed\_Q() / e -\/> get\_dA());}
\DoxyCodeLine{553         ++e;}
\DoxyCodeLine{554       \}}
\DoxyCodeLine{555     \}}
\DoxyCodeLine{556     calc\_slopes(\&BLACK\_ELTS);}
\DoxyCodeLine{557 }
\DoxyCodeLine{558     \textcolor{comment}{// determine the first time step from the CFL constraint}}
\DoxyCodeLine{559     \textcolor{keywordtype}{double} second\_dt;}
\DoxyCodeLine{560     \{}
\DoxyCodeLine{561       elt\_iter e = RED\_ELTS.begin();}
\DoxyCodeLine{562       second\_dt = e -\/> get\_max\_dt();}
\DoxyCodeLine{563       ++e;}
\DoxyCodeLine{564       \textcolor{keywordflow}{while}(e != RED\_ELTS.end()) \{}
\DoxyCodeLine{565         second\_dt = std::min(second\_dt, e -\/> get\_max\_dt());}
\DoxyCodeLine{566         ++e;}
\DoxyCodeLine{567       \}}
\DoxyCodeLine{568       std::cout << \textcolor{stringliteral}{"[DEBUG] in update with second\_dt = "} << second\_dt << \textcolor{stringliteral}{"\(\backslash\)n"};      }
\DoxyCodeLine{569       second\_dt *= CFL;}
\DoxyCodeLine{570       std::cout << \textcolor{stringliteral}{"[DEBUG] in update with second\_dt*CFL = "} << second\_dt << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{571     \}}
\DoxyCodeLine{572     \textcolor{keywordflow}{if}(first\_dt + second\_dt > max\_dt) \{}
\DoxyCodeLine{573       second\_dt = max\_dt -\/ first\_dt;}
\DoxyCodeLine{574     \}}
\DoxyCodeLine{575     std::cout << \textcolor{stringliteral}{"[DEBUG] in update with final second\_dt = "} << second\_dt << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{576     }
\DoxyCodeLine{577     actions\_before\_time\_step2(second\_dt);}
\DoxyCodeLine{578     \textcolor{comment}{// do the time step}}
\DoxyCodeLine{579     \{}
\DoxyCodeLine{580       elt\_iter e = BLACK\_ELTS.begin();}
\DoxyCodeLine{581       \textcolor{keywordflow}{while}(e != BLACK\_ELTS.end()) \{}
\DoxyCodeLine{582         \textcolor{comment}{// add to the corrections}}
\DoxyCodeLine{583         e -\/> add\_flux\_contributions(second\_dt);}
\DoxyCodeLine{584         ++e;}
\DoxyCodeLine{585       \}}
\DoxyCodeLine{586     \}}
\DoxyCodeLine{587     calc\_slopes(\&BLACK\_ELTS);}
\DoxyCodeLine{588     MESH\_TIME += second\_dt;}
\DoxyCodeLine{589     std::cout << \textcolor{stringliteral}{"[DEBUG] in update with MESH\_TIME = "} << MESH\_TIME << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{590     }
\DoxyCodeLine{591     \textcolor{keywordflow}{return} first\_dt + second\_dt;}
\DoxyCodeLine{592   \}}

\end{DoxyCode}


References actions\+\_\+before\+\_\+time\+\_\+step1(), actions\+\_\+before\+\_\+time\+\_\+step2(), B\+L\+A\+C\+K\+\_\+\+E\+L\+TS, calc\+\_\+slopes(), M\+E\+S\+H\+\_\+\+T\+I\+ME, and R\+E\+D\+\_\+\+E\+L\+TS.



Referenced by main(), and update\+\_\+to().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a3c7b46d508af0452fc7d7aa334f3d3e4}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!update\_to@{update\_to}}
\index{update\_to@{update\_to}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{update\_to()}
{\footnotesize\ttfamily void Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::update\+\_\+to (\begin{DoxyParamCaption}\item[{const double \&}]{C\+FL,  }\item[{const double \&}]{t\+\_\+end }\end{DoxyParamCaption})}



Update the mesh object to a set time level. 

A time step is chosen based upon the C\+FL constraint. 
\begin{DoxyParams}{Parameters}
{\em C\+FL} & The C\+FL constraint for the timestep (e.\+g. 0.\+49) \\
\hline
{\em t\+\_\+end} & The target end time. \\
\hline
\end{DoxyParams}


Definition at line 594 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{594                                                                         \{}
\DoxyCodeLine{595     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{596       std::cout << \textcolor{stringliteral}{"    computing to "} << t\_end << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{597       update(CFL, std::abs(t\_end -\/ MESH\_TIME));}
\DoxyCodeLine{598     \} \textcolor{keywordflow}{while}(MESH\_TIME < t\_end);}
\DoxyCodeLine{599   \}}

\end{DoxyCode}


References M\+E\+S\+H\+\_\+\+T\+I\+ME, and update().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a484f892ebc298dfa4bd87581399595a1}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!west\_diff@{west\_diff}}
\index{west\_diff@{west\_diff}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{west\_diff()}
{\footnotesize\ttfamily \textbf{ Dense\+Vector}$<$ double $>$ Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::west\+\_\+diff (\begin{DoxyParamCaption}\item[{\textbf{ elt\+\_\+iter}}]{e }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}



Compute a finite difference approximation of the derivative in the compass direction. 


\begin{DoxyParams}{Parameters}
{\em e} & The iterator to the element that we want the derivative for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The spatial derivative of the vector system 
\end{DoxyReturn}


Definition at line 771 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{771                                                                  \{}
\DoxyCodeLine{772     DenseVector<double> diff(ORDER\_OF\_SYSTEM, 0.0);}
\DoxyCodeLine{773     std::set< int > faces(e -\/> get\_external\_faces());}
\DoxyCodeLine{774     \textcolor{keyword}{const} \textcolor{keywordtype}{int} face\_index(3);}
\DoxyCodeLine{775     \textcolor{keywordflow}{if}(e -\/> face\_is\_external(face\_index)) \{}
\DoxyCodeLine{776       \textcolor{comment}{// interior difference}}
\DoxyCodeLine{777       diff = east\_diff(e);}
\DoxyCodeLine{778       boundary\_diff(e, face\_index, diff);}
\DoxyCodeLine{779     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{780       \textcolor{comment}{// We're not on an edge, so we can difference}}
\DoxyCodeLine{781       elt\_iter j(e -\/> get\_ptrs(face\_index));}
\DoxyCodeLine{782       diff = (e -\/> get\_Q\_mid() -\/ j -\/> get\_Q\_mid())}
\DoxyCodeLine{783              / (e -\/> get\_x\_mid()[0] -\/ j -\/> get\_x\_mid()[0]);}
\DoxyCodeLine{784     \}}
\DoxyCodeLine{785     \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{786   \}}

\end{DoxyCode}


References boundary\+\_\+diff(), east\+\_\+diff(), and O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM.



Referenced by calc\+\_\+slopes(), east\+\_\+diff(), and E\+W\+\_\+diff().



\doxysubsubsection{Member Data Documentation}
\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a8733b332f46886d0e1807896779d0dc1}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!BLACK\_ELTS@{BLACK\_ELTS}}
\index{BLACK\_ELTS@{BLACK\_ELTS}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{BLACK\_ELTS}
{\footnotesize\ttfamily \textbf{ vector\+\_\+of\+\_\+elts} Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::\+B\+L\+A\+C\+K\+\_\+\+E\+L\+TS}



An S\+TL vector of linear elements -- the black mesh. 



Definition at line 126 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.



Referenced by dump\+\_\+data(), dump\+\_\+gnu(), dump\+\_\+nodes\+\_\+x(), dump\+\_\+nodes\+\_\+y(), get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+elt\+\_\+iter(), get\+\_\+elts\+\_\+from\+\_\+colour(), Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh(), and update().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a3e91c98452dd2959e58c7415face8dd0}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!LIMITER@{LIMITER}}
\index{LIMITER@{LIMITER}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{LIMITER}
{\footnotesize\ttfamily unsigned Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::\+L\+I\+M\+I\+T\+ER\hspace{0.3cm}{\ttfamily [protected]}}



Slope limiter method. 



Definition at line 373 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.



Referenced by calc\+\_\+slopes(), set\+\_\+limiter(), and Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_aed5955b66865ad3632f8e6c1fd6fb452}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!MESH\_TIME@{MESH\_TIME}}
\index{MESH\_TIME@{MESH\_TIME}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{MESH\_TIME}
{\footnotesize\ttfamily double Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::\+M\+E\+S\+H\+\_\+\+T\+I\+ME\hspace{0.3cm}{\ttfamily [protected]}}



the time level of the mesh 



Definition at line 379 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.



Referenced by get\+\_\+time(), Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh(), update(), and update\+\_\+to().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_ad717030df9edb6ddc6f85b77dad7544c}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!NX@{NX}}
\index{NX@{NX}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{NX}
{\footnotesize\ttfamily std\+::size\+\_\+t Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::\+NX\hspace{0.3cm}{\ttfamily [protected]}}



number of faces in the x \& y directions 



Definition at line 377 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.



Referenced by dump\+\_\+nodes\+\_\+x(), dump\+\_\+nodes\+\_\+y(), get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+elt\+\_\+iter(), get\+\_\+number\+\_\+elts\+\_\+in\+\_\+x(), and Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_ad341d85575a68e9dee3019bc7f6f59e8}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!NY@{NY}}
\index{NY@{NY}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{NY}
{\footnotesize\ttfamily std\+::size\+\_\+t Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::\+NY\hspace{0.3cm}{\ttfamily [protected]}}



Definition at line 377 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.



Referenced by dump\+\_\+nodes\+\_\+y(), get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+elt\+\_\+iter(), and Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a9eec3b97a601960d91b98aeda2fc5f67}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!ORDER\_OF\_SYSTEM@{ORDER\_OF\_SYSTEM}}
\index{ORDER\_OF\_SYSTEM@{ORDER\_OF\_SYSTEM}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{ORDER\_OF\_SYSTEM}
{\footnotesize\ttfamily std\+::size\+\_\+t Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::\+O\+R\+D\+E\+R\+\_\+\+O\+F\+\_\+\+S\+Y\+S\+T\+EM\hspace{0.3cm}{\ttfamily [protected]}}



order of the conservative system 



Definition at line 375 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.



Referenced by boundary\+\_\+diff(), calc\+\_\+slopes(), dump\+\_\+data(), dump\+\_\+gnu(), east\+\_\+diff(), E\+W\+\_\+diff(), integrate(), north\+\_\+diff(), N\+S\+\_\+diff(), set\+\_\+boundary\+\_\+\+Q(), south\+\_\+diff(), Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh(), and west\+\_\+diff().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a9d7afaa9761defe23008485fac5a9910}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!p\_Q\_INIT@{p\_Q\_INIT}}
\index{p\_Q\_INIT@{p\_Q\_INIT}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{p\_Q\_INIT}
{\footnotesize\ttfamily \textbf{ fn\+\_\+ptr} Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::p\+\_\+\+Q\+\_\+\+I\+N\+IT\hspace{0.3cm}{\ttfamily [protected]}}



function pointer to a funnction that defines the initial distribution 



Definition at line 381 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.



Referenced by Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh().

\mbox{\label{classCppNoddy_1_1TwoD__TVDLF__Mesh_a189b1354824c9a9a0da7a12c598be461}} 
\index{CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}!RED\_ELTS@{RED\_ELTS}}
\index{RED\_ELTS@{RED\_ELTS}!CppNoddy::TwoD\_TVDLF\_Mesh@{CppNoddy::TwoD\_TVDLF\_Mesh}}
\doxyparagraph{RED\_ELTS}
{\footnotesize\ttfamily \textbf{ vector\+\_\+of\+\_\+elts} Cpp\+Noddy\+::\+Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh\+::\+R\+E\+D\+\_\+\+E\+L\+TS}



An S\+TL vector of linear elements -- the red mesh. 



Definition at line 128 of file Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h.



Referenced by get\+\_\+elt\+\_\+iter\+\_\+from\+\_\+elt\+\_\+iter(), get\+\_\+elts\+\_\+from\+\_\+colour(), Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh(), and update().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/\textbf{ Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+h}\item 
src/\textbf{ Two\+D\+\_\+\+T\+V\+D\+L\+F\+\_\+\+Mesh.\+cpp}\end{DoxyCompactItemize}
