\doxysubsection{Tests/\+Meshes/1\+D\+Node\+Mesh.cpp File Reference}
\label{1DNodeMesh_8cpp}\index{Tests/Meshes/1DNodeMesh.cpp@{Tests/Meshes/1DNodeMesh.cpp}}
{\ttfamily \#include $<$One\+D\+\_\+\+Node\+\_\+\+Mesh.\+h$>$}\newline
{\ttfamily \#include $<$Utility.\+h$>$}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \textbf{ main} ()
\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
A simple check of the One\+D\+\_\+\+Node\+\_\+\+Mesh container that stores nodal data over a given mesh. This checks that mesh data is interpolated and integrated correctly. We write $ \cos(x) $ to a uniform mesh, then check the integration routines converge appropriately. We then re-\/interpolate the data onto a non-\/uniform mesh and check the integral again. 

\doxysubsubsection{Function Documentation}
\mbox{\label{1DNodeMesh_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}} 
\index{1DNodeMesh.cpp@{1DNodeMesh.cpp}!main@{main}}
\index{main@{main}!1DNodeMesh.cpp@{1DNodeMesh.cpp}}
\doxyparagraph{main()}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 19 of file 1\+D\+Node\+Mesh.\+cpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{20 \{}
\DoxyCodeLine{21   cout.precision( 10 );}
\DoxyCodeLine{22   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{23   cout << \textcolor{stringliteral}{"=== OneD\_Node\_Mesh: wrapper =========================\(\backslash\)n"};}
\DoxyCodeLine{24   cout << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{25   cout << \textcolor{stringliteral}{" The test checks the convergence rate for an integral \(\backslash\)n"};}
\DoxyCodeLine{26   cout << \textcolor{stringliteral}{" over an increasing number of mesh points. \(\backslash\)n\(\backslash\)n"};}
\DoxyCodeLine{27 }
\DoxyCodeLine{28   \textcolor{keywordtype}{double} error\_trapezium = 1.0;}
\DoxyCodeLine{29   \textcolor{keywordtype}{double} error\_Simpson = 1.0;}
\DoxyCodeLine{30   \textcolor{keywordtype}{double} error\_remesh = 1.0;}
\DoxyCodeLine{31   \textcolor{keywordtype}{double} error\_diffroot = 0.0;}
\DoxyCodeLine{32 }
\DoxyCodeLine{33   \{}
\DoxyCodeLine{34     \textcolor{keywordtype}{double} old\_integral = 0.0;}
\DoxyCodeLine{35     \textcolor{keywordtype}{double} integral = 0.0;}
\DoxyCodeLine{36     std::size\_t n = 2;}
\DoxyCodeLine{37     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} jmax = 8;}
\DoxyCodeLine{38     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} j = 1; j <= jmax ; ++j )}
\DoxyCodeLine{39     \{}
\DoxyCodeLine{40       \textcolor{comment}{// A mesh of n points}}
\DoxyCodeLine{41       n *= 2;}
\DoxyCodeLine{42       n += 1;}
\DoxyCodeLine{43       \textcolor{comment}{// make a uniform mesh}}
\DoxyCodeLine{44       OneD\_Node\_Mesh<double> Q( Utility::uniform\_node\_vector( 0.0, 1.0, n ), 1 );}
\DoxyCodeLine{45 }
\DoxyCodeLine{46       \textcolor{comment}{// Set the variable values to be defined by a Cosine.}}
\DoxyCodeLine{47       \textcolor{keywordflow}{for} ( std::size\_t i = 0; i < n; ++i )}
\DoxyCodeLine{48       \{}
\DoxyCodeLine{49         \textcolor{comment}{// mesh stores cos(x)}}
\DoxyCodeLine{50         Q( i, 0 ) = cos( Q.coord( i ) );}
\DoxyCodeLine{51       \}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53       \textcolor{comment}{// cos integrates to sin(x) \& limits are 0 to 1}}
\DoxyCodeLine{54       integral = std::abs( Q.integral2( 0 ) -\/ sin( 1.0 ) );}
\DoxyCodeLine{55       \textcolor{keywordflow}{if} ( j > 1 )}
\DoxyCodeLine{56       \{}
\DoxyCodeLine{57         \textcolor{comment}{// Check the lin integral method.}}
\DoxyCodeLine{58         cout << \textcolor{stringliteral}{" n = "} << n << \textcolor{stringliteral}{" |Integral Error| = "} << integral}
\DoxyCodeLine{59              << \textcolor{stringliteral}{" Ratio = "} << old\_integral / integral << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{60       \}}
\DoxyCodeLine{61       old\_integral = integral;}
\DoxyCodeLine{62     \}}
\DoxyCodeLine{63     error\_trapezium = integral;}
\DoxyCodeLine{64   \}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66   cout << \textcolor{stringliteral}{"\(\backslash\)n Checking Simpson integration routine \(\backslash\)n\(\backslash\)n"};}
\DoxyCodeLine{67 }
\DoxyCodeLine{68   \{}
\DoxyCodeLine{69     \textcolor{keywordtype}{double} old\_integral = 0.0;}
\DoxyCodeLine{70     \textcolor{keywordtype}{double} integral = 0.0;}
\DoxyCodeLine{71     std::size\_t n = 2;}
\DoxyCodeLine{72     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} jmax = 8;}
\DoxyCodeLine{73     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} j = 1; j <= jmax ; ++j )}
\DoxyCodeLine{74     \{}
\DoxyCodeLine{75       \textcolor{comment}{// A mesh of n points}}
\DoxyCodeLine{76       n *= 2;}
\DoxyCodeLine{77       n += 1;}
\DoxyCodeLine{78       \textcolor{comment}{// make a uniform mesh}}
\DoxyCodeLine{79       OneD\_Node\_Mesh<double> Q( Utility::uniform\_node\_vector( 0.0, 1.0, n ), 1 );}
\DoxyCodeLine{80 }
\DoxyCodeLine{81       \textcolor{comment}{// Set the nodal values to be defined by a Cosine.}}
\DoxyCodeLine{82       \textcolor{keywordflow}{for} ( std::size\_t i = 0; i < n; ++i )}
\DoxyCodeLine{83       \{}
\DoxyCodeLine{84         \textcolor{comment}{// mesh contains cos(x)}}
\DoxyCodeLine{85         Q( i, 0 ) = cos( Q.coord( i ) );}
\DoxyCodeLine{86       \}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88       \textcolor{comment}{// mesh integrates to give sin(x) with limits 0 to 1}}
\DoxyCodeLine{89       integral = std::abs( Q.integral4( 0 ) -\/ sin( 1.0 ) );}
\DoxyCodeLine{90       \textcolor{keywordflow}{if} ( j > 1 )}
\DoxyCodeLine{91       \{}
\DoxyCodeLine{92         \textcolor{comment}{// Check the lin integral method.}}
\DoxyCodeLine{93         cout << \textcolor{stringliteral}{" n = "} << n << \textcolor{stringliteral}{" |Integral Error| = "} << integral}
\DoxyCodeLine{94              << \textcolor{stringliteral}{" Ratio = "} << old\_integral / integral << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{95       \}}
\DoxyCodeLine{96       old\_integral = integral;}
\DoxyCodeLine{97     \}}
\DoxyCodeLine{98     error\_Simpson = integral;}
\DoxyCodeLine{99   \}}
\DoxyCodeLine{100 }
\DoxyCodeLine{101   std::cout << \textcolor{stringliteral}{"\(\backslash\)n Checking the mesh linear interpolation. \(\backslash\)n"};}
\DoxyCodeLine{102   \{}
\DoxyCodeLine{103     \textcolor{keyword}{const} std::size\_t n = 501;}
\DoxyCodeLine{104 }
\DoxyCodeLine{105     \textcolor{comment}{// make a nonuniform mesh distribution}}
\DoxyCodeLine{106     OneD\_Node\_Mesh<D\_complex> Q( Utility::power\_node\_vector( 0.0, 1.0, n, 2.0 ), 1 );}
\DoxyCodeLine{107 }
\DoxyCodeLine{108     \textcolor{keywordflow}{for} ( std::size\_t i = 0; i < n; ++i )}
\DoxyCodeLine{109     \{}
\DoxyCodeLine{110       \textcolor{comment}{// set mesh to contain cos(x) but this time with non-\/uniform x nodes}}
\DoxyCodeLine{111       Q( i, 0 ) = std::cos( Q.coord( i ) );}
\DoxyCodeLine{112     \}}
\DoxyCodeLine{113 }
\DoxyCodeLine{114     \textcolor{comment}{// integrate over the nonuniform mesh}}
\DoxyCodeLine{115     \textcolor{keyword}{const} \textcolor{keywordtype}{double} Inonuniform = std::abs( Q.integral2( 0 ) );}
\DoxyCodeLine{116 }
\DoxyCodeLine{117     \textcolor{comment}{// make a uniform mesh of nodes}}
\DoxyCodeLine{118     DenseVector<double> Xuniform = Utility::uniform\_node\_vector( 0.0, 1.0, n );}
\DoxyCodeLine{119 }
\DoxyCodeLine{120     \textcolor{comment}{// remesh the nonlinear distribution to a uniform mesh}}
\DoxyCodeLine{121     Q.remesh1( Xuniform );}
\DoxyCodeLine{122 }
\DoxyCodeLine{123     \textcolor{keyword}{const} \textcolor{keywordtype}{double} Iuniform = std::abs( Q.integral2( 0 ) );}
\DoxyCodeLine{124     error\_remesh = std::abs( Inonuniform -\/ Iuniform );}
\DoxyCodeLine{125 }
\DoxyCodeLine{126     std::cout << \textcolor{stringliteral}{" |error| = "} << error\_remesh << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{127   \}}
\DoxyCodeLine{128 }
\DoxyCodeLine{129 }
\DoxyCodeLine{130   std::cout << \textcolor{stringliteral}{"\(\backslash\)n Checking mesh root interpolation. \(\backslash\)n"};}
\DoxyCodeLine{131   \{}
\DoxyCodeLine{132     \textcolor{keyword}{const} std::size\_t n = 401;}
\DoxyCodeLine{133 }
\DoxyCodeLine{134     OneD\_Node\_Mesh<double> F( Utility::uniform\_node\_vector( 0.0, 10.0, n ), 1 );}
\DoxyCodeLine{135 }
\DoxyCodeLine{136     \textcolor{keywordflow}{for} ( std::size\_t i = 0; i < n; ++i )}
\DoxyCodeLine{137     \{}
\DoxyCodeLine{138       \textcolor{comment}{// put sin(x) into var 0}}
\DoxyCodeLine{139       F( i, 0 ) = std::sin( F.coord( i ) );}
\DoxyCodeLine{140     \}}
\DoxyCodeLine{141 }
\DoxyCodeLine{142 }
\DoxyCodeLine{143     \textcolor{comment}{// find the roots of sin(x) with x in 0 to 10}}
\DoxyCodeLine{144     \{}
\DoxyCodeLine{145       DenseVector<double> roots( F.find\_roots1( 0 ) );}
\DoxyCodeLine{146       \textcolor{keywordflow}{for} ( std::size\_t i = 0; i < roots.size(); ++i )}
\DoxyCodeLine{147       \{}
\DoxyCodeLine{148         \textcolor{comment}{// roots should be ordered, so just check that they are at n * pi}}
\DoxyCodeLine{149         error\_diffroot = std::max( std::abs( roots[ i ] -\/ ( i + 1 ) * M\_PI ) , error\_diffroot );}
\DoxyCodeLine{150       \}}
\DoxyCodeLine{151     \}}
\DoxyCodeLine{152 }
\DoxyCodeLine{153   \}}
\DoxyCodeLine{154 }
\DoxyCodeLine{155   \textcolor{keywordflow}{if} ( ( error\_trapezium > 1.e-\/6 ) || ( error\_Simpson > 1.e-\/12 )}
\DoxyCodeLine{156        || ( error\_remesh > 1.e-\/6 ) || ( error\_diffroot > 1.e-\/6 ) )}
\DoxyCodeLine{157   \{}
\DoxyCodeLine{158     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;31;48m  * FAILED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{159     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{160   \}}
\DoxyCodeLine{161   \textcolor{keywordflow}{else}}
\DoxyCodeLine{162   \{}
\DoxyCodeLine{163     cout << \textcolor{stringliteral}{"\(\backslash\)033[1;32;48m  * PASSED \(\backslash\)033[0m\(\backslash\)n"};}
\DoxyCodeLine{164     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{165   \}}
\DoxyCodeLine{166 }
\DoxyCodeLine{167 \}}

\end{DoxyCode}


References Cpp\+Noddy\+::\+One\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::coord(), Cpp\+Noddy\+::\+One\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::find\+\_\+roots1(), Cpp\+Noddy\+::\+One\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::integral2(), Cpp\+Noddy\+::\+One\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::integral4(), Cpp\+Noddy\+::\+Utility\+::power\+\_\+node\+\_\+vector(), Cpp\+Noddy\+::\+One\+D\+\_\+\+Node\+\_\+\+Mesh$<$ \+\_\+\+Type, \+\_\+\+Xtype $>$\+::remesh1(), Cpp\+Noddy\+::\+Dense\+Vector$<$ \+\_\+\+Type $>$\+::size(), and Cpp\+Noddy\+::\+Utility\+::uniform\+\_\+node\+\_\+vector().

